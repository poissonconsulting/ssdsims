% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/run-scenario.R
\name{ssd_run_scenario}
\alias{ssd_run_scenario}
\alias{ssd_run_scenario.data.frame}
\alias{ssd_run_scenario.fitdists}
\alias{ssd_run_scenario.tmbfit}
\alias{ssd_run_scenario.character}
\alias{ssd_run_scenario.function}
\title{Run Scenario}
\usage{
ssd_run_scenario(x, ...)

\method{ssd_run_scenario}{data.frame}(
  x,
  ...,
  nrow = 6L,
  replace = FALSE,
  dists = ssdtools::ssd_dists_bcanz(),
  rescale = FALSE,
  computable = FALSE,
  at_boundary_ok = TRUE,
  min_pmix = list(ssdtools::ssd_min_pmix),
  proportion = 0.05,
  ci = FALSE,
  ci_method = "weighted_samples",
  seed = NULL,
  nsim = 100L,
  stream = getOption("ssdsims.stream", 1L),
  start_sim = 1L,
  .progress = FALSE
)

\method{ssd_run_scenario}{fitdists}(
  x,
  ...,
  nrow = 6L,
  dist_sim = "top",
  dists = ssdtools::ssd_dists_bcanz(),
  rescale = FALSE,
  computable = FALSE,
  at_boundary_ok = TRUE,
  min_pmix = list(ssdtools::ssd_min_pmix),
  proportion = 0.05,
  ci = FALSE,
  ci_method = "weighted_samples",
  seed = NULL,
  nsim = 100L,
  stream = getOption("ssdsims.stream", 1L),
  start_sim = 1L,
  .progress = FALSE
)

\method{ssd_run_scenario}{tmbfit}(
  x,
  ...,
  nrow = 6L,
  dists = ssdtools::ssd_dists_bcanz(),
  rescale = FALSE,
  computable = FALSE,
  at_boundary_ok = TRUE,
  min_pmix = list(ssdtools::ssd_min_pmix),
  proportion = 0.05,
  ci = FALSE,
  ci_method = "weighted_samples",
  seed = NULL,
  nsim = 100L,
  stream = getOption("ssdsims.stream", 1L),
  start_sim = 1L,
  .progress = FALSE
)

\method{ssd_run_scenario}{character}(
  x,
  ...,
  nrow = 6L,
  args = list(),
  dists = ssdtools::ssd_dists_bcanz(),
  rescale = FALSE,
  computable = FALSE,
  at_boundary_ok = TRUE,
  min_pmix = list(ssdtools::ssd_min_pmix),
  proportion = 0.05,
  ci = FALSE,
  ci_method = "weighted_samples",
  seed = NULL,
  nsim = 100L,
  stream = getOption("ssdsims.stream", 1L),
  start_sim = 1L,
  .progress = FALSE
)

\method{ssd_run_scenario}{`function`}(
  x,
  ...,
  nrow = 6L,
  args = list(),
  dists = ssdtools::ssd_dists_bcanz(),
  rescale = FALSE,
  computable = FALSE,
  at_boundary_ok = TRUE,
  min_pmix = list(ssdtools::ssd_min_pmix),
  proportion = 0.05,
  ci = FALSE,
  ci_method = "weighted_samples",
  seed = NULL,
  nsim = 100L,
  stream = getOption("ssdsims.stream", 1L),
  start_sim = 1L,
  .progress = FALSE
)
}
\arguments{
\item{x}{The object to use for the scenario.}

\item{...}{Unused.}

\item{nrow}{A positive whole number of the minimum number of non-missing rows.}

\item{replace}{A logical vector specifying whether to sample with replacement.}

\item{dists}{A character vector of the distribution names.}

\item{rescale}{A flag specifying whether to leave the values unchanged (FALSE) or to rescale concentration values by dividing by the geometric mean of the minimum and maximum positive finite values (TRUE) or a string specifying whether to leave the values unchanged ("no") or to rescale concentration values by dividing by the geometric mean of the minimum and maximum positive finite values ("geomean") or to logistically transform ("odds").}

\item{computable}{A flag specifying whether to only return fits with numerically computable standard errors.}

\item{at_boundary_ok}{A flag specifying whether a model with one or more
parameters at the boundary should be considered to have converged (default = TRUE).}

\item{min_pmix}{A number between 0 and 0.5 specifying the minimum proportion in mixture models.}

\item{proportion}{A numeric vector of proportion values to estimate hazard concentrations for.}

\item{ci}{A flag specifying whether to estimate confidence intervals (by bootstrapping).}

\item{ci_method}{A string specifying which method to use for estimating
the standard error and confidence limits from the bootstrap samples.
Possible values include \code{ci_method = "multi_fixed"} and  \code{ci_method = "multi_free"}
which generate the bootstrap samples using the model-averaged cumulative distribution function
but differ in whether the model weights are fixed at the values for the original dataset
or re-estimated for each bootstrap sample dataset.
The value \code{ci_method = "weighted_samples"} takes bootstrap samples
from each distribution proportional to its AICc based weights and
calculates the confidence limits (and SE) from this single set.
The value \code{ci_method = "MACL"} (was \code{ci_method = "weighted_arithmetic"} but
has been soft-deprecated) which is only included for
historical reasons takes the weighted arithmetic mean of the confidence
limits and \code{ci_method = MGCL} which was included for a research paper
takes the weighted geometric mean of the confidence limits.
The values \code{ci_method = "MAW1"} and \code{ci_method = "MAW2"}
use the two alternative equations of Burnham and Anderson to
model average the weighted standard errors and then calculate the confidence
limits using the Wald approach.
Finally \code{ci_method = "arithmetic"} and \code{ci_method = "geometric"}
take the weighted arithmetic or geometric mean of the values for
each bootstrap iteration across all the distributions and then
calculate the confidence limits (and SE) from the single set of samples.}

\item{seed}{An integer of the starting seed or NULL.}

\item{nsim}{A count of the number of data sets to generate.}

\item{stream}{A count of the stream number.}

\item{start_sim}{A count of the number of the simulation to start from.}

\item{.progress}{Whether to show a \verb{purrr::progress bar}.}

\item{dist_sim}{A character vector specifying the distributions in the fitdists object or \verb{"all"`` for all the distributions and/or }"top"\verb{to use the distribution with most weight  and/or}"multi"` to treat the distributions as a single distribution.}

\item{args}{A named list of the argument values.}
}
\value{
A tibble of nested data sets.
}
\description{
Run Scenario
}
\section{Methods (by class)}{
\itemize{
\item \code{ssd_run_scenario(data.frame)}: Run scenario using data.frame to sample data

\item \code{ssd_run_scenario(fitdists)}: Run scenario using fitdists object to generate data

\item \code{ssd_run_scenario(tmbfit)}: Run scenario using tmbfit object to generate data

\item \code{ssd_run_scenario(character)}: Run scenario using name of function to generate sequence of random numbers

\item \code{ssd_run_scenario(`function`)}: Run scenario data using function to generate sequence of random numbers

}}
\examples{
ssd_run_scenario(ssddata::ccme_boron, nsim = 2)

fit <- ssdtools::ssd_fit_dists(ssddata::ccme_boron)
ssd_run_scenario(fit, dist_sim = c("lnorm", "top"), nsim = 3)

fit <- ssdtools::ssd_fit_dists(ssddata::ccme_boron)
ssd_run_scenario(fit[[1]], nsim = 3)

ssd_run_scenario("rlnorm", nsim = 3)

ssd_run_scenario(ssdtools::ssd_rlnorm, nsim = 3)

}
