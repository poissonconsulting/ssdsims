sim,stream,nrow,Conc,fits,dist,proportion,est,se,lcl,ucl,wt,level,est_method,ci_method,boot_method,nboot,pboot,dists,samples
1,1,6,1.58536,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.518780089662888, log_scale = 0.437261807784766), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.672968855128749, log_scale = 0.283073509653298), value = 11.0754487116769, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(15.2476860621103, 11.7602877145024, 11.7602877145024, 11.7602831985411)), est = c(scale = 1.3272027204432, shape = 1.96004778907978), pars = list(log_scale = 0.283073509653298, log_shape = 0.672968855128749), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 0.679762260982086, log_scalelog = 0.0774363712824645), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.296802411959905, log_scalelog = -0.38331847938149), value = 11.1498109860176, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(12.9150994592457, -3.85693533208831, -3.85693533208831, 10.729854449394)), est = c(locationlog = 0.296802411959905, scalelog = 0.681595790509704), pars = list(locationlog = 0.296802411959905, log_scalelog = -0.38331847938149), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 0.679762260982086, log_scalelog = 0.424009961562437), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.685837980702908, log_scalelog = -0.743770301087676), value = 11.3407349552588, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.16470969502081, 0.125964352303982, 0.125964352303982, 9.42132989951453)), est = c(locationlog = 0.685837980702908, scalelog = 0.475318439276335), pars = list(locationlog = 0.685837980702908, log_scalelog = -0.743770301087676), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 0.686559883591907, log_sdlog = -0.169699642153379), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 0.679767346676092, log_sdlog = -0.26257550350974), value = 11.0167574151578, counts = c(`function` = 6, gradient = 6), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(10.1442848328368, -0.000103181491450193, -0.000103181491450193, 12.0000306843988)), est = c(meanlog = 0.679767346676092, sdlog = 0.769068294820882), pars = list(meanlog = 0.679767346676092, log_sdlog = -0.26257550350974), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -0.0130613567557379, log_sdlog1 = -0.84279575919664, meanlog2 = 1.38618112393955, log_sdlog2 = -0.930180839661385, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -0.0182869711915506, log_sdlog1 = -1.03219840397756, meanlog2 = 1.34802270470149, log_sdlog2 = -1.04715715411901, pmix = 0.5), value = 10.0704826946716, counts = c(`function` = 13, gradient = 13), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(20.1522952682531, -1.8642982873774, -2.8970001023996, 1.70865022396371, -2.14925762185539, -1.8642982873774, 4.34533978308639, -1.02677068201541, 0.356958049758749, -1.06268145690422, 
    -2.8970001023996, -1.02677068201541, 20.2711386849588, 3.31227383431584, -2.74183715293366, 1.70865022396371, 0.356958049758749, 3.31227383431584, 3.62897928185312, 1.82898981402591, -2.14925762185539, -1.06268145690422, -2.74183715293366, 1.82898981402591, 22.213086565092)), est = c(meanlog1 = -0.0182869711915506, meanlog2 = 1.34802270470149, pmix = 0.5, sdlog1 = 0.35622297711893, sdlog2 = 0.350933983599431), pars = list(meanlog1 = -0.0182869711915506, meanlog2 = 1.34802270470149, pmix = 0.5, 
        log_sdlog1 = -1.03219840397756, log_sdlog2 = -1.04715715411901), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.204807128577247, log_scale = 1.0876346818222), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.385716843449679, log_scale = 1.06102655771602), value = 11.128552130261, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(10.8425344959725, -3.87628167181952, -3.87628167181952, 12.9771941030584)), est = c(scale = 2.88933553705765, shape = 1.4706681825226), pars = list(log_scale = 1.06102655771602, log_shape = 0.385716843449679), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.514363,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,6,3.83091,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.518780089662888, log_scale = 0.437261807784766), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.672968855128749, log_scale = 0.283073509653298), value = 11.0754487116769, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(15.2476860621103, 11.7602877145024, 11.7602877145024, 11.7602831985411)), est = c(scale = 1.3272027204432, shape = 1.96004778907978), pars = list(log_scale = 0.283073509653298, log_shape = 0.672968855128749), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 0.679762260982086, log_scalelog = 0.0774363712824645), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.296802411959905, log_scalelog = -0.38331847938149), value = 11.1498109860176, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(12.9150994592457, -3.85693533208831, -3.85693533208831, 10.729854449394)), est = c(locationlog = 0.296802411959905, scalelog = 0.681595790509704), pars = list(locationlog = 0.296802411959905, log_scalelog = -0.38331847938149), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 0.679762260982086, log_scalelog = 0.424009961562437), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.685837980702908, log_scalelog = -0.743770301087676), value = 11.3407349552588, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.16470969502081, 0.125964352303982, 0.125964352303982, 9.42132989951453)), est = c(locationlog = 0.685837980702908, scalelog = 0.475318439276335), pars = list(locationlog = 0.685837980702908, log_scalelog = -0.743770301087676), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 0.686559883591907, log_sdlog = -0.169699642153379), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 0.679767346676092, log_sdlog = -0.26257550350974), value = 11.0167574151578, counts = c(`function` = 6, gradient = 6), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(10.1442848328368, -0.000103181491450193, -0.000103181491450193, 12.0000306843988)), est = c(meanlog = 0.679767346676092, sdlog = 0.769068294820882), pars = list(meanlog = 0.679767346676092, log_sdlog = -0.26257550350974), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -0.0130613567557379, log_sdlog1 = -0.84279575919664, meanlog2 = 1.38618112393955, log_sdlog2 = -0.930180839661385, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -0.0182869711915506, log_sdlog1 = -1.03219840397756, meanlog2 = 1.34802270470149, log_sdlog2 = -1.04715715411901, pmix = 0.5), value = 10.0704826946716, counts = c(`function` = 13, gradient = 13), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(20.1522952682531, -1.8642982873774, -2.8970001023996, 1.70865022396371, -2.14925762185539, -1.8642982873774, 4.34533978308639, -1.02677068201541, 0.356958049758749, -1.06268145690422, 
    -2.8970001023996, -1.02677068201541, 20.2711386849588, 3.31227383431584, -2.74183715293366, 1.70865022396371, 0.356958049758749, 3.31227383431584, 3.62897928185312, 1.82898981402591, -2.14925762185539, -1.06268145690422, -2.74183715293366, 1.82898981402591, 22.213086565092)), est = c(meanlog1 = -0.0182869711915506, meanlog2 = 1.34802270470149, pmix = 0.5, sdlog1 = 0.35622297711893, sdlog2 = 0.350933983599431), pars = list(meanlog1 = -0.0182869711915506, meanlog2 = 1.34802270470149, pmix = 0.5, 
        log_sdlog1 = -1.03219840397756, log_sdlog2 = -1.04715715411901), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.204807128577247, log_scale = 1.0876346818222), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.385716843449679, log_scale = 1.06102655771602), value = 11.128552130261, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(10.8425344959725, -3.87628167181952, -3.87628167181952, 12.9771941030584)), est = c(scale = 2.88933553705765, shape = 1.4706681825226), pars = list(log_scale = 1.06102655771602, log_shape = 0.385716843449679), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.514363,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,6,2.7106,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.518780089662888, log_scale = 0.437261807784766), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.672968855128749, log_scale = 0.283073509653298), value = 11.0754487116769, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(15.2476860621103, 11.7602877145024, 11.7602877145024, 11.7602831985411)), est = c(scale = 1.3272027204432, shape = 1.96004778907978), pars = list(log_scale = 0.283073509653298, log_shape = 0.672968855128749), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 0.679762260982086, log_scalelog = 0.0774363712824645), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.296802411959905, log_scalelog = -0.38331847938149), value = 11.1498109860176, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(12.9150994592457, -3.85693533208831, -3.85693533208831, 10.729854449394)), est = c(locationlog = 0.296802411959905, scalelog = 0.681595790509704), pars = list(locationlog = 0.296802411959905, log_scalelog = -0.38331847938149), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 0.679762260982086, log_scalelog = 0.424009961562437), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.685837980702908, log_scalelog = -0.743770301087676), value = 11.3407349552588, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.16470969502081, 0.125964352303982, 0.125964352303982, 9.42132989951453)), est = c(locationlog = 0.685837980702908, scalelog = 0.475318439276335), pars = list(locationlog = 0.685837980702908, log_scalelog = -0.743770301087676), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 0.686559883591907, log_sdlog = -0.169699642153379), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 0.679767346676092, log_sdlog = -0.26257550350974), value = 11.0167574151578, counts = c(`function` = 6, gradient = 6), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(10.1442848328368, -0.000103181491450193, -0.000103181491450193, 12.0000306843988)), est = c(meanlog = 0.679767346676092, sdlog = 0.769068294820882), pars = list(meanlog = 0.679767346676092, log_sdlog = -0.26257550350974), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -0.0130613567557379, log_sdlog1 = -0.84279575919664, meanlog2 = 1.38618112393955, log_sdlog2 = -0.930180839661385, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -0.0182869711915506, log_sdlog1 = -1.03219840397756, meanlog2 = 1.34802270470149, log_sdlog2 = -1.04715715411901, pmix = 0.5), value = 10.0704826946716, counts = c(`function` = 13, gradient = 13), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(20.1522952682531, -1.8642982873774, -2.8970001023996, 1.70865022396371, -2.14925762185539, -1.8642982873774, 4.34533978308639, -1.02677068201541, 0.356958049758749, -1.06268145690422, 
    -2.8970001023996, -1.02677068201541, 20.2711386849588, 3.31227383431584, -2.74183715293366, 1.70865022396371, 0.356958049758749, 3.31227383431584, 3.62897928185312, 1.82898981402591, -2.14925762185539, -1.06268145690422, -2.74183715293366, 1.82898981402591, 22.213086565092)), est = c(meanlog1 = -0.0182869711915506, meanlog2 = 1.34802270470149, pmix = 0.5, sdlog1 = 0.35622297711893, sdlog2 = 0.350933983599431), pars = list(meanlog1 = -0.0182869711915506, meanlog2 = 1.34802270470149, pmix = 0.5, 
        log_sdlog1 = -1.03219840397756, log_sdlog2 = -1.04715715411901), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.204807128577247, log_scale = 1.0876346818222), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.385716843449679, log_scale = 1.06102655771602), value = 11.128552130261, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(10.8425344959725, -3.87628167181952, -3.87628167181952, 12.9771941030584)), est = c(scale = 2.88933553705765, shape = 1.4706681825226), pars = list(log_scale = 1.06102655771602, log_shape = 0.385716843449679), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.514363,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,6,0.692377,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.518780089662888, log_scale = 0.437261807784766), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.672968855128749, log_scale = 0.283073509653298), value = 11.0754487116769, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(15.2476860621103, 11.7602877145024, 11.7602877145024, 11.7602831985411)), est = c(scale = 1.3272027204432, shape = 1.96004778907978), pars = list(log_scale = 0.283073509653298, log_shape = 0.672968855128749), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 0.679762260982086, log_scalelog = 0.0774363712824645), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.296802411959905, log_scalelog = -0.38331847938149), value = 11.1498109860176, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(12.9150994592457, -3.85693533208831, -3.85693533208831, 10.729854449394)), est = c(locationlog = 0.296802411959905, scalelog = 0.681595790509704), pars = list(locationlog = 0.296802411959905, log_scalelog = -0.38331847938149), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 0.679762260982086, log_scalelog = 0.424009961562437), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.685837980702908, log_scalelog = -0.743770301087676), value = 11.3407349552588, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.16470969502081, 0.125964352303982, 0.125964352303982, 9.42132989951453)), est = c(locationlog = 0.685837980702908, scalelog = 0.475318439276335), pars = list(locationlog = 0.685837980702908, log_scalelog = -0.743770301087676), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 0.686559883591907, log_sdlog = -0.169699642153379), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 0.679767346676092, log_sdlog = -0.26257550350974), value = 11.0167574151578, counts = c(`function` = 6, gradient = 6), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(10.1442848328368, -0.000103181491450193, -0.000103181491450193, 12.0000306843988)), est = c(meanlog = 0.679767346676092, sdlog = 0.769068294820882), pars = list(meanlog = 0.679767346676092, log_sdlog = -0.26257550350974), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -0.0130613567557379, log_sdlog1 = -0.84279575919664, meanlog2 = 1.38618112393955, log_sdlog2 = -0.930180839661385, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -0.0182869711915506, log_sdlog1 = -1.03219840397756, meanlog2 = 1.34802270470149, log_sdlog2 = -1.04715715411901, pmix = 0.5), value = 10.0704826946716, counts = c(`function` = 13, gradient = 13), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(20.1522952682531, -1.8642982873774, -2.8970001023996, 1.70865022396371, -2.14925762185539, -1.8642982873774, 4.34533978308639, -1.02677068201541, 0.356958049758749, -1.06268145690422, 
    -2.8970001023996, -1.02677068201541, 20.2711386849588, 3.31227383431584, -2.74183715293366, 1.70865022396371, 0.356958049758749, 3.31227383431584, 3.62897928185312, 1.82898981402591, -2.14925762185539, -1.06268145690422, -2.74183715293366, 1.82898981402591, 22.213086565092)), est = c(meanlog1 = -0.0182869711915506, meanlog2 = 1.34802270470149, pmix = 0.5, sdlog1 = 0.35622297711893, sdlog2 = 0.350933983599431), pars = list(meanlog1 = -0.0182869711915506, meanlog2 = 1.34802270470149, pmix = 0.5, 
        log_sdlog1 = -1.03219840397756, log_sdlog2 = -1.04715715411901), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.204807128577247, log_scale = 1.0876346818222), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.385716843449679, log_scale = 1.06102655771602), value = 11.128552130261, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(10.8425344959725, -3.87628167181952, -3.87628167181952, 12.9771941030584)), est = c(scale = 2.88933553705765, shape = 1.4706681825226), pars = list(log_scale = 1.06102655771602, log_shape = 0.385716843449679), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.514363,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,6,0.876356,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.518780089662888, log_scale = 0.437261807784766), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.672968855128749, log_scale = 0.283073509653298), value = 11.0754487116769, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(15.2476860621103, 11.7602877145024, 11.7602877145024, 11.7602831985411)), est = c(scale = 1.3272027204432, shape = 1.96004778907978), pars = list(log_scale = 0.283073509653298, log_shape = 0.672968855128749), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 0.679762260982086, log_scalelog = 0.0774363712824645), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.296802411959905, log_scalelog = -0.38331847938149), value = 11.1498109860176, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(12.9150994592457, -3.85693533208831, -3.85693533208831, 10.729854449394)), est = c(locationlog = 0.296802411959905, scalelog = 0.681595790509704), pars = list(locationlog = 0.296802411959905, log_scalelog = -0.38331847938149), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 0.679762260982086, log_scalelog = 0.424009961562437), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.685837980702908, log_scalelog = -0.743770301087676), value = 11.3407349552588, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.16470969502081, 0.125964352303982, 0.125964352303982, 9.42132989951453)), est = c(locationlog = 0.685837980702908, scalelog = 0.475318439276335), pars = list(locationlog = 0.685837980702908, log_scalelog = -0.743770301087676), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 0.686559883591907, log_sdlog = -0.169699642153379), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 0.679767346676092, log_sdlog = -0.26257550350974), value = 11.0167574151578, counts = c(`function` = 6, gradient = 6), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(10.1442848328368, -0.000103181491450193, -0.000103181491450193, 12.0000306843988)), est = c(meanlog = 0.679767346676092, sdlog = 0.769068294820882), pars = list(meanlog = 0.679767346676092, log_sdlog = -0.26257550350974), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -0.0130613567557379, log_sdlog1 = -0.84279575919664, meanlog2 = 1.38618112393955, log_sdlog2 = -0.930180839661385, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -0.0182869711915506, log_sdlog1 = -1.03219840397756, meanlog2 = 1.34802270470149, log_sdlog2 = -1.04715715411901, pmix = 0.5), value = 10.0704826946716, counts = c(`function` = 13, gradient = 13), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(20.1522952682531, -1.8642982873774, -2.8970001023996, 1.70865022396371, -2.14925762185539, -1.8642982873774, 4.34533978308639, -1.02677068201541, 0.356958049758749, -1.06268145690422, 
    -2.8970001023996, -1.02677068201541, 20.2711386849588, 3.31227383431584, -2.74183715293366, 1.70865022396371, 0.356958049758749, 3.31227383431584, 3.62897928185312, 1.82898981402591, -2.14925762185539, -1.06268145690422, -2.74183715293366, 1.82898981402591, 22.213086565092)), est = c(meanlog1 = -0.0182869711915506, meanlog2 = 1.34802270470149, pmix = 0.5, sdlog1 = 0.35622297711893, sdlog2 = 0.350933983599431), pars = list(meanlog1 = -0.0182869711915506, meanlog2 = 1.34802270470149, pmix = 0.5, 
        log_sdlog1 = -1.03219840397756, log_sdlog2 = -1.04715715411901), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.204807128577247, log_scale = 1.0876346818222), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.385716843449679, log_scale = 1.06102655771602), value = 11.128552130261, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(10.8425344959725, -3.87628167181952, -3.87628167181952, 12.9771941030584)), est = c(scale = 2.88933553705765, shape = 1.4706681825226), pars = list(log_scale = 1.06102655771602, log_shape = 0.385716843449679), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.514363,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,6,5.91268,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.518780089662888, log_scale = 0.437261807784766), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.672968855128749, log_scale = 0.283073509653298), value = 11.0754487116769, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(15.2476860621103, 11.7602877145024, 11.7602877145024, 11.7602831985411)), est = c(scale = 1.3272027204432, shape = 1.96004778907978), pars = list(log_scale = 0.283073509653298, log_shape = 0.672968855128749), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 0.679762260982086, log_scalelog = 0.0774363712824645), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.296802411959905, log_scalelog = -0.38331847938149), value = 11.1498109860176, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(12.9150994592457, -3.85693533208831, -3.85693533208831, 10.729854449394)), est = c(locationlog = 0.296802411959905, scalelog = 0.681595790509704), pars = list(locationlog = 0.296802411959905, log_scalelog = -0.38331847938149), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 0.679762260982086, log_scalelog = 0.424009961562437), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.685837980702908, log_scalelog = -0.743770301087676), value = 11.3407349552588, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.16470969502081, 0.125964352303982, 0.125964352303982, 9.42132989951453)), est = c(locationlog = 0.685837980702908, scalelog = 0.475318439276335), pars = list(locationlog = 0.685837980702908, log_scalelog = -0.743770301087676), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 0.686559883591907, log_sdlog = -0.169699642153379), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 0.679767346676092, log_sdlog = -0.26257550350974), value = 11.0167574151578, counts = c(`function` = 6, gradient = 6), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(10.1442848328368, -0.000103181491450193, -0.000103181491450193, 12.0000306843988)), est = c(meanlog = 0.679767346676092, sdlog = 0.769068294820882), pars = list(meanlog = 0.679767346676092, log_sdlog = -0.26257550350974), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -0.0130613567557379, log_sdlog1 = -0.84279575919664, meanlog2 = 1.38618112393955, log_sdlog2 = -0.930180839661385, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -0.0182869711915506, log_sdlog1 = -1.03219840397756, meanlog2 = 1.34802270470149, log_sdlog2 = -1.04715715411901, pmix = 0.5), value = 10.0704826946716, counts = c(`function` = 13, gradient = 13), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(20.1522952682531, -1.8642982873774, -2.8970001023996, 1.70865022396371, -2.14925762185539, -1.8642982873774, 4.34533978308639, -1.02677068201541, 0.356958049758749, -1.06268145690422, 
    -2.8970001023996, -1.02677068201541, 20.2711386849588, 3.31227383431584, -2.74183715293366, 1.70865022396371, 0.356958049758749, 3.31227383431584, 3.62897928185312, 1.82898981402591, -2.14925762185539, -1.06268145690422, -2.74183715293366, 1.82898981402591, 22.213086565092)), est = c(meanlog1 = -0.0182869711915506, meanlog2 = 1.34802270470149, pmix = 0.5, sdlog1 = 0.35622297711893, sdlog2 = 0.350933983599431), pars = list(meanlog1 = -0.0182869711915506, meanlog2 = 1.34802270470149, pmix = 0.5, 
        log_sdlog1 = -1.03219840397756, log_sdlog2 = -1.04715715411901), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.204807128577247, log_scale = 1.0876346818222), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.385716843449679, log_scale = 1.06102655771602), value = 11.128552130261, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(10.8425344959725, -3.87628167181952, -3.87628167181952, 12.9771941030584)), est = c(scale = 2.88933553705765, shape = 1.4706681825226), pars = list(log_scale = 1.06102655771602, log_shape = 0.385716843449679), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.514363,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,10,1.58536,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.313310043121904, log_scale = 0.468793393642748), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.488893148492065, log_scale = 0.293210676328775), value = 17.195866523443, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(22.2647264475715, 16.3051062368479, 16.3051062368479, 16.3051012683112)), est = c(scale = 1.34072521974724, shape = 1.63051048780892), pars = list(log_scale = 0.293210676328775, log_shape = 0.488893148492065), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 0.445125904309182, log_scalelog = 0.105052752181371), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.0523837981861042, log_scalelog = -0.435255982815164), value = 16.1679734857783, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(23.8813422478162, -6.07440192220193, -6.07440192220193, 15.7935174396287)), est = c(locationlog = 0.0523837981861042, scalelog = 0.647098999651312), pars = list(locationlog = 0.0523837981861042, log_scalelog = -0.435255982815164), flags = list(
        at_boundary = FALSE, computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 0.445125904309182, log_scalelog = 0.451626342461343), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.396203749028518, log_scalelog = -0.668710159202585), value = 17.2608170766989, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(11.5652826590785, -0.960872692309404, -0.960872692309404, 15.9921428127923)), est = c(locationlog = 0.396203749028518, scalelog = 0.512369026231668), pars = list(locationlog = 0.396203749028518, log_scalelog = -0.668710159202585), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 0.449577163352274, log_sdlog = -0.142359425063462), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 0.445125913513896, log_sdlog = -0.196477691214009), value = 16.6758678063094, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.8135229351217, -2.72708150472351e-07, -2.72708150472351e-07, 20.0000147065809)), est = c(meanlog = 0.445125913513896, sdlog = 0.821619660427973), pars = list(meanlog = 0.445125913513896, log_sdlog = -0.196477691214009), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -0.311430735190836, log_sdlog1 = -1.89966266223835, meanlog2 = 1.21058506189538, log_sdlog2 = -0.692593198323942, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -0.308771827414923, log_sdlog1 = -2.03114672578293, meanlog2 = 1.19403040885289, log_sdlog2 = -0.797034753547832, pmix = 0.498337901729023), value = 11.3488497889913, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(288.190023186438, -0.0833658453059696, -0.788260857686404, 0.90375962561372, -0.489403332045587, -0.0833658453059696, 9.95919313615642, -0.0467455271308537, 0.0536356398802495, 
    -0.0290823654323725, -0.788260857686404, -0.0467455271308537, 23.9405244899582, 0.943420228040546, -0.446967942328035, 0.90375962561372, 0.0536356398802495, 0.943420228040546, 8.85208427183911, 0.551431961882911, -0.489403332045587, -0.0290823654323725, -0.446967942328035, 0.551431961882911, 39.7365576178185)), est = c(meanlog1 = -0.308771827414923, meanlog2 = 1.19403040885289, pmix = 0.498337901729023, sdlog1 = 0.131185001638973, sdlog2 = 0.450663312592259), pars = list(meanlog1 = -0.308771827414923, 
        meanlog2 = 1.19403040885289, pmix = 0.498337901729023, log_sdlog1 = -2.03114672578293, log_sdlog2 = -0.797034753547832), flags = list(at_boundary = FALSE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.150389323608881, log_scale = 0.895198407358448), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.252237051343527, log_scale = 0.866075278091329), value = 17.3460904626157, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(18.833004054424, -5.89762325039989, -5.89762325039989, 16.5611479715735)), est = c(scale = 2.37756125149869, shape = 1.28690106275598), pars = list(log_scale = 0.866075278091329, log_shape = 0.252237051343527), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.410544,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,10,3.83091,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.313310043121904, log_scale = 0.468793393642748), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.488893148492065, log_scale = 0.293210676328775), value = 17.195866523443, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(22.2647264475715, 16.3051062368479, 16.3051062368479, 16.3051012683112)), est = c(scale = 1.34072521974724, shape = 1.63051048780892), pars = list(log_scale = 0.293210676328775, log_shape = 0.488893148492065), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 0.445125904309182, log_scalelog = 0.105052752181371), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.0523837981861042, log_scalelog = -0.435255982815164), value = 16.1679734857783, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(23.8813422478162, -6.07440192220193, -6.07440192220193, 15.7935174396287)), est = c(locationlog = 0.0523837981861042, scalelog = 0.647098999651312), pars = list(locationlog = 0.0523837981861042, log_scalelog = -0.435255982815164), flags = list(
        at_boundary = FALSE, computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 0.445125904309182, log_scalelog = 0.451626342461343), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.396203749028518, log_scalelog = -0.668710159202585), value = 17.2608170766989, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(11.5652826590785, -0.960872692309404, -0.960872692309404, 15.9921428127923)), est = c(locationlog = 0.396203749028518, scalelog = 0.512369026231668), pars = list(locationlog = 0.396203749028518, log_scalelog = -0.668710159202585), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 0.449577163352274, log_sdlog = -0.142359425063462), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 0.445125913513896, log_sdlog = -0.196477691214009), value = 16.6758678063094, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.8135229351217, -2.72708150472351e-07, -2.72708150472351e-07, 20.0000147065809)), est = c(meanlog = 0.445125913513896, sdlog = 0.821619660427973), pars = list(meanlog = 0.445125913513896, log_sdlog = -0.196477691214009), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -0.311430735190836, log_sdlog1 = -1.89966266223835, meanlog2 = 1.21058506189538, log_sdlog2 = -0.692593198323942, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -0.308771827414923, log_sdlog1 = -2.03114672578293, meanlog2 = 1.19403040885289, log_sdlog2 = -0.797034753547832, pmix = 0.498337901729023), value = 11.3488497889913, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(288.190023186438, -0.0833658453059696, -0.788260857686404, 0.90375962561372, -0.489403332045587, -0.0833658453059696, 9.95919313615642, -0.0467455271308537, 0.0536356398802495, 
    -0.0290823654323725, -0.788260857686404, -0.0467455271308537, 23.9405244899582, 0.943420228040546, -0.446967942328035, 0.90375962561372, 0.0536356398802495, 0.943420228040546, 8.85208427183911, 0.551431961882911, -0.489403332045587, -0.0290823654323725, -0.446967942328035, 0.551431961882911, 39.7365576178185)), est = c(meanlog1 = -0.308771827414923, meanlog2 = 1.19403040885289, pmix = 0.498337901729023, sdlog1 = 0.131185001638973, sdlog2 = 0.450663312592259), pars = list(meanlog1 = -0.308771827414923, 
        meanlog2 = 1.19403040885289, pmix = 0.498337901729023, log_sdlog1 = -2.03114672578293, log_sdlog2 = -0.797034753547832), flags = list(at_boundary = FALSE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.150389323608881, log_scale = 0.895198407358448), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.252237051343527, log_scale = 0.866075278091329), value = 17.3460904626157, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(18.833004054424, -5.89762325039989, -5.89762325039989, 16.5611479715735)), est = c(scale = 2.37756125149869, shape = 1.28690106275598), pars = list(log_scale = 0.866075278091329, log_shape = 0.252237051343527), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.410544,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,10,2.7106,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.313310043121904, log_scale = 0.468793393642748), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.488893148492065, log_scale = 0.293210676328775), value = 17.195866523443, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(22.2647264475715, 16.3051062368479, 16.3051062368479, 16.3051012683112)), est = c(scale = 1.34072521974724, shape = 1.63051048780892), pars = list(log_scale = 0.293210676328775, log_shape = 0.488893148492065), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 0.445125904309182, log_scalelog = 0.105052752181371), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.0523837981861042, log_scalelog = -0.435255982815164), value = 16.1679734857783, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(23.8813422478162, -6.07440192220193, -6.07440192220193, 15.7935174396287)), est = c(locationlog = 0.0523837981861042, scalelog = 0.647098999651312), pars = list(locationlog = 0.0523837981861042, log_scalelog = -0.435255982815164), flags = list(
        at_boundary = FALSE, computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 0.445125904309182, log_scalelog = 0.451626342461343), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.396203749028518, log_scalelog = -0.668710159202585), value = 17.2608170766989, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(11.5652826590785, -0.960872692309404, -0.960872692309404, 15.9921428127923)), est = c(locationlog = 0.396203749028518, scalelog = 0.512369026231668), pars = list(locationlog = 0.396203749028518, log_scalelog = -0.668710159202585), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 0.449577163352274, log_sdlog = -0.142359425063462), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 0.445125913513896, log_sdlog = -0.196477691214009), value = 16.6758678063094, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.8135229351217, -2.72708150472351e-07, -2.72708150472351e-07, 20.0000147065809)), est = c(meanlog = 0.445125913513896, sdlog = 0.821619660427973), pars = list(meanlog = 0.445125913513896, log_sdlog = -0.196477691214009), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -0.311430735190836, log_sdlog1 = -1.89966266223835, meanlog2 = 1.21058506189538, log_sdlog2 = -0.692593198323942, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -0.308771827414923, log_sdlog1 = -2.03114672578293, meanlog2 = 1.19403040885289, log_sdlog2 = -0.797034753547832, pmix = 0.498337901729023), value = 11.3488497889913, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(288.190023186438, -0.0833658453059696, -0.788260857686404, 0.90375962561372, -0.489403332045587, -0.0833658453059696, 9.95919313615642, -0.0467455271308537, 0.0536356398802495, 
    -0.0290823654323725, -0.788260857686404, -0.0467455271308537, 23.9405244899582, 0.943420228040546, -0.446967942328035, 0.90375962561372, 0.0536356398802495, 0.943420228040546, 8.85208427183911, 0.551431961882911, -0.489403332045587, -0.0290823654323725, -0.446967942328035, 0.551431961882911, 39.7365576178185)), est = c(meanlog1 = -0.308771827414923, meanlog2 = 1.19403040885289, pmix = 0.498337901729023, sdlog1 = 0.131185001638973, sdlog2 = 0.450663312592259), pars = list(meanlog1 = -0.308771827414923, 
        meanlog2 = 1.19403040885289, pmix = 0.498337901729023, log_sdlog1 = -2.03114672578293, log_sdlog2 = -0.797034753547832), flags = list(at_boundary = FALSE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.150389323608881, log_scale = 0.895198407358448), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.252237051343527, log_scale = 0.866075278091329), value = 17.3460904626157, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(18.833004054424, -5.89762325039989, -5.89762325039989, 16.5611479715735)), est = c(scale = 2.37756125149869, shape = 1.28690106275598), pars = list(log_scale = 0.866075278091329, log_shape = 0.252237051343527), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.410544,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,10,0.692377,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.313310043121904, log_scale = 0.468793393642748), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.488893148492065, log_scale = 0.293210676328775), value = 17.195866523443, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(22.2647264475715, 16.3051062368479, 16.3051062368479, 16.3051012683112)), est = c(scale = 1.34072521974724, shape = 1.63051048780892), pars = list(log_scale = 0.293210676328775, log_shape = 0.488893148492065), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 0.445125904309182, log_scalelog = 0.105052752181371), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.0523837981861042, log_scalelog = -0.435255982815164), value = 16.1679734857783, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(23.8813422478162, -6.07440192220193, -6.07440192220193, 15.7935174396287)), est = c(locationlog = 0.0523837981861042, scalelog = 0.647098999651312), pars = list(locationlog = 0.0523837981861042, log_scalelog = -0.435255982815164), flags = list(
        at_boundary = FALSE, computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 0.445125904309182, log_scalelog = 0.451626342461343), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.396203749028518, log_scalelog = -0.668710159202585), value = 17.2608170766989, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(11.5652826590785, -0.960872692309404, -0.960872692309404, 15.9921428127923)), est = c(locationlog = 0.396203749028518, scalelog = 0.512369026231668), pars = list(locationlog = 0.396203749028518, log_scalelog = -0.668710159202585), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 0.449577163352274, log_sdlog = -0.142359425063462), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 0.445125913513896, log_sdlog = -0.196477691214009), value = 16.6758678063094, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.8135229351217, -2.72708150472351e-07, -2.72708150472351e-07, 20.0000147065809)), est = c(meanlog = 0.445125913513896, sdlog = 0.821619660427973), pars = list(meanlog = 0.445125913513896, log_sdlog = -0.196477691214009), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -0.311430735190836, log_sdlog1 = -1.89966266223835, meanlog2 = 1.21058506189538, log_sdlog2 = -0.692593198323942, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -0.308771827414923, log_sdlog1 = -2.03114672578293, meanlog2 = 1.19403040885289, log_sdlog2 = -0.797034753547832, pmix = 0.498337901729023), value = 11.3488497889913, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(288.190023186438, -0.0833658453059696, -0.788260857686404, 0.90375962561372, -0.489403332045587, -0.0833658453059696, 9.95919313615642, -0.0467455271308537, 0.0536356398802495, 
    -0.0290823654323725, -0.788260857686404, -0.0467455271308537, 23.9405244899582, 0.943420228040546, -0.446967942328035, 0.90375962561372, 0.0536356398802495, 0.943420228040546, 8.85208427183911, 0.551431961882911, -0.489403332045587, -0.0290823654323725, -0.446967942328035, 0.551431961882911, 39.7365576178185)), est = c(meanlog1 = -0.308771827414923, meanlog2 = 1.19403040885289, pmix = 0.498337901729023, sdlog1 = 0.131185001638973, sdlog2 = 0.450663312592259), pars = list(meanlog1 = -0.308771827414923, 
        meanlog2 = 1.19403040885289, pmix = 0.498337901729023, log_sdlog1 = -2.03114672578293, log_sdlog2 = -0.797034753547832), flags = list(at_boundary = FALSE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.150389323608881, log_scale = 0.895198407358448), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.252237051343527, log_scale = 0.866075278091329), value = 17.3460904626157, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(18.833004054424, -5.89762325039989, -5.89762325039989, 16.5611479715735)), est = c(scale = 2.37756125149869, shape = 1.28690106275598), pars = list(log_scale = 0.866075278091329, log_shape = 0.252237051343527), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.410544,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,10,0.876356,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.313310043121904, log_scale = 0.468793393642748), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.488893148492065, log_scale = 0.293210676328775), value = 17.195866523443, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(22.2647264475715, 16.3051062368479, 16.3051062368479, 16.3051012683112)), est = c(scale = 1.34072521974724, shape = 1.63051048780892), pars = list(log_scale = 0.293210676328775, log_shape = 0.488893148492065), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 0.445125904309182, log_scalelog = 0.105052752181371), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.0523837981861042, log_scalelog = -0.435255982815164), value = 16.1679734857783, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(23.8813422478162, -6.07440192220193, -6.07440192220193, 15.7935174396287)), est = c(locationlog = 0.0523837981861042, scalelog = 0.647098999651312), pars = list(locationlog = 0.0523837981861042, log_scalelog = -0.435255982815164), flags = list(
        at_boundary = FALSE, computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 0.445125904309182, log_scalelog = 0.451626342461343), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.396203749028518, log_scalelog = -0.668710159202585), value = 17.2608170766989, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(11.5652826590785, -0.960872692309404, -0.960872692309404, 15.9921428127923)), est = c(locationlog = 0.396203749028518, scalelog = 0.512369026231668), pars = list(locationlog = 0.396203749028518, log_scalelog = -0.668710159202585), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 0.449577163352274, log_sdlog = -0.142359425063462), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 0.445125913513896, log_sdlog = -0.196477691214009), value = 16.6758678063094, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.8135229351217, -2.72708150472351e-07, -2.72708150472351e-07, 20.0000147065809)), est = c(meanlog = 0.445125913513896, sdlog = 0.821619660427973), pars = list(meanlog = 0.445125913513896, log_sdlog = -0.196477691214009), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -0.311430735190836, log_sdlog1 = -1.89966266223835, meanlog2 = 1.21058506189538, log_sdlog2 = -0.692593198323942, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -0.308771827414923, log_sdlog1 = -2.03114672578293, meanlog2 = 1.19403040885289, log_sdlog2 = -0.797034753547832, pmix = 0.498337901729023), value = 11.3488497889913, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(288.190023186438, -0.0833658453059696, -0.788260857686404, 0.90375962561372, -0.489403332045587, -0.0833658453059696, 9.95919313615642, -0.0467455271308537, 0.0536356398802495, 
    -0.0290823654323725, -0.788260857686404, -0.0467455271308537, 23.9405244899582, 0.943420228040546, -0.446967942328035, 0.90375962561372, 0.0536356398802495, 0.943420228040546, 8.85208427183911, 0.551431961882911, -0.489403332045587, -0.0290823654323725, -0.446967942328035, 0.551431961882911, 39.7365576178185)), est = c(meanlog1 = -0.308771827414923, meanlog2 = 1.19403040885289, pmix = 0.498337901729023, sdlog1 = 0.131185001638973, sdlog2 = 0.450663312592259), pars = list(meanlog1 = -0.308771827414923, 
        meanlog2 = 1.19403040885289, pmix = 0.498337901729023, log_sdlog1 = -2.03114672578293, log_sdlog2 = -0.797034753547832), flags = list(at_boundary = FALSE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.150389323608881, log_scale = 0.895198407358448), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.252237051343527, log_scale = 0.866075278091329), value = 17.3460904626157, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(18.833004054424, -5.89762325039989, -5.89762325039989, 16.5611479715735)), est = c(scale = 2.37756125149869, shape = 1.28690106275598), pars = list(log_scale = 0.866075278091329, log_shape = 0.252237051343527), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.410544,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,10,5.91268,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.313310043121904, log_scale = 0.468793393642748), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.488893148492065, log_scale = 0.293210676328775), value = 17.195866523443, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(22.2647264475715, 16.3051062368479, 16.3051062368479, 16.3051012683112)), est = c(scale = 1.34072521974724, shape = 1.63051048780892), pars = list(log_scale = 0.293210676328775, log_shape = 0.488893148492065), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 0.445125904309182, log_scalelog = 0.105052752181371), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.0523837981861042, log_scalelog = -0.435255982815164), value = 16.1679734857783, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(23.8813422478162, -6.07440192220193, -6.07440192220193, 15.7935174396287)), est = c(locationlog = 0.0523837981861042, scalelog = 0.647098999651312), pars = list(locationlog = 0.0523837981861042, log_scalelog = -0.435255982815164), flags = list(
        at_boundary = FALSE, computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 0.445125904309182, log_scalelog = 0.451626342461343), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.396203749028518, log_scalelog = -0.668710159202585), value = 17.2608170766989, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(11.5652826590785, -0.960872692309404, -0.960872692309404, 15.9921428127923)), est = c(locationlog = 0.396203749028518, scalelog = 0.512369026231668), pars = list(locationlog = 0.396203749028518, log_scalelog = -0.668710159202585), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 0.449577163352274, log_sdlog = -0.142359425063462), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 0.445125913513896, log_sdlog = -0.196477691214009), value = 16.6758678063094, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.8135229351217, -2.72708150472351e-07, -2.72708150472351e-07, 20.0000147065809)), est = c(meanlog = 0.445125913513896, sdlog = 0.821619660427973), pars = list(meanlog = 0.445125913513896, log_sdlog = -0.196477691214009), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -0.311430735190836, log_sdlog1 = -1.89966266223835, meanlog2 = 1.21058506189538, log_sdlog2 = -0.692593198323942, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -0.308771827414923, log_sdlog1 = -2.03114672578293, meanlog2 = 1.19403040885289, log_sdlog2 = -0.797034753547832, pmix = 0.498337901729023), value = 11.3488497889913, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(288.190023186438, -0.0833658453059696, -0.788260857686404, 0.90375962561372, -0.489403332045587, -0.0833658453059696, 9.95919313615642, -0.0467455271308537, 0.0536356398802495, 
    -0.0290823654323725, -0.788260857686404, -0.0467455271308537, 23.9405244899582, 0.943420228040546, -0.446967942328035, 0.90375962561372, 0.0536356398802495, 0.943420228040546, 8.85208427183911, 0.551431961882911, -0.489403332045587, -0.0290823654323725, -0.446967942328035, 0.551431961882911, 39.7365576178185)), est = c(meanlog1 = -0.308771827414923, meanlog2 = 1.19403040885289, pmix = 0.498337901729023, sdlog1 = 0.131185001638973, sdlog2 = 0.450663312592259), pars = list(meanlog1 = -0.308771827414923, 
        meanlog2 = 1.19403040885289, pmix = 0.498337901729023, log_sdlog1 = -2.03114672578293, log_sdlog2 = -0.797034753547832), flags = list(at_boundary = FALSE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.150389323608881, log_scale = 0.895198407358448), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.252237051343527, log_scale = 0.866075278091329), value = 17.3460904626157, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(18.833004054424, -5.89762325039989, -5.89762325039989, 16.5611479715735)), est = c(scale = 2.37756125149869, shape = 1.28690106275598), pars = list(log_scale = 0.866075278091329, log_shape = 0.252237051343527), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.410544,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,10,0.628595,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.313310043121904, log_scale = 0.468793393642748), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.488893148492065, log_scale = 0.293210676328775), value = 17.195866523443, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(22.2647264475715, 16.3051062368479, 16.3051062368479, 16.3051012683112)), est = c(scale = 1.34072521974724, shape = 1.63051048780892), pars = list(log_scale = 0.293210676328775, log_shape = 0.488893148492065), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 0.445125904309182, log_scalelog = 0.105052752181371), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.0523837981861042, log_scalelog = -0.435255982815164), value = 16.1679734857783, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(23.8813422478162, -6.07440192220193, -6.07440192220193, 15.7935174396287)), est = c(locationlog = 0.0523837981861042, scalelog = 0.647098999651312), pars = list(locationlog = 0.0523837981861042, log_scalelog = -0.435255982815164), flags = list(
        at_boundary = FALSE, computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 0.445125904309182, log_scalelog = 0.451626342461343), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.396203749028518, log_scalelog = -0.668710159202585), value = 17.2608170766989, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(11.5652826590785, -0.960872692309404, -0.960872692309404, 15.9921428127923)), est = c(locationlog = 0.396203749028518, scalelog = 0.512369026231668), pars = list(locationlog = 0.396203749028518, log_scalelog = -0.668710159202585), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 0.449577163352274, log_sdlog = -0.142359425063462), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 0.445125913513896, log_sdlog = -0.196477691214009), value = 16.6758678063094, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.8135229351217, -2.72708150472351e-07, -2.72708150472351e-07, 20.0000147065809)), est = c(meanlog = 0.445125913513896, sdlog = 0.821619660427973), pars = list(meanlog = 0.445125913513896, log_sdlog = -0.196477691214009), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -0.311430735190836, log_sdlog1 = -1.89966266223835, meanlog2 = 1.21058506189538, log_sdlog2 = -0.692593198323942, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -0.308771827414923, log_sdlog1 = -2.03114672578293, meanlog2 = 1.19403040885289, log_sdlog2 = -0.797034753547832, pmix = 0.498337901729023), value = 11.3488497889913, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(288.190023186438, -0.0833658453059696, -0.788260857686404, 0.90375962561372, -0.489403332045587, -0.0833658453059696, 9.95919313615642, -0.0467455271308537, 0.0536356398802495, 
    -0.0290823654323725, -0.788260857686404, -0.0467455271308537, 23.9405244899582, 0.943420228040546, -0.446967942328035, 0.90375962561372, 0.0536356398802495, 0.943420228040546, 8.85208427183911, 0.551431961882911, -0.489403332045587, -0.0290823654323725, -0.446967942328035, 0.551431961882911, 39.7365576178185)), est = c(meanlog1 = -0.308771827414923, meanlog2 = 1.19403040885289, pmix = 0.498337901729023, sdlog1 = 0.131185001638973, sdlog2 = 0.450663312592259), pars = list(meanlog1 = -0.308771827414923, 
        meanlog2 = 1.19403040885289, pmix = 0.498337901729023, log_sdlog1 = -2.03114672578293, log_sdlog2 = -0.797034753547832), flags = list(at_boundary = FALSE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.150389323608881, log_scale = 0.895198407358448), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.252237051343527, log_scale = 0.866075278091329), value = 17.3460904626157, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(18.833004054424, -5.89762325039989, -5.89762325039989, 16.5611479715735)), est = c(scale = 2.37756125149869, shape = 1.28690106275598), pars = list(log_scale = 0.866075278091329, log_shape = 0.252237051343527), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.410544,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,10,0.840426,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.313310043121904, log_scale = 0.468793393642748), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.488893148492065, log_scale = 0.293210676328775), value = 17.195866523443, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(22.2647264475715, 16.3051062368479, 16.3051062368479, 16.3051012683112)), est = c(scale = 1.34072521974724, shape = 1.63051048780892), pars = list(log_scale = 0.293210676328775, log_shape = 0.488893148492065), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 0.445125904309182, log_scalelog = 0.105052752181371), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.0523837981861042, log_scalelog = -0.435255982815164), value = 16.1679734857783, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(23.8813422478162, -6.07440192220193, -6.07440192220193, 15.7935174396287)), est = c(locationlog = 0.0523837981861042, scalelog = 0.647098999651312), pars = list(locationlog = 0.0523837981861042, log_scalelog = -0.435255982815164), flags = list(
        at_boundary = FALSE, computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 0.445125904309182, log_scalelog = 0.451626342461343), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.396203749028518, log_scalelog = -0.668710159202585), value = 17.2608170766989, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(11.5652826590785, -0.960872692309404, -0.960872692309404, 15.9921428127923)), est = c(locationlog = 0.396203749028518, scalelog = 0.512369026231668), pars = list(locationlog = 0.396203749028518, log_scalelog = -0.668710159202585), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 0.449577163352274, log_sdlog = -0.142359425063462), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 0.445125913513896, log_sdlog = -0.196477691214009), value = 16.6758678063094, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.8135229351217, -2.72708150472351e-07, -2.72708150472351e-07, 20.0000147065809)), est = c(meanlog = 0.445125913513896, sdlog = 0.821619660427973), pars = list(meanlog = 0.445125913513896, log_sdlog = -0.196477691214009), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -0.311430735190836, log_sdlog1 = -1.89966266223835, meanlog2 = 1.21058506189538, log_sdlog2 = -0.692593198323942, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -0.308771827414923, log_sdlog1 = -2.03114672578293, meanlog2 = 1.19403040885289, log_sdlog2 = -0.797034753547832, pmix = 0.498337901729023), value = 11.3488497889913, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(288.190023186438, -0.0833658453059696, -0.788260857686404, 0.90375962561372, -0.489403332045587, -0.0833658453059696, 9.95919313615642, -0.0467455271308537, 0.0536356398802495, 
    -0.0290823654323725, -0.788260857686404, -0.0467455271308537, 23.9405244899582, 0.943420228040546, -0.446967942328035, 0.90375962561372, 0.0536356398802495, 0.943420228040546, 8.85208427183911, 0.551431961882911, -0.489403332045587, -0.0290823654323725, -0.446967942328035, 0.551431961882911, 39.7365576178185)), est = c(meanlog1 = -0.308771827414923, meanlog2 = 1.19403040885289, pmix = 0.498337901729023, sdlog1 = 0.131185001638973, sdlog2 = 0.450663312592259), pars = list(meanlog1 = -0.308771827414923, 
        meanlog2 = 1.19403040885289, pmix = 0.498337901729023, log_sdlog1 = -2.03114672578293, log_sdlog2 = -0.797034753547832), flags = list(at_boundary = FALSE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.150389323608881, log_scale = 0.895198407358448), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.252237051343527, log_scale = 0.866075278091329), value = 17.3460904626157, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(18.833004054424, -5.89762325039989, -5.89762325039989, 16.5611479715735)), est = c(scale = 2.37756125149869, shape = 1.28690106275598), pars = list(log_scale = 0.866075278091329, log_shape = 0.252237051343527), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.410544,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,10,0.667635,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.313310043121904, log_scale = 0.468793393642748), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.488893148492065, log_scale = 0.293210676328775), value = 17.195866523443, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(22.2647264475715, 16.3051062368479, 16.3051062368479, 16.3051012683112)), est = c(scale = 1.34072521974724, shape = 1.63051048780892), pars = list(log_scale = 0.293210676328775, log_shape = 0.488893148492065), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 0.445125904309182, log_scalelog = 0.105052752181371), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.0523837981861042, log_scalelog = -0.435255982815164), value = 16.1679734857783, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(23.8813422478162, -6.07440192220193, -6.07440192220193, 15.7935174396287)), est = c(locationlog = 0.0523837981861042, scalelog = 0.647098999651312), pars = list(locationlog = 0.0523837981861042, log_scalelog = -0.435255982815164), flags = list(
        at_boundary = FALSE, computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 0.445125904309182, log_scalelog = 0.451626342461343), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.396203749028518, log_scalelog = -0.668710159202585), value = 17.2608170766989, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(11.5652826590785, -0.960872692309404, -0.960872692309404, 15.9921428127923)), est = c(locationlog = 0.396203749028518, scalelog = 0.512369026231668), pars = list(locationlog = 0.396203749028518, log_scalelog = -0.668710159202585), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 0.449577163352274, log_sdlog = -0.142359425063462), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 0.445125913513896, log_sdlog = -0.196477691214009), value = 16.6758678063094, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.8135229351217, -2.72708150472351e-07, -2.72708150472351e-07, 20.0000147065809)), est = c(meanlog = 0.445125913513896, sdlog = 0.821619660427973), pars = list(meanlog = 0.445125913513896, log_sdlog = -0.196477691214009), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -0.311430735190836, log_sdlog1 = -1.89966266223835, meanlog2 = 1.21058506189538, log_sdlog2 = -0.692593198323942, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -0.308771827414923, log_sdlog1 = -2.03114672578293, meanlog2 = 1.19403040885289, log_sdlog2 = -0.797034753547832, pmix = 0.498337901729023), value = 11.3488497889913, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(288.190023186438, -0.0833658453059696, -0.788260857686404, 0.90375962561372, -0.489403332045587, -0.0833658453059696, 9.95919313615642, -0.0467455271308537, 0.0536356398802495, 
    -0.0290823654323725, -0.788260857686404, -0.0467455271308537, 23.9405244899582, 0.943420228040546, -0.446967942328035, 0.90375962561372, 0.0536356398802495, 0.943420228040546, 8.85208427183911, 0.551431961882911, -0.489403332045587, -0.0290823654323725, -0.446967942328035, 0.551431961882911, 39.7365576178185)), est = c(meanlog1 = -0.308771827414923, meanlog2 = 1.19403040885289, pmix = 0.498337901729023, sdlog1 = 0.131185001638973, sdlog2 = 0.450663312592259), pars = list(meanlog1 = -0.308771827414923, 
        meanlog2 = 1.19403040885289, pmix = 0.498337901729023, log_sdlog1 = -2.03114672578293, log_sdlog2 = -0.797034753547832), flags = list(at_boundary = FALSE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.150389323608881, log_scale = 0.895198407358448), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.252237051343527, log_scale = 0.866075278091329), value = 17.3460904626157, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(18.833004054424, -5.89762325039989, -5.89762325039989, 16.5611479715735)), est = c(scale = 2.37756125149869, shape = 1.28690106275598), pars = list(log_scale = 0.866075278091329, log_shape = 0.252237051343527), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.410544,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,10,4.11572,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.313310043121904, log_scale = 0.468793393642748), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.488893148492065, log_scale = 0.293210676328775), value = 17.195866523443, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(22.2647264475715, 16.3051062368479, 16.3051062368479, 16.3051012683112)), est = c(scale = 1.34072521974724, shape = 1.63051048780892), pars = list(log_scale = 0.293210676328775, log_shape = 0.488893148492065), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 0.445125904309182, log_scalelog = 0.105052752181371), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.0523837981861042, log_scalelog = -0.435255982815164), value = 16.1679734857783, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(23.8813422478162, -6.07440192220193, -6.07440192220193, 15.7935174396287)), est = c(locationlog = 0.0523837981861042, scalelog = 0.647098999651312), pars = list(locationlog = 0.0523837981861042, log_scalelog = -0.435255982815164), flags = list(
        at_boundary = FALSE, computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 0.445125904309182, log_scalelog = 0.451626342461343), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.396203749028518, log_scalelog = -0.668710159202585), value = 17.2608170766989, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(11.5652826590785, -0.960872692309404, -0.960872692309404, 15.9921428127923)), est = c(locationlog = 0.396203749028518, scalelog = 0.512369026231668), pars = list(locationlog = 0.396203749028518, log_scalelog = -0.668710159202585), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 0.449577163352274, log_sdlog = -0.142359425063462), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 0.445125913513896, log_sdlog = -0.196477691214009), value = 16.6758678063094, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.8135229351217, -2.72708150472351e-07, -2.72708150472351e-07, 20.0000147065809)), est = c(meanlog = 0.445125913513896, sdlog = 0.821619660427973), pars = list(meanlog = 0.445125913513896, log_sdlog = -0.196477691214009), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -0.311430735190836, log_sdlog1 = -1.89966266223835, meanlog2 = 1.21058506189538, log_sdlog2 = -0.692593198323942, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -0.308771827414923, log_sdlog1 = -2.03114672578293, meanlog2 = 1.19403040885289, log_sdlog2 = -0.797034753547832, pmix = 0.498337901729023), value = 11.3488497889913, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(288.190023186438, -0.0833658453059696, -0.788260857686404, 0.90375962561372, -0.489403332045587, -0.0833658453059696, 9.95919313615642, -0.0467455271308537, 0.0536356398802495, 
    -0.0290823654323725, -0.788260857686404, -0.0467455271308537, 23.9405244899582, 0.943420228040546, -0.446967942328035, 0.90375962561372, 0.0536356398802495, 0.943420228040546, 8.85208427183911, 0.551431961882911, -0.489403332045587, -0.0290823654323725, -0.446967942328035, 0.551431961882911, 39.7365576178185)), est = c(meanlog1 = -0.308771827414923, meanlog2 = 1.19403040885289, pmix = 0.498337901729023, sdlog1 = 0.131185001638973, sdlog2 = 0.450663312592259), pars = list(meanlog1 = -0.308771827414923, 
        meanlog2 = 1.19403040885289, pmix = 0.498337901729023, log_sdlog1 = -2.03114672578293, log_sdlog2 = -0.797034753547832), flags = list(at_boundary = FALSE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.150389323608881, log_scale = 0.895198407358448), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.252237051343527, log_scale = 0.866075278091329), value = 17.3460904626157, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(18.833004054424, -5.89762325039989, -5.89762325039989, 16.5611479715735)), est = c(scale = 2.37756125149869, shape = 1.28690106275598), pars = list(log_scale = 0.866075278091329, log_shape = 0.252237051343527), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.410544,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,6,0.288638,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.666545825730291, log_scale = -0.831617395063014), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.579410455662064, log_scale = -0.744479707125134), value = 4.50145219642055, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.2407259785313, 10.7099156458426, 10.7099156458426, 10.7098917141745)), est = c(scale = 0.474981365081169, shape = 1.78498579222492), pars = list(log_scale = -0.744479707125134, log_shape = 0.579410455662064), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = -0.470614259619334, log_scalelog = 0.175816968066392), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = -0.904133621247625, log_scalelog = -0.225750359220163), value = 5.08169729113658, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.42401242003915, -3.4341163924165, -3.4341163924165, 11.2657575358147)), est = c(locationlog = -0.904133621247625, scalelog = 0.797917269493836), pars = list(locationlog = -0.904133621247625, log_scalelog = -0.225750359220163), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = -0.470614259619334, log_scalelog = 0.522390558346364), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = -0.428302228723782, log_scalelog = -0.632268155981293), value = 5.06592279997596, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(6.4100999142902, 0.418449754401674, 0.418449754401674, 9.67944003660899)), est = c(locationlog = -0.428302228723782, scalelog = 0.531385168660339), pars = list(locationlog = -0.428302228723782, log_scalelog = -0.632268155981293), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = -0.475320402215528, log_sdlog = -0.0723028513372912), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = -0.470614287502052, log_sdlog = -0.164194053979775), value = 4.70478187211634, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.33236706425389, 4.64658418715651e-07, 4.64658418715651e-07, 12.0000102179342)), est = c(meanlog = -0.470614287502052, sdlog = 0.848577336092542), pars = list(meanlog = -0.470614287502052, log_sdlog = -0.164194053979775), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -1.28366726633283, log_sdlog1 = -0.720964043822069, meanlog2 = 0.333026461901773, log_sdlog2 = -2.57101644371957, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -1.27084587699122, log_sdlog1 = -0.930436715945484, meanlog2 = 0.329730867283933, log_sdlog2 = -2.79971262011664, pmix = 0.5), value = -1.34348051363851, counts = c(`function` = 19, gradient = 19), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.2670691436771, -0.033156495291315, -0.0109082859932608, -0.000180789706254138, -0.00879700129999785, -0.033156495291315, 5.95098681388796, -0.0142587226206303, -0.000210713240973324, 
    -0.0130531185970101, -0.0109082859932608, -0.0142587226206303, 810.701711114545, -0.00186696205033566, -0.00472856561395396, -0.000180789706254138, -0.000210713240973324, -0.00186696205033566, 5.99946130760755, -8.39540226193817e-05, -0.00879700129999785, -0.0130531185970101, -0.00472856561395396, -8.39540226193817e-05, 23.9966328737282)), est = c(meanlog1 = -1.27084587699122, meanlog2 = 0.329730867283933, pmix = 0.5, sdlog1 = 0.394381440094259, sdlog2 = 0.060827540725229), pars = list(meanlog1 = -1.27084587699122, 
        meanlog2 = 0.329730867283933, pmix = 0.5, log_sdlog1 = -0.930436715945484, log_sdlog2 = -2.79971262011664), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.0870574989549454, log_scale = -0.0117731144931627), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.400189824815353, log_scale = -0.0635480748731807), value = 4.41949386816115, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.4115194644952, -3.5149429751779, -3.5149429751779, 13.3583173272637)), est = c(scale = 0.938429003360875, shape = 1.49210790986854), pars = list(log_scale = -0.0635480748731807, log_shape = 0.400189824815353), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.143255,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,6,0.170798,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.666545825730291, log_scale = -0.831617395063014), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.579410455662064, log_scale = -0.744479707125134), value = 4.50145219642055, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.2407259785313, 10.7099156458426, 10.7099156458426, 10.7098917141745)), est = c(scale = 0.474981365081169, shape = 1.78498579222492), pars = list(log_scale = -0.744479707125134, log_shape = 0.579410455662064), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = -0.470614259619334, log_scalelog = 0.175816968066392), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = -0.904133621247625, log_scalelog = -0.225750359220163), value = 5.08169729113658, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.42401242003915, -3.4341163924165, -3.4341163924165, 11.2657575358147)), est = c(locationlog = -0.904133621247625, scalelog = 0.797917269493836), pars = list(locationlog = -0.904133621247625, log_scalelog = -0.225750359220163), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = -0.470614259619334, log_scalelog = 0.522390558346364), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = -0.428302228723782, log_scalelog = -0.632268155981293), value = 5.06592279997596, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(6.4100999142902, 0.418449754401674, 0.418449754401674, 9.67944003660899)), est = c(locationlog = -0.428302228723782, scalelog = 0.531385168660339), pars = list(locationlog = -0.428302228723782, log_scalelog = -0.632268155981293), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = -0.475320402215528, log_sdlog = -0.0723028513372912), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = -0.470614287502052, log_sdlog = -0.164194053979775), value = 4.70478187211634, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.33236706425389, 4.64658418715651e-07, 4.64658418715651e-07, 12.0000102179342)), est = c(meanlog = -0.470614287502052, sdlog = 0.848577336092542), pars = list(meanlog = -0.470614287502052, log_sdlog = -0.164194053979775), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -1.28366726633283, log_sdlog1 = -0.720964043822069, meanlog2 = 0.333026461901773, log_sdlog2 = -2.57101644371957, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -1.27084587699122, log_sdlog1 = -0.930436715945484, meanlog2 = 0.329730867283933, log_sdlog2 = -2.79971262011664, pmix = 0.5), value = -1.34348051363851, counts = c(`function` = 19, gradient = 19), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.2670691436771, -0.033156495291315, -0.0109082859932608, -0.000180789706254138, -0.00879700129999785, -0.033156495291315, 5.95098681388796, -0.0142587226206303, -0.000210713240973324, 
    -0.0130531185970101, -0.0109082859932608, -0.0142587226206303, 810.701711114545, -0.00186696205033566, -0.00472856561395396, -0.000180789706254138, -0.000210713240973324, -0.00186696205033566, 5.99946130760755, -8.39540226193817e-05, -0.00879700129999785, -0.0130531185970101, -0.00472856561395396, -8.39540226193817e-05, 23.9966328737282)), est = c(meanlog1 = -1.27084587699122, meanlog2 = 0.329730867283933, pmix = 0.5, sdlog1 = 0.394381440094259, sdlog2 = 0.060827540725229), pars = list(meanlog1 = -1.27084587699122, 
        meanlog2 = 0.329730867283933, pmix = 0.5, log_sdlog1 = -0.930436715945484, log_sdlog2 = -2.79971262011664), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.0870574989549454, log_scale = -0.0117731144931627), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.400189824815353, log_scale = -0.0635480748731807), value = 4.41949386816115, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.4115194644952, -3.5149429751779, -3.5149429751779, 13.3583173272637)), est = c(scale = 0.938429003360875, shape = 1.49210790986854), pars = list(log_scale = -0.0635480748731807, log_shape = 0.400189824815353), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.143255,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,6,0.447976,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.666545825730291, log_scale = -0.831617395063014), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.579410455662064, log_scale = -0.744479707125134), value = 4.50145219642055, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.2407259785313, 10.7099156458426, 10.7099156458426, 10.7098917141745)), est = c(scale = 0.474981365081169, shape = 1.78498579222492), pars = list(log_scale = -0.744479707125134, log_shape = 0.579410455662064), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = -0.470614259619334, log_scalelog = 0.175816968066392), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = -0.904133621247625, log_scalelog = -0.225750359220163), value = 5.08169729113658, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.42401242003915, -3.4341163924165, -3.4341163924165, 11.2657575358147)), est = c(locationlog = -0.904133621247625, scalelog = 0.797917269493836), pars = list(locationlog = -0.904133621247625, log_scalelog = -0.225750359220163), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = -0.470614259619334, log_scalelog = 0.522390558346364), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = -0.428302228723782, log_scalelog = -0.632268155981293), value = 5.06592279997596, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(6.4100999142902, 0.418449754401674, 0.418449754401674, 9.67944003660899)), est = c(locationlog = -0.428302228723782, scalelog = 0.531385168660339), pars = list(locationlog = -0.428302228723782, log_scalelog = -0.632268155981293), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = -0.475320402215528, log_sdlog = -0.0723028513372912), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = -0.470614287502052, log_sdlog = -0.164194053979775), value = 4.70478187211634, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.33236706425389, 4.64658418715651e-07, 4.64658418715651e-07, 12.0000102179342)), est = c(meanlog = -0.470614287502052, sdlog = 0.848577336092542), pars = list(meanlog = -0.470614287502052, log_sdlog = -0.164194053979775), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -1.28366726633283, log_sdlog1 = -0.720964043822069, meanlog2 = 0.333026461901773, log_sdlog2 = -2.57101644371957, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -1.27084587699122, log_sdlog1 = -0.930436715945484, meanlog2 = 0.329730867283933, log_sdlog2 = -2.79971262011664, pmix = 0.5), value = -1.34348051363851, counts = c(`function` = 19, gradient = 19), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.2670691436771, -0.033156495291315, -0.0109082859932608, -0.000180789706254138, -0.00879700129999785, -0.033156495291315, 5.95098681388796, -0.0142587226206303, -0.000210713240973324, 
    -0.0130531185970101, -0.0109082859932608, -0.0142587226206303, 810.701711114545, -0.00186696205033566, -0.00472856561395396, -0.000180789706254138, -0.000210713240973324, -0.00186696205033566, 5.99946130760755, -8.39540226193817e-05, -0.00879700129999785, -0.0130531185970101, -0.00472856561395396, -8.39540226193817e-05, 23.9966328737282)), est = c(meanlog1 = -1.27084587699122, meanlog2 = 0.329730867283933, pmix = 0.5, sdlog1 = 0.394381440094259, sdlog2 = 0.060827540725229), pars = list(meanlog1 = -1.27084587699122, 
        meanlog2 = 0.329730867283933, pmix = 0.5, log_sdlog1 = -0.930436715945484, log_sdlog2 = -2.79971262011664), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.0870574989549454, log_scale = -0.0117731144931627), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.400189824815353, log_scale = -0.0635480748731807), value = 4.41949386816115, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.4115194644952, -3.5149429751779, -3.5149429751779, 13.3583173272637)), est = c(scale = 0.938429003360875, shape = 1.49210790986854), pars = list(log_scale = -0.0635480748731807, log_shape = 0.400189824815353), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.143255,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,6,1.35322,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.666545825730291, log_scale = -0.831617395063014), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.579410455662064, log_scale = -0.744479707125134), value = 4.50145219642055, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.2407259785313, 10.7099156458426, 10.7099156458426, 10.7098917141745)), est = c(scale = 0.474981365081169, shape = 1.78498579222492), pars = list(log_scale = -0.744479707125134, log_shape = 0.579410455662064), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = -0.470614259619334, log_scalelog = 0.175816968066392), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = -0.904133621247625, log_scalelog = -0.225750359220163), value = 5.08169729113658, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.42401242003915, -3.4341163924165, -3.4341163924165, 11.2657575358147)), est = c(locationlog = -0.904133621247625, scalelog = 0.797917269493836), pars = list(locationlog = -0.904133621247625, log_scalelog = -0.225750359220163), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = -0.470614259619334, log_scalelog = 0.522390558346364), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = -0.428302228723782, log_scalelog = -0.632268155981293), value = 5.06592279997596, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(6.4100999142902, 0.418449754401674, 0.418449754401674, 9.67944003660899)), est = c(locationlog = -0.428302228723782, scalelog = 0.531385168660339), pars = list(locationlog = -0.428302228723782, log_scalelog = -0.632268155981293), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = -0.475320402215528, log_sdlog = -0.0723028513372912), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = -0.470614287502052, log_sdlog = -0.164194053979775), value = 4.70478187211634, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.33236706425389, 4.64658418715651e-07, 4.64658418715651e-07, 12.0000102179342)), est = c(meanlog = -0.470614287502052, sdlog = 0.848577336092542), pars = list(meanlog = -0.470614287502052, log_sdlog = -0.164194053979775), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -1.28366726633283, log_sdlog1 = -0.720964043822069, meanlog2 = 0.333026461901773, log_sdlog2 = -2.57101644371957, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -1.27084587699122, log_sdlog1 = -0.930436715945484, meanlog2 = 0.329730867283933, log_sdlog2 = -2.79971262011664, pmix = 0.5), value = -1.34348051363851, counts = c(`function` = 19, gradient = 19), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.2670691436771, -0.033156495291315, -0.0109082859932608, -0.000180789706254138, -0.00879700129999785, -0.033156495291315, 5.95098681388796, -0.0142587226206303, -0.000210713240973324, 
    -0.0130531185970101, -0.0109082859932608, -0.0142587226206303, 810.701711114545, -0.00186696205033566, -0.00472856561395396, -0.000180789706254138, -0.000210713240973324, -0.00186696205033566, 5.99946130760755, -8.39540226193817e-05, -0.00879700129999785, -0.0130531185970101, -0.00472856561395396, -8.39540226193817e-05, 23.9966328737282)), est = c(meanlog1 = -1.27084587699122, meanlog2 = 0.329730867283933, pmix = 0.5, sdlog1 = 0.394381440094259, sdlog2 = 0.060827540725229), pars = list(meanlog1 = -1.27084587699122, 
        meanlog2 = 0.329730867283933, pmix = 0.5, log_sdlog1 = -0.930436715945484, log_sdlog2 = -2.79971262011664), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.0870574989549454, log_scale = -0.0117731144931627), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.400189824815353, log_scale = -0.0635480748731807), value = 4.41949386816115, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.4115194644952, -3.5149429751779, -3.5149429751779, 13.3583173272637)), est = c(scale = 0.938429003360875, shape = 1.49210790986854), pars = list(log_scale = -0.0635480748731807, log_shape = 0.400189824815353), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.143255,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,6,1.31349,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.666545825730291, log_scale = -0.831617395063014), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.579410455662064, log_scale = -0.744479707125134), value = 4.50145219642055, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.2407259785313, 10.7099156458426, 10.7099156458426, 10.7098917141745)), est = c(scale = 0.474981365081169, shape = 1.78498579222492), pars = list(log_scale = -0.744479707125134, log_shape = 0.579410455662064), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = -0.470614259619334, log_scalelog = 0.175816968066392), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = -0.904133621247625, log_scalelog = -0.225750359220163), value = 5.08169729113658, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.42401242003915, -3.4341163924165, -3.4341163924165, 11.2657575358147)), est = c(locationlog = -0.904133621247625, scalelog = 0.797917269493836), pars = list(locationlog = -0.904133621247625, log_scalelog = -0.225750359220163), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = -0.470614259619334, log_scalelog = 0.522390558346364), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = -0.428302228723782, log_scalelog = -0.632268155981293), value = 5.06592279997596, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(6.4100999142902, 0.418449754401674, 0.418449754401674, 9.67944003660899)), est = c(locationlog = -0.428302228723782, scalelog = 0.531385168660339), pars = list(locationlog = -0.428302228723782, log_scalelog = -0.632268155981293), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = -0.475320402215528, log_sdlog = -0.0723028513372912), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = -0.470614287502052, log_sdlog = -0.164194053979775), value = 4.70478187211634, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.33236706425389, 4.64658418715651e-07, 4.64658418715651e-07, 12.0000102179342)), est = c(meanlog = -0.470614287502052, sdlog = 0.848577336092542), pars = list(meanlog = -0.470614287502052, log_sdlog = -0.164194053979775), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -1.28366726633283, log_sdlog1 = -0.720964043822069, meanlog2 = 0.333026461901773, log_sdlog2 = -2.57101644371957, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -1.27084587699122, log_sdlog1 = -0.930436715945484, meanlog2 = 0.329730867283933, log_sdlog2 = -2.79971262011664, pmix = 0.5), value = -1.34348051363851, counts = c(`function` = 19, gradient = 19), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.2670691436771, -0.033156495291315, -0.0109082859932608, -0.000180789706254138, -0.00879700129999785, -0.033156495291315, 5.95098681388796, -0.0142587226206303, -0.000210713240973324, 
    -0.0130531185970101, -0.0109082859932608, -0.0142587226206303, 810.701711114545, -0.00186696205033566, -0.00472856561395396, -0.000180789706254138, -0.000210713240973324, -0.00186696205033566, 5.99946130760755, -8.39540226193817e-05, -0.00879700129999785, -0.0130531185970101, -0.00472856561395396, -8.39540226193817e-05, 23.9966328737282)), est = c(meanlog1 = -1.27084587699122, meanlog2 = 0.329730867283933, pmix = 0.5, sdlog1 = 0.394381440094259, sdlog2 = 0.060827540725229), pars = list(meanlog1 = -1.27084587699122, 
        meanlog2 = 0.329730867283933, pmix = 0.5, log_sdlog1 = -0.930436715945484, log_sdlog2 = -2.79971262011664), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.0870574989549454, log_scale = -0.0117731144931627), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.400189824815353, log_scale = -0.0635480748731807), value = 4.41949386816115, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.4115194644952, -3.5149429751779, -3.5149429751779, 13.3583173272637)), est = c(scale = 0.938429003360875, shape = 1.49210790986854), pars = list(log_scale = -0.0635480748731807, log_shape = 0.400189824815353), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.143255,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,6,1.51288,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.666545825730291, log_scale = -0.831617395063014), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.579410455662064, log_scale = -0.744479707125134), value = 4.50145219642055, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.2407259785313, 10.7099156458426, 10.7099156458426, 10.7098917141745)), est = c(scale = 0.474981365081169, shape = 1.78498579222492), pars = list(log_scale = -0.744479707125134, log_shape = 0.579410455662064), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = -0.470614259619334, log_scalelog = 0.175816968066392), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = -0.904133621247625, log_scalelog = -0.225750359220163), value = 5.08169729113658, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.42401242003915, -3.4341163924165, -3.4341163924165, 11.2657575358147)), est = c(locationlog = -0.904133621247625, scalelog = 0.797917269493836), pars = list(locationlog = -0.904133621247625, log_scalelog = -0.225750359220163), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = -0.470614259619334, log_scalelog = 0.522390558346364), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = -0.428302228723782, log_scalelog = -0.632268155981293), value = 5.06592279997596, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(6.4100999142902, 0.418449754401674, 0.418449754401674, 9.67944003660899)), est = c(locationlog = -0.428302228723782, scalelog = 0.531385168660339), pars = list(locationlog = -0.428302228723782, log_scalelog = -0.632268155981293), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = -0.475320402215528, log_sdlog = -0.0723028513372912), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = -0.470614287502052, log_sdlog = -0.164194053979775), value = 4.70478187211634, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.33236706425389, 4.64658418715651e-07, 4.64658418715651e-07, 12.0000102179342)), est = c(meanlog = -0.470614287502052, sdlog = 0.848577336092542), pars = list(meanlog = -0.470614287502052, log_sdlog = -0.164194053979775), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -1.28366726633283, log_sdlog1 = -0.720964043822069, meanlog2 = 0.333026461901773, log_sdlog2 = -2.57101644371957, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -1.27084587699122, log_sdlog1 = -0.930436715945484, meanlog2 = 0.329730867283933, log_sdlog2 = -2.79971262011664, pmix = 0.5), value = -1.34348051363851, counts = c(`function` = 19, gradient = 19), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.2670691436771, -0.033156495291315, -0.0109082859932608, -0.000180789706254138, -0.00879700129999785, -0.033156495291315, 5.95098681388796, -0.0142587226206303, -0.000210713240973324, 
    -0.0130531185970101, -0.0109082859932608, -0.0142587226206303, 810.701711114545, -0.00186696205033566, -0.00472856561395396, -0.000180789706254138, -0.000210713240973324, -0.00186696205033566, 5.99946130760755, -8.39540226193817e-05, -0.00879700129999785, -0.0130531185970101, -0.00472856561395396, -8.39540226193817e-05, 23.9966328737282)), est = c(meanlog1 = -1.27084587699122, meanlog2 = 0.329730867283933, pmix = 0.5, sdlog1 = 0.394381440094259, sdlog2 = 0.060827540725229), pars = list(meanlog1 = -1.27084587699122, 
        meanlog2 = 0.329730867283933, pmix = 0.5, log_sdlog1 = -0.930436715945484, log_sdlog2 = -2.79971262011664), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.0870574989549454, log_scale = -0.0117731144931627), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.400189824815353, log_scale = -0.0635480748731807), value = 4.41949386816115, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.4115194644952, -3.5149429751779, -3.5149429751779, 13.3583173272637)), est = c(scale = 0.938429003360875, shape = 1.49210790986854), pars = list(log_scale = -0.0635480748731807, log_shape = 0.400189824815353), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.143255,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,10,0.288638,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 1.08965565115993, log_scale = -0.874886188954804), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.719386267549595, log_scale = -0.504611737671322), value = 10.9114849647188, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(26.3101829308068, 20.5317289625299, 20.5317289625299, 20.5316266256697)), est = c(scale = 0.603739939401533, shape = 2.05317272515532), pars = list(log_scale = -0.504611737671322, log_shape = 0.719386267549595), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = -0.0481012058269039, log_scalelog = 0.132286820914897), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = -0.504332114515477, log_scalelog = -0.0793300034813957), value = 13.6646699738363, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(11.7193987255328, -5.47888066621961, -5.47888066621961, 21.5703740109553)), est = c(locationlog = -0.504332114515477, scalelog = 0.923735038362573), pars = list(locationlog = -0.504332114515477, log_scalelog = -0.0793300034813957), flags = list(
        at_boundary = FALSE, computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = -0.0481012058269039, log_scalelog = 0.47886041119487), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.090614251529311, log_scalelog = -0.732930412563481), value = 12.1625054825233, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.4218463902552, 2.66639463081363, 2.66639463081363, 14.2249240872724)), est = c(locationlog = 0.090614251529311, scalelog = 0.480498865064333), pars = list(locationlog = 0.090614251529311, log_scalelog = -0.732930412563481), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = -0.048582217885173, log_sdlog = -0.115397697017271), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = -0.0481058621980201, log_sdlog = -0.169243752518798), value = 12.0159373924362, counts = c(`function` = 6, gradient = 6), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.0282422060839, 0.000130641447811457, 0.000130641447811457, 20.0000199087256)), est = c(meanlog = -0.0481058621980201, sdlog = 0.844303077300019), pars = list(meanlog = -0.0481058621980201, log_sdlog = -0.169243752518798), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -0.654015168908265, log_sdlog1 = -0.0831589266249067, meanlog2 = 0.55685073313792, log_sdlog2 = -1.61293656585375, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -1.27077306905376, log_sdlog1 = -0.930100467707033, meanlog2 = 0.475988425945152, log_sdlog2 = -1.65892475636163, pmix = 0.300034732925026), value = 5.41122690586385, counts = c(`function` = 22, gradient = 22), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.2413059302343, -0.0537769526742383, -0.0155856747475615, -0.000536293690274291, -0.016815917044849, -0.0537769526742383, 5.92029140321116, -0.0226696291943129, 
    -0.000867936111100888, -0.0250323926302005, -0.0155856747475615, -0.0226696291943129, 193.188701340865, -0.000117993131382568, -0.0074261092792788, -0.000536293690274291, -0.000867936111100888, -0.000117993131382568, 13.9992040740672, -0.000231216273245552, -0.016815917044849, -0.0250323926302005, -0.0074261092792788, -0.000231216273245552, 47.6084267520771)), est = c(meanlog1 = -1.27077306905376, meanlog2 = 0.475988425945152, pmix = 0.300034732925026, sdlog1 = 0.394514072456217, sdlog2 = 0.190343535784172
    ), pars = list(meanlog1 = -1.27077306905376, meanlog2 = 0.475988425945152, pmix = 0.300034732925026, log_sdlog1 = -0.930100467707033, log_sdlog2 = -1.65892475636163), flags = list(at_boundary = FALSE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.171024484167609, log_scale = 0.392779145792594), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.570946535987384, log_scale = 0.323413170070508), value = 10.3851160159588, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.4803436690636, -6.0610513939173, -6.0610513939173, 31.3269669941962)), est = c(scale = 1.38183616632186, shape = 1.76994157220529), pars = list(log_scale = 0.323413170070508, log_shape = 0.570946535987384), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.244793,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,10,0.170798,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 1.08965565115993, log_scale = -0.874886188954804), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.719386267549595, log_scale = -0.504611737671322), value = 10.9114849647188, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(26.3101829308068, 20.5317289625299, 20.5317289625299, 20.5316266256697)), est = c(scale = 0.603739939401533, shape = 2.05317272515532), pars = list(log_scale = -0.504611737671322, log_shape = 0.719386267549595), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = -0.0481012058269039, log_scalelog = 0.132286820914897), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = -0.504332114515477, log_scalelog = -0.0793300034813957), value = 13.6646699738363, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(11.7193987255328, -5.47888066621961, -5.47888066621961, 21.5703740109553)), est = c(locationlog = -0.504332114515477, scalelog = 0.923735038362573), pars = list(locationlog = -0.504332114515477, log_scalelog = -0.0793300034813957), flags = list(
        at_boundary = FALSE, computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = -0.0481012058269039, log_scalelog = 0.47886041119487), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.090614251529311, log_scalelog = -0.732930412563481), value = 12.1625054825233, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.4218463902552, 2.66639463081363, 2.66639463081363, 14.2249240872724)), est = c(locationlog = 0.090614251529311, scalelog = 0.480498865064333), pars = list(locationlog = 0.090614251529311, log_scalelog = -0.732930412563481), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = -0.048582217885173, log_sdlog = -0.115397697017271), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = -0.0481058621980201, log_sdlog = -0.169243752518798), value = 12.0159373924362, counts = c(`function` = 6, gradient = 6), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.0282422060839, 0.000130641447811457, 0.000130641447811457, 20.0000199087256)), est = c(meanlog = -0.0481058621980201, sdlog = 0.844303077300019), pars = list(meanlog = -0.0481058621980201, log_sdlog = -0.169243752518798), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -0.654015168908265, log_sdlog1 = -0.0831589266249067, meanlog2 = 0.55685073313792, log_sdlog2 = -1.61293656585375, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -1.27077306905376, log_sdlog1 = -0.930100467707033, meanlog2 = 0.475988425945152, log_sdlog2 = -1.65892475636163, pmix = 0.300034732925026), value = 5.41122690586385, counts = c(`function` = 22, gradient = 22), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.2413059302343, -0.0537769526742383, -0.0155856747475615, -0.000536293690274291, -0.016815917044849, -0.0537769526742383, 5.92029140321116, -0.0226696291943129, 
    -0.000867936111100888, -0.0250323926302005, -0.0155856747475615, -0.0226696291943129, 193.188701340865, -0.000117993131382568, -0.0074261092792788, -0.000536293690274291, -0.000867936111100888, -0.000117993131382568, 13.9992040740672, -0.000231216273245552, -0.016815917044849, -0.0250323926302005, -0.0074261092792788, -0.000231216273245552, 47.6084267520771)), est = c(meanlog1 = -1.27077306905376, meanlog2 = 0.475988425945152, pmix = 0.300034732925026, sdlog1 = 0.394514072456217, sdlog2 = 0.190343535784172
    ), pars = list(meanlog1 = -1.27077306905376, meanlog2 = 0.475988425945152, pmix = 0.300034732925026, log_sdlog1 = -0.930100467707033, log_sdlog2 = -1.65892475636163), flags = list(at_boundary = FALSE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.171024484167609, log_scale = 0.392779145792594), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.570946535987384, log_scale = 0.323413170070508), value = 10.3851160159588, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.4803436690636, -6.0610513939173, -6.0610513939173, 31.3269669941962)), est = c(scale = 1.38183616632186, shape = 1.76994157220529), pars = list(log_scale = 0.323413170070508, log_shape = 0.570946535987384), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.244793,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,10,0.447976,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 1.08965565115993, log_scale = -0.874886188954804), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.719386267549595, log_scale = -0.504611737671322), value = 10.9114849647188, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(26.3101829308068, 20.5317289625299, 20.5317289625299, 20.5316266256697)), est = c(scale = 0.603739939401533, shape = 2.05317272515532), pars = list(log_scale = -0.504611737671322, log_shape = 0.719386267549595), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = -0.0481012058269039, log_scalelog = 0.132286820914897), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = -0.504332114515477, log_scalelog = -0.0793300034813957), value = 13.6646699738363, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(11.7193987255328, -5.47888066621961, -5.47888066621961, 21.5703740109553)), est = c(locationlog = -0.504332114515477, scalelog = 0.923735038362573), pars = list(locationlog = -0.504332114515477, log_scalelog = -0.0793300034813957), flags = list(
        at_boundary = FALSE, computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = -0.0481012058269039, log_scalelog = 0.47886041119487), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.090614251529311, log_scalelog = -0.732930412563481), value = 12.1625054825233, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.4218463902552, 2.66639463081363, 2.66639463081363, 14.2249240872724)), est = c(locationlog = 0.090614251529311, scalelog = 0.480498865064333), pars = list(locationlog = 0.090614251529311, log_scalelog = -0.732930412563481), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = -0.048582217885173, log_sdlog = -0.115397697017271), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = -0.0481058621980201, log_sdlog = -0.169243752518798), value = 12.0159373924362, counts = c(`function` = 6, gradient = 6), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.0282422060839, 0.000130641447811457, 0.000130641447811457, 20.0000199087256)), est = c(meanlog = -0.0481058621980201, sdlog = 0.844303077300019), pars = list(meanlog = -0.0481058621980201, log_sdlog = -0.169243752518798), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -0.654015168908265, log_sdlog1 = -0.0831589266249067, meanlog2 = 0.55685073313792, log_sdlog2 = -1.61293656585375, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -1.27077306905376, log_sdlog1 = -0.930100467707033, meanlog2 = 0.475988425945152, log_sdlog2 = -1.65892475636163, pmix = 0.300034732925026), value = 5.41122690586385, counts = c(`function` = 22, gradient = 22), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.2413059302343, -0.0537769526742383, -0.0155856747475615, -0.000536293690274291, -0.016815917044849, -0.0537769526742383, 5.92029140321116, -0.0226696291943129, 
    -0.000867936111100888, -0.0250323926302005, -0.0155856747475615, -0.0226696291943129, 193.188701340865, -0.000117993131382568, -0.0074261092792788, -0.000536293690274291, -0.000867936111100888, -0.000117993131382568, 13.9992040740672, -0.000231216273245552, -0.016815917044849, -0.0250323926302005, -0.0074261092792788, -0.000231216273245552, 47.6084267520771)), est = c(meanlog1 = -1.27077306905376, meanlog2 = 0.475988425945152, pmix = 0.300034732925026, sdlog1 = 0.394514072456217, sdlog2 = 0.190343535784172
    ), pars = list(meanlog1 = -1.27077306905376, meanlog2 = 0.475988425945152, pmix = 0.300034732925026, log_sdlog1 = -0.930100467707033, log_sdlog2 = -1.65892475636163), flags = list(at_boundary = FALSE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.171024484167609, log_scale = 0.392779145792594), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.570946535987384, log_scale = 0.323413170070508), value = 10.3851160159588, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.4803436690636, -6.0610513939173, -6.0610513939173, 31.3269669941962)), est = c(scale = 1.38183616632186, shape = 1.76994157220529), pars = list(log_scale = 0.323413170070508, log_shape = 0.570946535987384), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.244793,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,10,1.35322,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 1.08965565115993, log_scale = -0.874886188954804), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.719386267549595, log_scale = -0.504611737671322), value = 10.9114849647188, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(26.3101829308068, 20.5317289625299, 20.5317289625299, 20.5316266256697)), est = c(scale = 0.603739939401533, shape = 2.05317272515532), pars = list(log_scale = -0.504611737671322, log_shape = 0.719386267549595), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = -0.0481012058269039, log_scalelog = 0.132286820914897), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = -0.504332114515477, log_scalelog = -0.0793300034813957), value = 13.6646699738363, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(11.7193987255328, -5.47888066621961, -5.47888066621961, 21.5703740109553)), est = c(locationlog = -0.504332114515477, scalelog = 0.923735038362573), pars = list(locationlog = -0.504332114515477, log_scalelog = -0.0793300034813957), flags = list(
        at_boundary = FALSE, computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = -0.0481012058269039, log_scalelog = 0.47886041119487), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.090614251529311, log_scalelog = -0.732930412563481), value = 12.1625054825233, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.4218463902552, 2.66639463081363, 2.66639463081363, 14.2249240872724)), est = c(locationlog = 0.090614251529311, scalelog = 0.480498865064333), pars = list(locationlog = 0.090614251529311, log_scalelog = -0.732930412563481), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = -0.048582217885173, log_sdlog = -0.115397697017271), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = -0.0481058621980201, log_sdlog = -0.169243752518798), value = 12.0159373924362, counts = c(`function` = 6, gradient = 6), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.0282422060839, 0.000130641447811457, 0.000130641447811457, 20.0000199087256)), est = c(meanlog = -0.0481058621980201, sdlog = 0.844303077300019), pars = list(meanlog = -0.0481058621980201, log_sdlog = -0.169243752518798), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -0.654015168908265, log_sdlog1 = -0.0831589266249067, meanlog2 = 0.55685073313792, log_sdlog2 = -1.61293656585375, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -1.27077306905376, log_sdlog1 = -0.930100467707033, meanlog2 = 0.475988425945152, log_sdlog2 = -1.65892475636163, pmix = 0.300034732925026), value = 5.41122690586385, counts = c(`function` = 22, gradient = 22), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.2413059302343, -0.0537769526742383, -0.0155856747475615, -0.000536293690274291, -0.016815917044849, -0.0537769526742383, 5.92029140321116, -0.0226696291943129, 
    -0.000867936111100888, -0.0250323926302005, -0.0155856747475615, -0.0226696291943129, 193.188701340865, -0.000117993131382568, -0.0074261092792788, -0.000536293690274291, -0.000867936111100888, -0.000117993131382568, 13.9992040740672, -0.000231216273245552, -0.016815917044849, -0.0250323926302005, -0.0074261092792788, -0.000231216273245552, 47.6084267520771)), est = c(meanlog1 = -1.27077306905376, meanlog2 = 0.475988425945152, pmix = 0.300034732925026, sdlog1 = 0.394514072456217, sdlog2 = 0.190343535784172
    ), pars = list(meanlog1 = -1.27077306905376, meanlog2 = 0.475988425945152, pmix = 0.300034732925026, log_sdlog1 = -0.930100467707033, log_sdlog2 = -1.65892475636163), flags = list(at_boundary = FALSE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.171024484167609, log_scale = 0.392779145792594), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.570946535987384, log_scale = 0.323413170070508), value = 10.3851160159588, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.4803436690636, -6.0610513939173, -6.0610513939173, 31.3269669941962)), est = c(scale = 1.38183616632186, shape = 1.76994157220529), pars = list(log_scale = 0.323413170070508, log_shape = 0.570946535987384), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.244793,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,10,1.31349,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 1.08965565115993, log_scale = -0.874886188954804), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.719386267549595, log_scale = -0.504611737671322), value = 10.9114849647188, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(26.3101829308068, 20.5317289625299, 20.5317289625299, 20.5316266256697)), est = c(scale = 0.603739939401533, shape = 2.05317272515532), pars = list(log_scale = -0.504611737671322, log_shape = 0.719386267549595), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = -0.0481012058269039, log_scalelog = 0.132286820914897), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = -0.504332114515477, log_scalelog = -0.0793300034813957), value = 13.6646699738363, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(11.7193987255328, -5.47888066621961, -5.47888066621961, 21.5703740109553)), est = c(locationlog = -0.504332114515477, scalelog = 0.923735038362573), pars = list(locationlog = -0.504332114515477, log_scalelog = -0.0793300034813957), flags = list(
        at_boundary = FALSE, computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = -0.0481012058269039, log_scalelog = 0.47886041119487), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.090614251529311, log_scalelog = -0.732930412563481), value = 12.1625054825233, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.4218463902552, 2.66639463081363, 2.66639463081363, 14.2249240872724)), est = c(locationlog = 0.090614251529311, scalelog = 0.480498865064333), pars = list(locationlog = 0.090614251529311, log_scalelog = -0.732930412563481), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = -0.048582217885173, log_sdlog = -0.115397697017271), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = -0.0481058621980201, log_sdlog = -0.169243752518798), value = 12.0159373924362, counts = c(`function` = 6, gradient = 6), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.0282422060839, 0.000130641447811457, 0.000130641447811457, 20.0000199087256)), est = c(meanlog = -0.0481058621980201, sdlog = 0.844303077300019), pars = list(meanlog = -0.0481058621980201, log_sdlog = -0.169243752518798), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -0.654015168908265, log_sdlog1 = -0.0831589266249067, meanlog2 = 0.55685073313792, log_sdlog2 = -1.61293656585375, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -1.27077306905376, log_sdlog1 = -0.930100467707033, meanlog2 = 0.475988425945152, log_sdlog2 = -1.65892475636163, pmix = 0.300034732925026), value = 5.41122690586385, counts = c(`function` = 22, gradient = 22), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.2413059302343, -0.0537769526742383, -0.0155856747475615, -0.000536293690274291, -0.016815917044849, -0.0537769526742383, 5.92029140321116, -0.0226696291943129, 
    -0.000867936111100888, -0.0250323926302005, -0.0155856747475615, -0.0226696291943129, 193.188701340865, -0.000117993131382568, -0.0074261092792788, -0.000536293690274291, -0.000867936111100888, -0.000117993131382568, 13.9992040740672, -0.000231216273245552, -0.016815917044849, -0.0250323926302005, -0.0074261092792788, -0.000231216273245552, 47.6084267520771)), est = c(meanlog1 = -1.27077306905376, meanlog2 = 0.475988425945152, pmix = 0.300034732925026, sdlog1 = 0.394514072456217, sdlog2 = 0.190343535784172
    ), pars = list(meanlog1 = -1.27077306905376, meanlog2 = 0.475988425945152, pmix = 0.300034732925026, log_sdlog1 = -0.930100467707033, log_sdlog2 = -1.65892475636163), flags = list(at_boundary = FALSE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.171024484167609, log_scale = 0.392779145792594), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.570946535987384, log_scale = 0.323413170070508), value = 10.3851160159588, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.4803436690636, -6.0610513939173, -6.0610513939173, 31.3269669941962)), est = c(scale = 1.38183616632186, shape = 1.76994157220529), pars = list(log_scale = 0.323413170070508, log_shape = 0.570946535987384), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.244793,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,10,1.51288,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 1.08965565115993, log_scale = -0.874886188954804), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.719386267549595, log_scale = -0.504611737671322), value = 10.9114849647188, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(26.3101829308068, 20.5317289625299, 20.5317289625299, 20.5316266256697)), est = c(scale = 0.603739939401533, shape = 2.05317272515532), pars = list(log_scale = -0.504611737671322, log_shape = 0.719386267549595), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = -0.0481012058269039, log_scalelog = 0.132286820914897), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = -0.504332114515477, log_scalelog = -0.0793300034813957), value = 13.6646699738363, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(11.7193987255328, -5.47888066621961, -5.47888066621961, 21.5703740109553)), est = c(locationlog = -0.504332114515477, scalelog = 0.923735038362573), pars = list(locationlog = -0.504332114515477, log_scalelog = -0.0793300034813957), flags = list(
        at_boundary = FALSE, computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = -0.0481012058269039, log_scalelog = 0.47886041119487), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.090614251529311, log_scalelog = -0.732930412563481), value = 12.1625054825233, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.4218463902552, 2.66639463081363, 2.66639463081363, 14.2249240872724)), est = c(locationlog = 0.090614251529311, scalelog = 0.480498865064333), pars = list(locationlog = 0.090614251529311, log_scalelog = -0.732930412563481), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = -0.048582217885173, log_sdlog = -0.115397697017271), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = -0.0481058621980201, log_sdlog = -0.169243752518798), value = 12.0159373924362, counts = c(`function` = 6, gradient = 6), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.0282422060839, 0.000130641447811457, 0.000130641447811457, 20.0000199087256)), est = c(meanlog = -0.0481058621980201, sdlog = 0.844303077300019), pars = list(meanlog = -0.0481058621980201, log_sdlog = -0.169243752518798), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -0.654015168908265, log_sdlog1 = -0.0831589266249067, meanlog2 = 0.55685073313792, log_sdlog2 = -1.61293656585375, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -1.27077306905376, log_sdlog1 = -0.930100467707033, meanlog2 = 0.475988425945152, log_sdlog2 = -1.65892475636163, pmix = 0.300034732925026), value = 5.41122690586385, counts = c(`function` = 22, gradient = 22), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.2413059302343, -0.0537769526742383, -0.0155856747475615, -0.000536293690274291, -0.016815917044849, -0.0537769526742383, 5.92029140321116, -0.0226696291943129, 
    -0.000867936111100888, -0.0250323926302005, -0.0155856747475615, -0.0226696291943129, 193.188701340865, -0.000117993131382568, -0.0074261092792788, -0.000536293690274291, -0.000867936111100888, -0.000117993131382568, 13.9992040740672, -0.000231216273245552, -0.016815917044849, -0.0250323926302005, -0.0074261092792788, -0.000231216273245552, 47.6084267520771)), est = c(meanlog1 = -1.27077306905376, meanlog2 = 0.475988425945152, pmix = 0.300034732925026, sdlog1 = 0.394514072456217, sdlog2 = 0.190343535784172
    ), pars = list(meanlog1 = -1.27077306905376, meanlog2 = 0.475988425945152, pmix = 0.300034732925026, log_sdlog1 = -0.930100467707033, log_sdlog2 = -1.65892475636163), flags = list(at_boundary = FALSE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.171024484167609, log_scale = 0.392779145792594), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.570946535987384, log_scale = 0.323413170070508), value = 10.3851160159588, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.4803436690636, -6.0610513939173, -6.0610513939173, 31.3269669941962)), est = c(scale = 1.38183616632186, shape = 1.76994157220529), pars = list(log_scale = 0.323413170070508, log_shape = 0.570946535987384), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.244793,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,10,1.7485,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 1.08965565115993, log_scale = -0.874886188954804), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.719386267549595, log_scale = -0.504611737671322), value = 10.9114849647188, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(26.3101829308068, 20.5317289625299, 20.5317289625299, 20.5316266256697)), est = c(scale = 0.603739939401533, shape = 2.05317272515532), pars = list(log_scale = -0.504611737671322, log_shape = 0.719386267549595), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = -0.0481012058269039, log_scalelog = 0.132286820914897), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = -0.504332114515477, log_scalelog = -0.0793300034813957), value = 13.6646699738363, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(11.7193987255328, -5.47888066621961, -5.47888066621961, 21.5703740109553)), est = c(locationlog = -0.504332114515477, scalelog = 0.923735038362573), pars = list(locationlog = -0.504332114515477, log_scalelog = -0.0793300034813957), flags = list(
        at_boundary = FALSE, computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = -0.0481012058269039, log_scalelog = 0.47886041119487), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.090614251529311, log_scalelog = -0.732930412563481), value = 12.1625054825233, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.4218463902552, 2.66639463081363, 2.66639463081363, 14.2249240872724)), est = c(locationlog = 0.090614251529311, scalelog = 0.480498865064333), pars = list(locationlog = 0.090614251529311, log_scalelog = -0.732930412563481), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = -0.048582217885173, log_sdlog = -0.115397697017271), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = -0.0481058621980201, log_sdlog = -0.169243752518798), value = 12.0159373924362, counts = c(`function` = 6, gradient = 6), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.0282422060839, 0.000130641447811457, 0.000130641447811457, 20.0000199087256)), est = c(meanlog = -0.0481058621980201, sdlog = 0.844303077300019), pars = list(meanlog = -0.0481058621980201, log_sdlog = -0.169243752518798), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -0.654015168908265, log_sdlog1 = -0.0831589266249067, meanlog2 = 0.55685073313792, log_sdlog2 = -1.61293656585375, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -1.27077306905376, log_sdlog1 = -0.930100467707033, meanlog2 = 0.475988425945152, log_sdlog2 = -1.65892475636163, pmix = 0.300034732925026), value = 5.41122690586385, counts = c(`function` = 22, gradient = 22), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.2413059302343, -0.0537769526742383, -0.0155856747475615, -0.000536293690274291, -0.016815917044849, -0.0537769526742383, 5.92029140321116, -0.0226696291943129, 
    -0.000867936111100888, -0.0250323926302005, -0.0155856747475615, -0.0226696291943129, 193.188701340865, -0.000117993131382568, -0.0074261092792788, -0.000536293690274291, -0.000867936111100888, -0.000117993131382568, 13.9992040740672, -0.000231216273245552, -0.016815917044849, -0.0250323926302005, -0.0074261092792788, -0.000231216273245552, 47.6084267520771)), est = c(meanlog1 = -1.27077306905376, meanlog2 = 0.475988425945152, pmix = 0.300034732925026, sdlog1 = 0.394514072456217, sdlog2 = 0.190343535784172
    ), pars = list(meanlog1 = -1.27077306905376, meanlog2 = 0.475988425945152, pmix = 0.300034732925026, log_sdlog1 = -0.930100467707033, log_sdlog2 = -1.65892475636163), flags = list(at_boundary = FALSE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.171024484167609, log_scale = 0.392779145792594), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.570946535987384, log_scale = 0.323413170070508), value = 10.3851160159588, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.4803436690636, -6.0610513939173, -6.0610513939173, 31.3269669941962)), est = c(scale = 1.38183616632186, shape = 1.76994157220529), pars = list(log_scale = 0.323413170070508, log_shape = 0.570946535987384), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.244793,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,10,1.51878,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 1.08965565115993, log_scale = -0.874886188954804), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.719386267549595, log_scale = -0.504611737671322), value = 10.9114849647188, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(26.3101829308068, 20.5317289625299, 20.5317289625299, 20.5316266256697)), est = c(scale = 0.603739939401533, shape = 2.05317272515532), pars = list(log_scale = -0.504611737671322, log_shape = 0.719386267549595), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = -0.0481012058269039, log_scalelog = 0.132286820914897), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = -0.504332114515477, log_scalelog = -0.0793300034813957), value = 13.6646699738363, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(11.7193987255328, -5.47888066621961, -5.47888066621961, 21.5703740109553)), est = c(locationlog = -0.504332114515477, scalelog = 0.923735038362573), pars = list(locationlog = -0.504332114515477, log_scalelog = -0.0793300034813957), flags = list(
        at_boundary = FALSE, computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = -0.0481012058269039, log_scalelog = 0.47886041119487), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.090614251529311, log_scalelog = -0.732930412563481), value = 12.1625054825233, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.4218463902552, 2.66639463081363, 2.66639463081363, 14.2249240872724)), est = c(locationlog = 0.090614251529311, scalelog = 0.480498865064333), pars = list(locationlog = 0.090614251529311, log_scalelog = -0.732930412563481), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = -0.048582217885173, log_sdlog = -0.115397697017271), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = -0.0481058621980201, log_sdlog = -0.169243752518798), value = 12.0159373924362, counts = c(`function` = 6, gradient = 6), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.0282422060839, 0.000130641447811457, 0.000130641447811457, 20.0000199087256)), est = c(meanlog = -0.0481058621980201, sdlog = 0.844303077300019), pars = list(meanlog = -0.0481058621980201, log_sdlog = -0.169243752518798), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -0.654015168908265, log_sdlog1 = -0.0831589266249067, meanlog2 = 0.55685073313792, log_sdlog2 = -1.61293656585375, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -1.27077306905376, log_sdlog1 = -0.930100467707033, meanlog2 = 0.475988425945152, log_sdlog2 = -1.65892475636163, pmix = 0.300034732925026), value = 5.41122690586385, counts = c(`function` = 22, gradient = 22), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.2413059302343, -0.0537769526742383, -0.0155856747475615, -0.000536293690274291, -0.016815917044849, -0.0537769526742383, 5.92029140321116, -0.0226696291943129, 
    -0.000867936111100888, -0.0250323926302005, -0.0155856747475615, -0.0226696291943129, 193.188701340865, -0.000117993131382568, -0.0074261092792788, -0.000536293690274291, -0.000867936111100888, -0.000117993131382568, 13.9992040740672, -0.000231216273245552, -0.016815917044849, -0.0250323926302005, -0.0074261092792788, -0.000231216273245552, 47.6084267520771)), est = c(meanlog1 = -1.27077306905376, meanlog2 = 0.475988425945152, pmix = 0.300034732925026, sdlog1 = 0.394514072456217, sdlog2 = 0.190343535784172
    ), pars = list(meanlog1 = -1.27077306905376, meanlog2 = 0.475988425945152, pmix = 0.300034732925026, log_sdlog1 = -0.930100467707033, log_sdlog2 = -1.65892475636163), flags = list(at_boundary = FALSE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.171024484167609, log_scale = 0.392779145792594), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.570946535987384, log_scale = 0.323413170070508), value = 10.3851160159588, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.4803436690636, -6.0610513939173, -6.0610513939173, 31.3269669941962)), est = c(scale = 1.38183616632186, shape = 1.76994157220529), pars = list(log_scale = 0.323413170070508, log_shape = 0.570946535987384), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.244793,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,10,1.61611,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 1.08965565115993, log_scale = -0.874886188954804), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.719386267549595, log_scale = -0.504611737671322), value = 10.9114849647188, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(26.3101829308068, 20.5317289625299, 20.5317289625299, 20.5316266256697)), est = c(scale = 0.603739939401533, shape = 2.05317272515532), pars = list(log_scale = -0.504611737671322, log_shape = 0.719386267549595), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = -0.0481012058269039, log_scalelog = 0.132286820914897), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = -0.504332114515477, log_scalelog = -0.0793300034813957), value = 13.6646699738363, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(11.7193987255328, -5.47888066621961, -5.47888066621961, 21.5703740109553)), est = c(locationlog = -0.504332114515477, scalelog = 0.923735038362573), pars = list(locationlog = -0.504332114515477, log_scalelog = -0.0793300034813957), flags = list(
        at_boundary = FALSE, computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = -0.0481012058269039, log_scalelog = 0.47886041119487), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.090614251529311, log_scalelog = -0.732930412563481), value = 12.1625054825233, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.4218463902552, 2.66639463081363, 2.66639463081363, 14.2249240872724)), est = c(locationlog = 0.090614251529311, scalelog = 0.480498865064333), pars = list(locationlog = 0.090614251529311, log_scalelog = -0.732930412563481), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = -0.048582217885173, log_sdlog = -0.115397697017271), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = -0.0481058621980201, log_sdlog = -0.169243752518798), value = 12.0159373924362, counts = c(`function` = 6, gradient = 6), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.0282422060839, 0.000130641447811457, 0.000130641447811457, 20.0000199087256)), est = c(meanlog = -0.0481058621980201, sdlog = 0.844303077300019), pars = list(meanlog = -0.0481058621980201, log_sdlog = -0.169243752518798), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -0.654015168908265, log_sdlog1 = -0.0831589266249067, meanlog2 = 0.55685073313792, log_sdlog2 = -1.61293656585375, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -1.27077306905376, log_sdlog1 = -0.930100467707033, meanlog2 = 0.475988425945152, log_sdlog2 = -1.65892475636163, pmix = 0.300034732925026), value = 5.41122690586385, counts = c(`function` = 22, gradient = 22), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.2413059302343, -0.0537769526742383, -0.0155856747475615, -0.000536293690274291, -0.016815917044849, -0.0537769526742383, 5.92029140321116, -0.0226696291943129, 
    -0.000867936111100888, -0.0250323926302005, -0.0155856747475615, -0.0226696291943129, 193.188701340865, -0.000117993131382568, -0.0074261092792788, -0.000536293690274291, -0.000867936111100888, -0.000117993131382568, 13.9992040740672, -0.000231216273245552, -0.016815917044849, -0.0250323926302005, -0.0074261092792788, -0.000231216273245552, 47.6084267520771)), est = c(meanlog1 = -1.27077306905376, meanlog2 = 0.475988425945152, pmix = 0.300034732925026, sdlog1 = 0.394514072456217, sdlog2 = 0.190343535784172
    ), pars = list(meanlog1 = -1.27077306905376, meanlog2 = 0.475988425945152, pmix = 0.300034732925026, log_sdlog1 = -0.930100467707033, log_sdlog2 = -1.65892475636163), flags = list(at_boundary = FALSE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.171024484167609, log_scale = 0.392779145792594), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.570946535987384, log_scale = 0.323413170070508), value = 10.3851160159588, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.4803436690636, -6.0610513939173, -6.0610513939173, 31.3269669941962)), est = c(scale = 1.38183616632186, shape = 1.76994157220529), pars = list(log_scale = 0.323413170070508, log_shape = 0.570946535987384), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.244793,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,10,2.42537,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 1.08965565115993, log_scale = -0.874886188954804), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.719386267549595, log_scale = -0.504611737671322), value = 10.9114849647188, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(26.3101829308068, 20.5317289625299, 20.5317289625299, 20.5316266256697)), est = c(scale = 0.603739939401533, shape = 2.05317272515532), pars = list(log_scale = -0.504611737671322, log_shape = 0.719386267549595), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = -0.0481012058269039, log_scalelog = 0.132286820914897), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = -0.504332114515477, log_scalelog = -0.0793300034813957), value = 13.6646699738363, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(11.7193987255328, -5.47888066621961, -5.47888066621961, 21.5703740109553)), est = c(locationlog = -0.504332114515477, scalelog = 0.923735038362573), pars = list(locationlog = -0.504332114515477, log_scalelog = -0.0793300034813957), flags = list(
        at_boundary = FALSE, computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = -0.0481012058269039, log_scalelog = 0.47886041119487), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 0.090614251529311, log_scalelog = -0.732930412563481), value = 12.1625054825233, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.4218463902552, 2.66639463081363, 2.66639463081363, 14.2249240872724)), est = c(locationlog = 0.090614251529311, scalelog = 0.480498865064333), pars = list(locationlog = 0.090614251529311, log_scalelog = -0.732930412563481), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = -0.048582217885173, log_sdlog = -0.115397697017271), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = -0.0481058621980201, log_sdlog = -0.169243752518798), value = 12.0159373924362, counts = c(`function` = 6, gradient = 6), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.0282422060839, 0.000130641447811457, 0.000130641447811457, 20.0000199087256)), est = c(meanlog = -0.0481058621980201, sdlog = 0.844303077300019), pars = list(meanlog = -0.0481058621980201, log_sdlog = -0.169243752518798), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = -0.654015168908265, log_sdlog1 = -0.0831589266249067, meanlog2 = 0.55685073313792, log_sdlog2 = -1.61293656585375, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = -1.27077306905376, log_sdlog1 = -0.930100467707033, meanlog2 = 0.475988425945152, log_sdlog2 = -1.65892475636163, pmix = 0.300034732925026), value = 5.41122690586385, counts = c(`function` = 22, gradient = 22), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.2413059302343, -0.0537769526742383, -0.0155856747475615, -0.000536293690274291, -0.016815917044849, -0.0537769526742383, 5.92029140321116, -0.0226696291943129, 
    -0.000867936111100888, -0.0250323926302005, -0.0155856747475615, -0.0226696291943129, 193.188701340865, -0.000117993131382568, -0.0074261092792788, -0.000536293690274291, -0.000867936111100888, -0.000117993131382568, 13.9992040740672, -0.000231216273245552, -0.016815917044849, -0.0250323926302005, -0.0074261092792788, -0.000231216273245552, 47.6084267520771)), est = c(meanlog1 = -1.27077306905376, meanlog2 = 0.475988425945152, pmix = 0.300034732925026, sdlog1 = 0.394514072456217, sdlog2 = 0.190343535784172
    ), pars = list(meanlog1 = -1.27077306905376, meanlog2 = 0.475988425945152, pmix = 0.300034732925026, log_sdlog1 = -0.930100467707033, log_sdlog2 = -1.65892475636163), flags = list(at_boundary = FALSE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = 0.171024484167609, log_scale = 0.392779145792594), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.570946535987384, log_scale = 0.323413170070508), value = 10.3851160159588, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(14.4803436690636, -6.0610513939173, -6.0610513939173, 31.3269669941962)), est = c(scale = 1.38183616632186, shape = 1.76994157220529), pars = list(log_scale = 0.323413170070508, log_shape = 0.570946535987384), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,0.244793,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
