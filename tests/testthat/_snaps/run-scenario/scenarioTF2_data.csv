sim,stream,replace,nrow,Chemical,Species,Conc,Group,Units,fits,dist,proportion,est,se,lcl,ucl,wt,level,est_method,ci_method,boot_method,nboot,pboot,dists,samples
1,1,TRUE,5,Boron,Ceriodaphnia dubia,13.4,Invertebrate,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.404342295956148, log_scale = 3.17973204379166), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.0105313667858157, log_scale = 3.57354290637599), value = 22.9201935827036, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.27159371108351, 5.05293550514965, 5.05293550514965, 5.05293626268208)), est = c(scale = 35.6426482848709, shape = 1.01058701681439), pars = list(log_scale = 3.57354290637599, log_shape = 0.0105313667858157), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01361143021043, log_scalelog = 0.656875636393804), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.28904105433868, log_scalelog = 0.376119114857425), value = 24.4358118482949, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.3565510495971, -1.72511552626965, -1.72511552626965, 10.6498933497436)), est = c(locationlog = 2.28904105433868, scalelog = 1.45662062859647), pars = list(locationlog = 2.28904105433868, log_scalelog = 0.376119114857425), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01361143021043, log_scalelog = 1.00344922667378), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.21159478248024, log_scalelog = -0.264677785737225), value = 23.720568054143, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.81342660491168, 0.663711081769443, 0.663711081769443, 7.16360678673574)), est = c(locationlog = 3.21159478248024, scalelog = 0.767453194506141), pars = list(locationlog = 3.21159478248024, log_scalelog = -0.264677785737225), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04374754451254, log_sdlog = 0.403945230306847), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01361049211189, log_sdlog = 0.296454505400714), value = 23.6450183645866, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.76358541928495, 5.18503263296939e-06, 5.18503263296939e-06, 9.9999907486879)), est = c(meanlog = 3.01361049211189, sdlog = 1.34508136466754), pars = list(meanlog = 3.01361049211189, log_sdlog = 0.296454505400714), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 1.60743589278879, log_sdlog1 = 0.346797650585182, meanlog2 = 4.00128864566171, log_sdlog2 = -0.955683746294042, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 1.90372731530473, log_sdlog1 = 0.18184626406043, meanlog2 = 3.9933343044265, log_sdlog2 = -1.20835298286039, pmix = 0.5), value = 21.8945918630597, counts = c(`function` = 12, gradient = 12), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.15749458501768, -0.563743440651667, -0.772422299048776, 0.213541067331319, -1.43180326885801, -0.563743440651667, 3.91575777552026, -0.277663697958906, 0.0925194874597639, -1.59987627195682, 
    -0.772422299048776, -0.277663697958906, 24.3076366978829, 1.42889831677594, -3.05961733243781, 0.213541067331319, 0.0925194874597639, 1.42889831677594, 4.88222000496555, 0.832087488744832, -1.43180326885801, -1.59987627195682, -3.05961733243781, 0.832087488744832, 15.5345267050092)), est = c(meanlog1 = 1.90372731530473, meanlog2 = 3.9933343044265, pmix = 0.5, sdlog1 = 1.19942978424021, sdlog2 = 0.298688820136962), pars = list(meanlog1 = 1.90372731530473, meanlog2 = 3.9933343044265, pmix = 0.5, 
        log_sdlog1 = 0.18184626406043, log_sdlog2 = -1.20835298286039), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.401894528195339, log_scale = 3.74731745369501), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.0848299228971603, log_scale = 3.6113315359395), value = 22.8970770469694, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.28590117356708, -1.9014653883579, -1.9014653883579, 5.92448904106288)), est = c(scale = 37.0153072274199, shape = 1.08853191659923), pars = list(log_scale = 3.6113315359395, log_shape = 0.0848299228971603), flags = list(at_boundary = FALSE, computable = TRUE)))",lnorm_lnorm,0.05,1.44282,NA,NA,NA,1,0.95,cdf,percentile,parametric,0,1,lnorm_lnorm,numeric(0)
1,1,TRUE,5,Boron,Myriophyllum spicatum,34.2,Plant,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.404342295956148, log_scale = 3.17973204379166), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.0105313667858157, log_scale = 3.57354290637599), value = 22.9201935827036, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.27159371108351, 5.05293550514965, 5.05293550514965, 5.05293626268208)), est = c(scale = 35.6426482848709, shape = 1.01058701681439), pars = list(log_scale = 3.57354290637599, log_shape = 0.0105313667858157), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01361143021043, log_scalelog = 0.656875636393804), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.28904105433868, log_scalelog = 0.376119114857425), value = 24.4358118482949, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.3565510495971, -1.72511552626965, -1.72511552626965, 10.6498933497436)), est = c(locationlog = 2.28904105433868, scalelog = 1.45662062859647), pars = list(locationlog = 2.28904105433868, log_scalelog = 0.376119114857425), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01361143021043, log_scalelog = 1.00344922667378), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.21159478248024, log_scalelog = -0.264677785737225), value = 23.720568054143, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.81342660491168, 0.663711081769443, 0.663711081769443, 7.16360678673574)), est = c(locationlog = 3.21159478248024, scalelog = 0.767453194506141), pars = list(locationlog = 3.21159478248024, log_scalelog = -0.264677785737225), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04374754451254, log_sdlog = 0.403945230306847), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01361049211189, log_sdlog = 0.296454505400714), value = 23.6450183645866, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.76358541928495, 5.18503263296939e-06, 5.18503263296939e-06, 9.9999907486879)), est = c(meanlog = 3.01361049211189, sdlog = 1.34508136466754), pars = list(meanlog = 3.01361049211189, log_sdlog = 0.296454505400714), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 1.60743589278879, log_sdlog1 = 0.346797650585182, meanlog2 = 4.00128864566171, log_sdlog2 = -0.955683746294042, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 1.90372731530473, log_sdlog1 = 0.18184626406043, meanlog2 = 3.9933343044265, log_sdlog2 = -1.20835298286039, pmix = 0.5), value = 21.8945918630597, counts = c(`function` = 12, gradient = 12), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.15749458501768, -0.563743440651667, -0.772422299048776, 0.213541067331319, -1.43180326885801, -0.563743440651667, 3.91575777552026, -0.277663697958906, 0.0925194874597639, -1.59987627195682, 
    -0.772422299048776, -0.277663697958906, 24.3076366978829, 1.42889831677594, -3.05961733243781, 0.213541067331319, 0.0925194874597639, 1.42889831677594, 4.88222000496555, 0.832087488744832, -1.43180326885801, -1.59987627195682, -3.05961733243781, 0.832087488744832, 15.5345267050092)), est = c(meanlog1 = 1.90372731530473, meanlog2 = 3.9933343044265, pmix = 0.5, sdlog1 = 1.19942978424021, sdlog2 = 0.298688820136962), pars = list(meanlog1 = 1.90372731530473, meanlog2 = 3.9933343044265, pmix = 0.5, 
        log_sdlog1 = 0.18184626406043, log_sdlog2 = -1.20835298286039), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.401894528195339, log_scale = 3.74731745369501), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.0848299228971603, log_scale = 3.6113315359395), value = 22.8970770469694, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.28590117356708, -1.9014653883579, -1.9014653883579, 5.92448904106288)), est = c(scale = 37.0153072274199, shape = 1.08853191659923), pars = list(log_scale = 3.6113315359395, log_shape = 0.0848299228971603), flags = list(at_boundary = FALSE, computable = TRUE)))",lnorm_lnorm,0.05,1.44282,NA,NA,NA,1,0.95,cdf,percentile,parametric,0,1,lnorm_lnorm,numeric(0)
1,1,TRUE,5,Boron,Rana sylvatica,70.7,Amphibian,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.404342295956148, log_scale = 3.17973204379166), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.0105313667858157, log_scale = 3.57354290637599), value = 22.9201935827036, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.27159371108351, 5.05293550514965, 5.05293550514965, 5.05293626268208)), est = c(scale = 35.6426482848709, shape = 1.01058701681439), pars = list(log_scale = 3.57354290637599, log_shape = 0.0105313667858157), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01361143021043, log_scalelog = 0.656875636393804), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.28904105433868, log_scalelog = 0.376119114857425), value = 24.4358118482949, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.3565510495971, -1.72511552626965, -1.72511552626965, 10.6498933497436)), est = c(locationlog = 2.28904105433868, scalelog = 1.45662062859647), pars = list(locationlog = 2.28904105433868, log_scalelog = 0.376119114857425), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01361143021043, log_scalelog = 1.00344922667378), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.21159478248024, log_scalelog = -0.264677785737225), value = 23.720568054143, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.81342660491168, 0.663711081769443, 0.663711081769443, 7.16360678673574)), est = c(locationlog = 3.21159478248024, scalelog = 0.767453194506141), pars = list(locationlog = 3.21159478248024, log_scalelog = -0.264677785737225), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04374754451254, log_sdlog = 0.403945230306847), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01361049211189, log_sdlog = 0.296454505400714), value = 23.6450183645866, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.76358541928495, 5.18503263296939e-06, 5.18503263296939e-06, 9.9999907486879)), est = c(meanlog = 3.01361049211189, sdlog = 1.34508136466754), pars = list(meanlog = 3.01361049211189, log_sdlog = 0.296454505400714), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 1.60743589278879, log_sdlog1 = 0.346797650585182, meanlog2 = 4.00128864566171, log_sdlog2 = -0.955683746294042, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 1.90372731530473, log_sdlog1 = 0.18184626406043, meanlog2 = 3.9933343044265, log_sdlog2 = -1.20835298286039, pmix = 0.5), value = 21.8945918630597, counts = c(`function` = 12, gradient = 12), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.15749458501768, -0.563743440651667, -0.772422299048776, 0.213541067331319, -1.43180326885801, -0.563743440651667, 3.91575777552026, -0.277663697958906, 0.0925194874597639, -1.59987627195682, 
    -0.772422299048776, -0.277663697958906, 24.3076366978829, 1.42889831677594, -3.05961733243781, 0.213541067331319, 0.0925194874597639, 1.42889831677594, 4.88222000496555, 0.832087488744832, -1.43180326885801, -1.59987627195682, -3.05961733243781, 0.832087488744832, 15.5345267050092)), est = c(meanlog1 = 1.90372731530473, meanlog2 = 3.9933343044265, pmix = 0.5, sdlog1 = 1.19942978424021, sdlog2 = 0.298688820136962), pars = list(meanlog1 = 1.90372731530473, meanlog2 = 3.9933343044265, pmix = 0.5, 
        log_sdlog1 = 0.18184626406043, log_sdlog2 = -1.20835298286039), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.401894528195339, log_scale = 3.74731745369501), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.0848299228971603, log_scale = 3.6113315359395), value = 22.8970770469694, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.28590117356708, -1.9014653883579, -1.9014653883579, 5.92448904106288)), est = c(scale = 37.0153072274199, shape = 1.08853191659923), pars = list(log_scale = 3.6113315359395, log_shape = 0.0848299228971603), flags = list(at_boundary = FALSE, computable = TRUE)))",lnorm_lnorm,0.05,1.44282,NA,NA,NA,1,0.95,cdf,percentile,parametric,0,1,lnorm_lnorm,numeric(0)
1,1,TRUE,5,Boron,Lemna minor,60,Plant,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.404342295956148, log_scale = 3.17973204379166), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.0105313667858157, log_scale = 3.57354290637599), value = 22.9201935827036, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.27159371108351, 5.05293550514965, 5.05293550514965, 5.05293626268208)), est = c(scale = 35.6426482848709, shape = 1.01058701681439), pars = list(log_scale = 3.57354290637599, log_shape = 0.0105313667858157), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01361143021043, log_scalelog = 0.656875636393804), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.28904105433868, log_scalelog = 0.376119114857425), value = 24.4358118482949, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.3565510495971, -1.72511552626965, -1.72511552626965, 10.6498933497436)), est = c(locationlog = 2.28904105433868, scalelog = 1.45662062859647), pars = list(locationlog = 2.28904105433868, log_scalelog = 0.376119114857425), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01361143021043, log_scalelog = 1.00344922667378), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.21159478248024, log_scalelog = -0.264677785737225), value = 23.720568054143, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.81342660491168, 0.663711081769443, 0.663711081769443, 7.16360678673574)), est = c(locationlog = 3.21159478248024, scalelog = 0.767453194506141), pars = list(locationlog = 3.21159478248024, log_scalelog = -0.264677785737225), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04374754451254, log_sdlog = 0.403945230306847), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01361049211189, log_sdlog = 0.296454505400714), value = 23.6450183645866, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.76358541928495, 5.18503263296939e-06, 5.18503263296939e-06, 9.9999907486879)), est = c(meanlog = 3.01361049211189, sdlog = 1.34508136466754), pars = list(meanlog = 3.01361049211189, log_sdlog = 0.296454505400714), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 1.60743589278879, log_sdlog1 = 0.346797650585182, meanlog2 = 4.00128864566171, log_sdlog2 = -0.955683746294042, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 1.90372731530473, log_sdlog1 = 0.18184626406043, meanlog2 = 3.9933343044265, log_sdlog2 = -1.20835298286039, pmix = 0.5), value = 21.8945918630597, counts = c(`function` = 12, gradient = 12), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.15749458501768, -0.563743440651667, -0.772422299048776, 0.213541067331319, -1.43180326885801, -0.563743440651667, 3.91575777552026, -0.277663697958906, 0.0925194874597639, -1.59987627195682, 
    -0.772422299048776, -0.277663697958906, 24.3076366978829, 1.42889831677594, -3.05961733243781, 0.213541067331319, 0.0925194874597639, 1.42889831677594, 4.88222000496555, 0.832087488744832, -1.43180326885801, -1.59987627195682, -3.05961733243781, 0.832087488744832, 15.5345267050092)), est = c(meanlog1 = 1.90372731530473, meanlog2 = 3.9933343044265, pmix = 0.5, sdlog1 = 1.19942978424021, sdlog2 = 0.298688820136962), pars = list(meanlog1 = 1.90372731530473, meanlog2 = 3.9933343044265, pmix = 0.5, 
        log_sdlog1 = 0.18184626406043, log_sdlog2 = -1.20835298286039), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.401894528195339, log_scale = 3.74731745369501), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.0848299228971603, log_scale = 3.6113315359395), value = 22.8970770469694, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.28590117356708, -1.9014653883579, -1.9014653883579, 5.92448904106288)), est = c(scale = 37.0153072274199, shape = 1.08853191659923), pars = list(log_scale = 3.6113315359395, log_shape = 0.0848299228971603), flags = list(at_boundary = FALSE, computable = TRUE)))",lnorm_lnorm,0.05,1.44282,NA,NA,NA,1,0.95,cdf,percentile,parametric,0,1,lnorm_lnorm,numeric(0)
1,1,TRUE,5,Boron,Spirodella polyrrhiza,1.8,Plant,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.404342295956148, log_scale = 3.17973204379166), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.0105313667858157, log_scale = 3.57354290637599), value = 22.9201935827036, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.27159371108351, 5.05293550514965, 5.05293550514965, 5.05293626268208)), est = c(scale = 35.6426482848709, shape = 1.01058701681439), pars = list(log_scale = 3.57354290637599, log_shape = 0.0105313667858157), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01361143021043, log_scalelog = 0.656875636393804), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.28904105433868, log_scalelog = 0.376119114857425), value = 24.4358118482949, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.3565510495971, -1.72511552626965, -1.72511552626965, 10.6498933497436)), est = c(locationlog = 2.28904105433868, scalelog = 1.45662062859647), pars = list(locationlog = 2.28904105433868, log_scalelog = 0.376119114857425), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01361143021043, log_scalelog = 1.00344922667378), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.21159478248024, log_scalelog = -0.264677785737225), value = 23.720568054143, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.81342660491168, 0.663711081769443, 0.663711081769443, 7.16360678673574)), est = c(locationlog = 3.21159478248024, scalelog = 0.767453194506141), pars = list(locationlog = 3.21159478248024, log_scalelog = -0.264677785737225), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04374754451254, log_sdlog = 0.403945230306847), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01361049211189, log_sdlog = 0.296454505400714), value = 23.6450183645866, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.76358541928495, 5.18503263296939e-06, 5.18503263296939e-06, 9.9999907486879)), est = c(meanlog = 3.01361049211189, sdlog = 1.34508136466754), pars = list(meanlog = 3.01361049211189, log_sdlog = 0.296454505400714), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 1.60743589278879, log_sdlog1 = 0.346797650585182, meanlog2 = 4.00128864566171, log_sdlog2 = -0.955683746294042, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 1.90372731530473, log_sdlog1 = 0.18184626406043, meanlog2 = 3.9933343044265, log_sdlog2 = -1.20835298286039, pmix = 0.5), value = 21.8945918630597, counts = c(`function` = 12, gradient = 12), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.15749458501768, -0.563743440651667, -0.772422299048776, 0.213541067331319, -1.43180326885801, -0.563743440651667, 3.91575777552026, -0.277663697958906, 0.0925194874597639, -1.59987627195682, 
    -0.772422299048776, -0.277663697958906, 24.3076366978829, 1.42889831677594, -3.05961733243781, 0.213541067331319, 0.0925194874597639, 1.42889831677594, 4.88222000496555, 0.832087488744832, -1.43180326885801, -1.59987627195682, -3.05961733243781, 0.832087488744832, 15.5345267050092)), est = c(meanlog1 = 1.90372731530473, meanlog2 = 3.9933343044265, pmix = 0.5, sdlog1 = 1.19942978424021, sdlog2 = 0.298688820136962), pars = list(meanlog1 = 1.90372731530473, meanlog2 = 3.9933343044265, pmix = 0.5, 
        log_sdlog1 = 0.18184626406043, log_sdlog2 = -1.20835298286039), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.401894528195339, log_scale = 3.74731745369501), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.0848299228971603, log_scale = 3.6113315359395), value = 22.8970770469694, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.28590117356708, -1.9014653883579, -1.9014653883579, 5.92448904106288)), est = c(scale = 37.0153072274199, shape = 1.08853191659923), pars = list(log_scale = 3.6113315359395, log_shape = 0.0848299228971603), flags = list(at_boundary = FALSE, computable = TRUE)))",lnorm_lnorm,0.05,1.44282,NA,NA,NA,1,0.95,cdf,percentile,parametric,0,1,lnorm_lnorm,numeric(0)
1,1,TRUE,10,Boron,Ceriodaphnia dubia,13.4,Invertebrate,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.347793754217606, log_scale = 3.09262434059783), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.277430462233145, log_scale = 3.16298819283177), value = 44.1844051391579, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.3513547229456, 13.197344545515, 13.197344545515, 13.1973382514882)), est = c(scale = 23.6411347541813, shape = 1.31973434457373), pars = list(log_scale = 3.16298819283177, log_shape = 0.277430462233145), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.354906869806067), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), value = 46.6778177990908, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(6.97932406875603, -4.4109512522487, -4.4109512522487, 23.5210817167262)), est = c(locationlog = 2.45095092520366, scalelog = 1.19699830659697), pars = list(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.70148046008604), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), value = 44.8068237391937, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.70755613219043, 0.110062370784643, 0.110062370784643, 14.3477071950677)), est = c(locationlog = 3.08612119576206, scalelog = 0.585534345569591), pars = list(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04610984020903, log_sdlog = 0.104996151384988), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), value = 44.8826533078709, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.9874790685385, -9.13810438523545e-07, -9.13810438523545e-07, 20.0000177849704)), est = c(meanlog = 3.01595038767856, sdlog = 1.05482655382095), pars = list(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.24404647320555, log_sdlog1 = -0.0740119078270196, meanlog2 = 3.8481732072125, log_sdlog2 = -0.528291412471149, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.14758312942008, log_sdlog1 = 0.244519270285268, meanlog2 = 3.34961017263854, log_sdlog2 = -0.334200253537533, pmix = 0.3), value = 44.2079824669256, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.01596678568366, -0.417719976164404, 0.355566795496601, -0.0227070283941919, -3.71066812352201, -0.417719976164404, 4.08011017928992, 1.92759745001563, 0.209859003102214, 1.21595140513363, 
    0.355566795496601, 1.92759745001563, 11.2200049169097, 0.305380836107699, -3.54125431450658, -0.0227070283941919, 0.209859003102214, 0.305380836107699, 13.1099265769319, 0.473756761924852, -3.71066812352201, 1.21595140513363, -3.54125431450658, 0.473756761924852, 14.4223658096976)), est = c(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, sdlog1 = 1.27700727028162, sdlog2 = 0.715910404280703), pars = list(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, 
        log_sdlog1 = 0.244519270285268, log_sdlog2 = -0.334200253537533), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0403453011819949, log_scale = 3.56060029650164), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.18695514873387, log_scale = 3.50227796541358), value = 44.1529874803777, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.3139940408785, -4.9874260353886, -4.9874260353886, 14.5340712022155)), est = c(scale = 33.1909737983211, shape = 1.20557321235233), pars = list(log_scale = 3.50227796541358, log_shape = 0.18695514873387), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,3.17476,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,TRUE,10,Boron,Myriophyllum spicatum,34.2,Plant,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.347793754217606, log_scale = 3.09262434059783), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.277430462233145, log_scale = 3.16298819283177), value = 44.1844051391579, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.3513547229456, 13.197344545515, 13.197344545515, 13.1973382514882)), est = c(scale = 23.6411347541813, shape = 1.31973434457373), pars = list(log_scale = 3.16298819283177, log_shape = 0.277430462233145), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.354906869806067), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), value = 46.6778177990908, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(6.97932406875603, -4.4109512522487, -4.4109512522487, 23.5210817167262)), est = c(locationlog = 2.45095092520366, scalelog = 1.19699830659697), pars = list(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.70148046008604), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), value = 44.8068237391937, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.70755613219043, 0.110062370784643, 0.110062370784643, 14.3477071950677)), est = c(locationlog = 3.08612119576206, scalelog = 0.585534345569591), pars = list(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04610984020903, log_sdlog = 0.104996151384988), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), value = 44.8826533078709, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.9874790685385, -9.13810438523545e-07, -9.13810438523545e-07, 20.0000177849704)), est = c(meanlog = 3.01595038767856, sdlog = 1.05482655382095), pars = list(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.24404647320555, log_sdlog1 = -0.0740119078270196, meanlog2 = 3.8481732072125, log_sdlog2 = -0.528291412471149, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.14758312942008, log_sdlog1 = 0.244519270285268, meanlog2 = 3.34961017263854, log_sdlog2 = -0.334200253537533, pmix = 0.3), value = 44.2079824669256, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.01596678568366, -0.417719976164404, 0.355566795496601, -0.0227070283941919, -3.71066812352201, -0.417719976164404, 4.08011017928992, 1.92759745001563, 0.209859003102214, 1.21595140513363, 
    0.355566795496601, 1.92759745001563, 11.2200049169097, 0.305380836107699, -3.54125431450658, -0.0227070283941919, 0.209859003102214, 0.305380836107699, 13.1099265769319, 0.473756761924852, -3.71066812352201, 1.21595140513363, -3.54125431450658, 0.473756761924852, 14.4223658096976)), est = c(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, sdlog1 = 1.27700727028162, sdlog2 = 0.715910404280703), pars = list(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, 
        log_sdlog1 = 0.244519270285268, log_sdlog2 = -0.334200253537533), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0403453011819949, log_scale = 3.56060029650164), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.18695514873387, log_scale = 3.50227796541358), value = 44.1529874803777, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.3139940408785, -4.9874260353886, -4.9874260353886, 14.5340712022155)), est = c(scale = 33.1909737983211, shape = 1.20557321235233), pars = list(log_scale = 3.50227796541358, log_shape = 0.18695514873387), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,3.17476,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,TRUE,10,Boron,Rana sylvatica,70.7,Amphibian,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.347793754217606, log_scale = 3.09262434059783), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.277430462233145, log_scale = 3.16298819283177), value = 44.1844051391579, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.3513547229456, 13.197344545515, 13.197344545515, 13.1973382514882)), est = c(scale = 23.6411347541813, shape = 1.31973434457373), pars = list(log_scale = 3.16298819283177, log_shape = 0.277430462233145), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.354906869806067), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), value = 46.6778177990908, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(6.97932406875603, -4.4109512522487, -4.4109512522487, 23.5210817167262)), est = c(locationlog = 2.45095092520366, scalelog = 1.19699830659697), pars = list(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.70148046008604), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), value = 44.8068237391937, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.70755613219043, 0.110062370784643, 0.110062370784643, 14.3477071950677)), est = c(locationlog = 3.08612119576206, scalelog = 0.585534345569591), pars = list(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04610984020903, log_sdlog = 0.104996151384988), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), value = 44.8826533078709, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.9874790685385, -9.13810438523545e-07, -9.13810438523545e-07, 20.0000177849704)), est = c(meanlog = 3.01595038767856, sdlog = 1.05482655382095), pars = list(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.24404647320555, log_sdlog1 = -0.0740119078270196, meanlog2 = 3.8481732072125, log_sdlog2 = -0.528291412471149, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.14758312942008, log_sdlog1 = 0.244519270285268, meanlog2 = 3.34961017263854, log_sdlog2 = -0.334200253537533, pmix = 0.3), value = 44.2079824669256, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.01596678568366, -0.417719976164404, 0.355566795496601, -0.0227070283941919, -3.71066812352201, -0.417719976164404, 4.08011017928992, 1.92759745001563, 0.209859003102214, 1.21595140513363, 
    0.355566795496601, 1.92759745001563, 11.2200049169097, 0.305380836107699, -3.54125431450658, -0.0227070283941919, 0.209859003102214, 0.305380836107699, 13.1099265769319, 0.473756761924852, -3.71066812352201, 1.21595140513363, -3.54125431450658, 0.473756761924852, 14.4223658096976)), est = c(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, sdlog1 = 1.27700727028162, sdlog2 = 0.715910404280703), pars = list(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, 
        log_sdlog1 = 0.244519270285268, log_sdlog2 = -0.334200253537533), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0403453011819949, log_scale = 3.56060029650164), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.18695514873387, log_scale = 3.50227796541358), value = 44.1529874803777, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.3139940408785, -4.9874260353886, -4.9874260353886, 14.5340712022155)), est = c(scale = 33.1909737983211, shape = 1.20557321235233), pars = list(log_scale = 3.50227796541358, log_shape = 0.18695514873387), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,3.17476,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,TRUE,10,Boron,Lemna minor,60,Plant,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.347793754217606, log_scale = 3.09262434059783), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.277430462233145, log_scale = 3.16298819283177), value = 44.1844051391579, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.3513547229456, 13.197344545515, 13.197344545515, 13.1973382514882)), est = c(scale = 23.6411347541813, shape = 1.31973434457373), pars = list(log_scale = 3.16298819283177, log_shape = 0.277430462233145), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.354906869806067), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), value = 46.6778177990908, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(6.97932406875603, -4.4109512522487, -4.4109512522487, 23.5210817167262)), est = c(locationlog = 2.45095092520366, scalelog = 1.19699830659697), pars = list(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.70148046008604), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), value = 44.8068237391937, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.70755613219043, 0.110062370784643, 0.110062370784643, 14.3477071950677)), est = c(locationlog = 3.08612119576206, scalelog = 0.585534345569591), pars = list(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04610984020903, log_sdlog = 0.104996151384988), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), value = 44.8826533078709, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.9874790685385, -9.13810438523545e-07, -9.13810438523545e-07, 20.0000177849704)), est = c(meanlog = 3.01595038767856, sdlog = 1.05482655382095), pars = list(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.24404647320555, log_sdlog1 = -0.0740119078270196, meanlog2 = 3.8481732072125, log_sdlog2 = -0.528291412471149, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.14758312942008, log_sdlog1 = 0.244519270285268, meanlog2 = 3.34961017263854, log_sdlog2 = -0.334200253537533, pmix = 0.3), value = 44.2079824669256, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.01596678568366, -0.417719976164404, 0.355566795496601, -0.0227070283941919, -3.71066812352201, -0.417719976164404, 4.08011017928992, 1.92759745001563, 0.209859003102214, 1.21595140513363, 
    0.355566795496601, 1.92759745001563, 11.2200049169097, 0.305380836107699, -3.54125431450658, -0.0227070283941919, 0.209859003102214, 0.305380836107699, 13.1099265769319, 0.473756761924852, -3.71066812352201, 1.21595140513363, -3.54125431450658, 0.473756761924852, 14.4223658096976)), est = c(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, sdlog1 = 1.27700727028162, sdlog2 = 0.715910404280703), pars = list(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, 
        log_sdlog1 = 0.244519270285268, log_sdlog2 = -0.334200253537533), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0403453011819949, log_scale = 3.56060029650164), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.18695514873387, log_scale = 3.50227796541358), value = 44.1529874803777, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.3139940408785, -4.9874260353886, -4.9874260353886, 14.5340712022155)), est = c(scale = 33.1909737983211, shape = 1.20557321235233), pars = list(log_scale = 3.50227796541358, log_shape = 0.18695514873387), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,3.17476,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,TRUE,10,Boron,Spirodella polyrrhiza,1.8,Plant,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.347793754217606, log_scale = 3.09262434059783), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.277430462233145, log_scale = 3.16298819283177), value = 44.1844051391579, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.3513547229456, 13.197344545515, 13.197344545515, 13.1973382514882)), est = c(scale = 23.6411347541813, shape = 1.31973434457373), pars = list(log_scale = 3.16298819283177, log_shape = 0.277430462233145), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.354906869806067), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), value = 46.6778177990908, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(6.97932406875603, -4.4109512522487, -4.4109512522487, 23.5210817167262)), est = c(locationlog = 2.45095092520366, scalelog = 1.19699830659697), pars = list(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.70148046008604), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), value = 44.8068237391937, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.70755613219043, 0.110062370784643, 0.110062370784643, 14.3477071950677)), est = c(locationlog = 3.08612119576206, scalelog = 0.585534345569591), pars = list(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04610984020903, log_sdlog = 0.104996151384988), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), value = 44.8826533078709, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.9874790685385, -9.13810438523545e-07, -9.13810438523545e-07, 20.0000177849704)), est = c(meanlog = 3.01595038767856, sdlog = 1.05482655382095), pars = list(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.24404647320555, log_sdlog1 = -0.0740119078270196, meanlog2 = 3.8481732072125, log_sdlog2 = -0.528291412471149, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.14758312942008, log_sdlog1 = 0.244519270285268, meanlog2 = 3.34961017263854, log_sdlog2 = -0.334200253537533, pmix = 0.3), value = 44.2079824669256, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.01596678568366, -0.417719976164404, 0.355566795496601, -0.0227070283941919, -3.71066812352201, -0.417719976164404, 4.08011017928992, 1.92759745001563, 0.209859003102214, 1.21595140513363, 
    0.355566795496601, 1.92759745001563, 11.2200049169097, 0.305380836107699, -3.54125431450658, -0.0227070283941919, 0.209859003102214, 0.305380836107699, 13.1099265769319, 0.473756761924852, -3.71066812352201, 1.21595140513363, -3.54125431450658, 0.473756761924852, 14.4223658096976)), est = c(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, sdlog1 = 1.27700727028162, sdlog2 = 0.715910404280703), pars = list(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, 
        log_sdlog1 = 0.244519270285268, log_sdlog2 = -0.334200253537533), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0403453011819949, log_scale = 3.56060029650164), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.18695514873387, log_scale = 3.50227796541358), value = 44.1529874803777, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.3139940408785, -4.9874260353886, -4.9874260353886, 14.5340712022155)), est = c(scale = 33.1909737983211, shape = 1.20557321235233), pars = list(log_scale = 3.50227796541358, log_shape = 0.18695514873387), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,3.17476,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,TRUE,10,Boron,Pimephales promelas,18.3,Fish,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.347793754217606, log_scale = 3.09262434059783), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.277430462233145, log_scale = 3.16298819283177), value = 44.1844051391579, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.3513547229456, 13.197344545515, 13.197344545515, 13.1973382514882)), est = c(scale = 23.6411347541813, shape = 1.31973434457373), pars = list(log_scale = 3.16298819283177, log_shape = 0.277430462233145), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.354906869806067), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), value = 46.6778177990908, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(6.97932406875603, -4.4109512522487, -4.4109512522487, 23.5210817167262)), est = c(locationlog = 2.45095092520366, scalelog = 1.19699830659697), pars = list(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.70148046008604), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), value = 44.8068237391937, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.70755613219043, 0.110062370784643, 0.110062370784643, 14.3477071950677)), est = c(locationlog = 3.08612119576206, scalelog = 0.585534345569591), pars = list(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04610984020903, log_sdlog = 0.104996151384988), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), value = 44.8826533078709, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.9874790685385, -9.13810438523545e-07, -9.13810438523545e-07, 20.0000177849704)), est = c(meanlog = 3.01595038767856, sdlog = 1.05482655382095), pars = list(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.24404647320555, log_sdlog1 = -0.0740119078270196, meanlog2 = 3.8481732072125, log_sdlog2 = -0.528291412471149, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.14758312942008, log_sdlog1 = 0.244519270285268, meanlog2 = 3.34961017263854, log_sdlog2 = -0.334200253537533, pmix = 0.3), value = 44.2079824669256, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.01596678568366, -0.417719976164404, 0.355566795496601, -0.0227070283941919, -3.71066812352201, -0.417719976164404, 4.08011017928992, 1.92759745001563, 0.209859003102214, 1.21595140513363, 
    0.355566795496601, 1.92759745001563, 11.2200049169097, 0.305380836107699, -3.54125431450658, -0.0227070283941919, 0.209859003102214, 0.305380836107699, 13.1099265769319, 0.473756761924852, -3.71066812352201, 1.21595140513363, -3.54125431450658, 0.473756761924852, 14.4223658096976)), est = c(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, sdlog1 = 1.27700727028162, sdlog2 = 0.715910404280703), pars = list(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, 
        log_sdlog1 = 0.244519270285268, log_sdlog2 = -0.334200253537533), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0403453011819949, log_scale = 3.56060029650164), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.18695514873387, log_scale = 3.50227796541358), value = 44.1529874803777, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.3139940408785, -4.9874260353886, -4.9874260353886, 14.5340712022155)), est = c(scale = 33.1909737983211, shape = 1.20557321235233), pars = list(log_scale = 3.50227796541358, log_shape = 0.18695514873387), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,3.17476,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,TRUE,10,Boron,Selenastrum capricornutum,12.3,Plant,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.347793754217606, log_scale = 3.09262434059783), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.277430462233145, log_scale = 3.16298819283177), value = 44.1844051391579, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.3513547229456, 13.197344545515, 13.197344545515, 13.1973382514882)), est = c(scale = 23.6411347541813, shape = 1.31973434457373), pars = list(log_scale = 3.16298819283177, log_shape = 0.277430462233145), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.354906869806067), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), value = 46.6778177990908, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(6.97932406875603, -4.4109512522487, -4.4109512522487, 23.5210817167262)), est = c(locationlog = 2.45095092520366, scalelog = 1.19699830659697), pars = list(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.70148046008604), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), value = 44.8068237391937, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.70755613219043, 0.110062370784643, 0.110062370784643, 14.3477071950677)), est = c(locationlog = 3.08612119576206, scalelog = 0.585534345569591), pars = list(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04610984020903, log_sdlog = 0.104996151384988), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), value = 44.8826533078709, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.9874790685385, -9.13810438523545e-07, -9.13810438523545e-07, 20.0000177849704)), est = c(meanlog = 3.01595038767856, sdlog = 1.05482655382095), pars = list(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.24404647320555, log_sdlog1 = -0.0740119078270196, meanlog2 = 3.8481732072125, log_sdlog2 = -0.528291412471149, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.14758312942008, log_sdlog1 = 0.244519270285268, meanlog2 = 3.34961017263854, log_sdlog2 = -0.334200253537533, pmix = 0.3), value = 44.2079824669256, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.01596678568366, -0.417719976164404, 0.355566795496601, -0.0227070283941919, -3.71066812352201, -0.417719976164404, 4.08011017928992, 1.92759745001563, 0.209859003102214, 1.21595140513363, 
    0.355566795496601, 1.92759745001563, 11.2200049169097, 0.305380836107699, -3.54125431450658, -0.0227070283941919, 0.209859003102214, 0.305380836107699, 13.1099265769319, 0.473756761924852, -3.71066812352201, 1.21595140513363, -3.54125431450658, 0.473756761924852, 14.4223658096976)), est = c(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, sdlog1 = 1.27700727028162, sdlog2 = 0.715910404280703), pars = list(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, 
        log_sdlog1 = 0.244519270285268, log_sdlog2 = -0.334200253537533), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0403453011819949, log_scale = 3.56060029650164), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.18695514873387, log_scale = 3.50227796541358), value = 44.1529874803777, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.3139940408785, -4.9874260353886, -4.9874260353886, 14.5340712022155)), est = c(scale = 33.1909737983211, shape = 1.20557321235233), pars = list(log_scale = 3.50227796541358, log_shape = 0.18695514873387), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,3.17476,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,TRUE,10,Boron,Selenastrum capricornutum,12.3,Plant,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.347793754217606, log_scale = 3.09262434059783), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.277430462233145, log_scale = 3.16298819283177), value = 44.1844051391579, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.3513547229456, 13.197344545515, 13.197344545515, 13.1973382514882)), est = c(scale = 23.6411347541813, shape = 1.31973434457373), pars = list(log_scale = 3.16298819283177, log_shape = 0.277430462233145), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.354906869806067), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), value = 46.6778177990908, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(6.97932406875603, -4.4109512522487, -4.4109512522487, 23.5210817167262)), est = c(locationlog = 2.45095092520366, scalelog = 1.19699830659697), pars = list(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.70148046008604), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), value = 44.8068237391937, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.70755613219043, 0.110062370784643, 0.110062370784643, 14.3477071950677)), est = c(locationlog = 3.08612119576206, scalelog = 0.585534345569591), pars = list(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04610984020903, log_sdlog = 0.104996151384988), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), value = 44.8826533078709, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.9874790685385, -9.13810438523545e-07, -9.13810438523545e-07, 20.0000177849704)), est = c(meanlog = 3.01595038767856, sdlog = 1.05482655382095), pars = list(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.24404647320555, log_sdlog1 = -0.0740119078270196, meanlog2 = 3.8481732072125, log_sdlog2 = -0.528291412471149, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.14758312942008, log_sdlog1 = 0.244519270285268, meanlog2 = 3.34961017263854, log_sdlog2 = -0.334200253537533, pmix = 0.3), value = 44.2079824669256, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.01596678568366, -0.417719976164404, 0.355566795496601, -0.0227070283941919, -3.71066812352201, -0.417719976164404, 4.08011017928992, 1.92759745001563, 0.209859003102214, 1.21595140513363, 
    0.355566795496601, 1.92759745001563, 11.2200049169097, 0.305380836107699, -3.54125431450658, -0.0227070283941919, 0.209859003102214, 0.305380836107699, 13.1099265769319, 0.473756761924852, -3.71066812352201, 1.21595140513363, -3.54125431450658, 0.473756761924852, 14.4223658096976)), est = c(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, sdlog1 = 1.27700727028162, sdlog2 = 0.715910404280703), pars = list(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, 
        log_sdlog1 = 0.244519270285268, log_sdlog2 = -0.334200253537533), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0403453011819949, log_scale = 3.56060029650164), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.18695514873387, log_scale = 3.50227796541358), value = 44.1529874803777, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.3139940408785, -4.9874260353886, -4.9874260353886, 14.5340712022155)), est = c(scale = 33.1909737983211, shape = 1.20557321235233), pars = list(log_scale = 3.50227796541358, log_shape = 0.18695514873387), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,3.17476,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,TRUE,10,Boron,Rana sylvatica,70.7,Amphibian,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.347793754217606, log_scale = 3.09262434059783), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.277430462233145, log_scale = 3.16298819283177), value = 44.1844051391579, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.3513547229456, 13.197344545515, 13.197344545515, 13.1973382514882)), est = c(scale = 23.6411347541813, shape = 1.31973434457373), pars = list(log_scale = 3.16298819283177, log_shape = 0.277430462233145), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.354906869806067), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), value = 46.6778177990908, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(6.97932406875603, -4.4109512522487, -4.4109512522487, 23.5210817167262)), est = c(locationlog = 2.45095092520366, scalelog = 1.19699830659697), pars = list(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.70148046008604), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), value = 44.8068237391937, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.70755613219043, 0.110062370784643, 0.110062370784643, 14.3477071950677)), est = c(locationlog = 3.08612119576206, scalelog = 0.585534345569591), pars = list(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04610984020903, log_sdlog = 0.104996151384988), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), value = 44.8826533078709, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.9874790685385, -9.13810438523545e-07, -9.13810438523545e-07, 20.0000177849704)), est = c(meanlog = 3.01595038767856, sdlog = 1.05482655382095), pars = list(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.24404647320555, log_sdlog1 = -0.0740119078270196, meanlog2 = 3.8481732072125, log_sdlog2 = -0.528291412471149, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.14758312942008, log_sdlog1 = 0.244519270285268, meanlog2 = 3.34961017263854, log_sdlog2 = -0.334200253537533, pmix = 0.3), value = 44.2079824669256, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.01596678568366, -0.417719976164404, 0.355566795496601, -0.0227070283941919, -3.71066812352201, -0.417719976164404, 4.08011017928992, 1.92759745001563, 0.209859003102214, 1.21595140513363, 
    0.355566795496601, 1.92759745001563, 11.2200049169097, 0.305380836107699, -3.54125431450658, -0.0227070283941919, 0.209859003102214, 0.305380836107699, 13.1099265769319, 0.473756761924852, -3.71066812352201, 1.21595140513363, -3.54125431450658, 0.473756761924852, 14.4223658096976)), est = c(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, sdlog1 = 1.27700727028162, sdlog2 = 0.715910404280703), pars = list(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, 
        log_sdlog1 = 0.244519270285268, log_sdlog2 = -0.334200253537533), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0403453011819949, log_scale = 3.56060029650164), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.18695514873387, log_scale = 3.50227796541358), value = 44.1529874803777, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.3139940408785, -4.9874260353886, -4.9874260353886, 14.5340712022155)), est = c(scale = 33.1909737983211, shape = 1.20557321235233), pars = list(log_scale = 3.50227796541358, log_shape = 0.18695514873387), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,3.17476,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,TRUE,10,Boron,Pimephales promelas,18.3,Fish,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.347793754217606, log_scale = 3.09262434059783), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.277430462233145, log_scale = 3.16298819283177), value = 44.1844051391579, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.3513547229456, 13.197344545515, 13.197344545515, 13.1973382514882)), est = c(scale = 23.6411347541813, shape = 1.31973434457373), pars = list(log_scale = 3.16298819283177, log_shape = 0.277430462233145), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.354906869806067), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), value = 46.6778177990908, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(6.97932406875603, -4.4109512522487, -4.4109512522487, 23.5210817167262)), est = c(locationlog = 2.45095092520366, scalelog = 1.19699830659697), pars = list(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.70148046008604), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), value = 44.8068237391937, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.70755613219043, 0.110062370784643, 0.110062370784643, 14.3477071950677)), est = c(locationlog = 3.08612119576206, scalelog = 0.585534345569591), pars = list(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04610984020903, log_sdlog = 0.104996151384988), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), value = 44.8826533078709, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.9874790685385, -9.13810438523545e-07, -9.13810438523545e-07, 20.0000177849704)), est = c(meanlog = 3.01595038767856, sdlog = 1.05482655382095), pars = list(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.24404647320555, log_sdlog1 = -0.0740119078270196, meanlog2 = 3.8481732072125, log_sdlog2 = -0.528291412471149, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.14758312942008, log_sdlog1 = 0.244519270285268, meanlog2 = 3.34961017263854, log_sdlog2 = -0.334200253537533, pmix = 0.3), value = 44.2079824669256, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.01596678568366, -0.417719976164404, 0.355566795496601, -0.0227070283941919, -3.71066812352201, -0.417719976164404, 4.08011017928992, 1.92759745001563, 0.209859003102214, 1.21595140513363, 
    0.355566795496601, 1.92759745001563, 11.2200049169097, 0.305380836107699, -3.54125431450658, -0.0227070283941919, 0.209859003102214, 0.305380836107699, 13.1099265769319, 0.473756761924852, -3.71066812352201, 1.21595140513363, -3.54125431450658, 0.473756761924852, 14.4223658096976)), est = c(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, sdlog1 = 1.27700727028162, sdlog2 = 0.715910404280703), pars = list(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, 
        log_sdlog1 = 0.244519270285268, log_sdlog2 = -0.334200253537533), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0403453011819949, log_scale = 3.56060029650164), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.18695514873387, log_scale = 3.50227796541358), value = 44.1529874803777, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.3139940408785, -4.9874260353886, -4.9874260353886, 14.5340712022155)), est = c(scale = 33.1909737983211, shape = 1.20557321235233), pars = list(log_scale = 3.50227796541358, log_shape = 0.18695514873387), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,3.17476,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,FALSE,5,Boron,Ceriodaphnia dubia,13.4,Invertebrate,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.0709197252160534, log_scale = 3.24979040553342), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.0521592425383351, log_scale = 3.26855155991363), value = 21.5992656601237, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.46296482004847, 5.26771792946124, 5.26771792946124, 5.26771483009887)), est = c(scale = 26.2732565316286, shape = 1.05354349809698), pars = list(log_scale = 3.26855155991363, log_shape = 0.0521592425383351), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.77612272973549, log_scalelog = 0.57027707940964), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.1200530284664, log_scalelog = 0.270384762353549), value = 22.7357199201822, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.91149729564533, -1.90528186703927, -1.90528186703927, 10.6069930822592)), est = c(locationlog = 2.1200530284664, scalelog = 1.31046857271574), pars = list(locationlog = 2.1200530284664, log_scalelog = 0.270384762353549), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.77612272973549, log_scalelog = 0.916850669689613), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.91423190972086, log_scalelog = -0.358099591288578), value = 22.0845690371308, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(3.4341246748476, 0.499769430597881, 0.499769430597881, 6.98558232421298)), est = c(locationlog = 2.91423190972086, scalelog = 0.699003456884912), pars = list(locationlog = 2.91423190972086, log_scalelog = -0.358099591288578), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.80388395703284, log_sdlog = 0.318212658892525), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.77612369904032, log_sdlog = 0.209854445232504), value = 22.0245820772907, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(3.2861906012625, -6.37064291894443e-06, -6.37064291894443e-06, 10.0000208123868)), est = c(meanlog = 2.77612369904032, sdlog = 1.2334985053014), pars = list(meanlog = 2.77612369904032, log_sdlog = 0.209854445232504), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 1.60743589278879, log_sdlog1 = 0.346797650585182, meanlog2 = 3.60151599986222, log_sdlog2 = -0.38706149063331, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 1.99034570838894, log_sdlog1 = 0.286683257635471, meanlog2 = 3.42087489998547, log_sdlog2 = -0.468459653346944, pmix = 0.5), value = 21.4511625063483, counts = c(`function` = 12, gradient = 12), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(0.788287469394661, -0.324135693935862, 0.165005130909078, 0.0594500270465814, -2.20979842699074, -0.324135693935862, 3.66513096540675, 1.26819419195667, 0.0914235746740809, -0.218632324075823, 
    0.165005130909078, 1.26819419195667, 4.72779943553958, 0.0727084770916568, -1.68100125418813, 0.0594500270465814, 0.0914235746740809, 0.0727084770916568, 5.0296202426585, 0.374586123416823, -2.20979842699074, -0.218632324075823, -1.68100125418813, 0.374586123416823, 7.1953556775653)), est = c(meanlog1 = 1.99034570838894, meanlog2 = 3.42087489998547, pmix = 0.5, sdlog1 = 1.3320022451109, sdlog2 = 0.625965730277033), pars = list(meanlog1 = 1.99034570838894, meanlog2 = 3.42087489998547, pmix = 0.5, 
        log_sdlog1 = 0.286683257635471, log_sdlog2 = -0.468459653346944), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.303299271682075, log_scale = 3.44094063661029), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.0577489899484726, log_scale = 3.34232414948968), value = 21.5911767141402, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.41414873904661, -2.11963745345901, -2.11963745345901, 5.6121626115933)), est = c(scale = 28.2847884486368, shape = 1.05944902997604), pars = list(log_scale = 3.34232414948968, log_shape = 0.0577489899484726), flags = list(at_boundary = FALSE, computable = TRUE)))",lnorm_lnorm,0.05,1.32752,NA,NA,NA,1,0.95,cdf,percentile,parametric,0,1,lnorm_lnorm,numeric(0)
1,1,FALSE,5,Boron,Myriophyllum spicatum,34.2,Plant,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.0709197252160534, log_scale = 3.24979040553342), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.0521592425383351, log_scale = 3.26855155991363), value = 21.5992656601237, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.46296482004847, 5.26771792946124, 5.26771792946124, 5.26771483009887)), est = c(scale = 26.2732565316286, shape = 1.05354349809698), pars = list(log_scale = 3.26855155991363, log_shape = 0.0521592425383351), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.77612272973549, log_scalelog = 0.57027707940964), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.1200530284664, log_scalelog = 0.270384762353549), value = 22.7357199201822, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.91149729564533, -1.90528186703927, -1.90528186703927, 10.6069930822592)), est = c(locationlog = 2.1200530284664, scalelog = 1.31046857271574), pars = list(locationlog = 2.1200530284664, log_scalelog = 0.270384762353549), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.77612272973549, log_scalelog = 0.916850669689613), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.91423190972086, log_scalelog = -0.358099591288578), value = 22.0845690371308, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(3.4341246748476, 0.499769430597881, 0.499769430597881, 6.98558232421298)), est = c(locationlog = 2.91423190972086, scalelog = 0.699003456884912), pars = list(locationlog = 2.91423190972086, log_scalelog = -0.358099591288578), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.80388395703284, log_sdlog = 0.318212658892525), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.77612369904032, log_sdlog = 0.209854445232504), value = 22.0245820772907, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(3.2861906012625, -6.37064291894443e-06, -6.37064291894443e-06, 10.0000208123868)), est = c(meanlog = 2.77612369904032, sdlog = 1.2334985053014), pars = list(meanlog = 2.77612369904032, log_sdlog = 0.209854445232504), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 1.60743589278879, log_sdlog1 = 0.346797650585182, meanlog2 = 3.60151599986222, log_sdlog2 = -0.38706149063331, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 1.99034570838894, log_sdlog1 = 0.286683257635471, meanlog2 = 3.42087489998547, log_sdlog2 = -0.468459653346944, pmix = 0.5), value = 21.4511625063483, counts = c(`function` = 12, gradient = 12), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(0.788287469394661, -0.324135693935862, 0.165005130909078, 0.0594500270465814, -2.20979842699074, -0.324135693935862, 3.66513096540675, 1.26819419195667, 0.0914235746740809, -0.218632324075823, 
    0.165005130909078, 1.26819419195667, 4.72779943553958, 0.0727084770916568, -1.68100125418813, 0.0594500270465814, 0.0914235746740809, 0.0727084770916568, 5.0296202426585, 0.374586123416823, -2.20979842699074, -0.218632324075823, -1.68100125418813, 0.374586123416823, 7.1953556775653)), est = c(meanlog1 = 1.99034570838894, meanlog2 = 3.42087489998547, pmix = 0.5, sdlog1 = 1.3320022451109, sdlog2 = 0.625965730277033), pars = list(meanlog1 = 1.99034570838894, meanlog2 = 3.42087489998547, pmix = 0.5, 
        log_sdlog1 = 0.286683257635471, log_sdlog2 = -0.468459653346944), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.303299271682075, log_scale = 3.44094063661029), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.0577489899484726, log_scale = 3.34232414948968), value = 21.5911767141402, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.41414873904661, -2.11963745345901, -2.11963745345901, 5.6121626115933)), est = c(scale = 28.2847884486368, shape = 1.05944902997604), pars = list(log_scale = 3.34232414948968, log_shape = 0.0577489899484726), flags = list(at_boundary = FALSE, computable = TRUE)))",lnorm_lnorm,0.05,1.32752,NA,NA,NA,1,0.95,cdf,percentile,parametric,0,1,lnorm_lnorm,numeric(0)
1,1,FALSE,5,Boron,Rana sylvatica,70.7,Amphibian,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.0709197252160534, log_scale = 3.24979040553342), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.0521592425383351, log_scale = 3.26855155991363), value = 21.5992656601237, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.46296482004847, 5.26771792946124, 5.26771792946124, 5.26771483009887)), est = c(scale = 26.2732565316286, shape = 1.05354349809698), pars = list(log_scale = 3.26855155991363, log_shape = 0.0521592425383351), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.77612272973549, log_scalelog = 0.57027707940964), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.1200530284664, log_scalelog = 0.270384762353549), value = 22.7357199201822, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.91149729564533, -1.90528186703927, -1.90528186703927, 10.6069930822592)), est = c(locationlog = 2.1200530284664, scalelog = 1.31046857271574), pars = list(locationlog = 2.1200530284664, log_scalelog = 0.270384762353549), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.77612272973549, log_scalelog = 0.916850669689613), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.91423190972086, log_scalelog = -0.358099591288578), value = 22.0845690371308, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(3.4341246748476, 0.499769430597881, 0.499769430597881, 6.98558232421298)), est = c(locationlog = 2.91423190972086, scalelog = 0.699003456884912), pars = list(locationlog = 2.91423190972086, log_scalelog = -0.358099591288578), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.80388395703284, log_sdlog = 0.318212658892525), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.77612369904032, log_sdlog = 0.209854445232504), value = 22.0245820772907, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(3.2861906012625, -6.37064291894443e-06, -6.37064291894443e-06, 10.0000208123868)), est = c(meanlog = 2.77612369904032, sdlog = 1.2334985053014), pars = list(meanlog = 2.77612369904032, log_sdlog = 0.209854445232504), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 1.60743589278879, log_sdlog1 = 0.346797650585182, meanlog2 = 3.60151599986222, log_sdlog2 = -0.38706149063331, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 1.99034570838894, log_sdlog1 = 0.286683257635471, meanlog2 = 3.42087489998547, log_sdlog2 = -0.468459653346944, pmix = 0.5), value = 21.4511625063483, counts = c(`function` = 12, gradient = 12), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(0.788287469394661, -0.324135693935862, 0.165005130909078, 0.0594500270465814, -2.20979842699074, -0.324135693935862, 3.66513096540675, 1.26819419195667, 0.0914235746740809, -0.218632324075823, 
    0.165005130909078, 1.26819419195667, 4.72779943553958, 0.0727084770916568, -1.68100125418813, 0.0594500270465814, 0.0914235746740809, 0.0727084770916568, 5.0296202426585, 0.374586123416823, -2.20979842699074, -0.218632324075823, -1.68100125418813, 0.374586123416823, 7.1953556775653)), est = c(meanlog1 = 1.99034570838894, meanlog2 = 3.42087489998547, pmix = 0.5, sdlog1 = 1.3320022451109, sdlog2 = 0.625965730277033), pars = list(meanlog1 = 1.99034570838894, meanlog2 = 3.42087489998547, pmix = 0.5, 
        log_sdlog1 = 0.286683257635471, log_sdlog2 = -0.468459653346944), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.303299271682075, log_scale = 3.44094063661029), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.0577489899484726, log_scale = 3.34232414948968), value = 21.5911767141402, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.41414873904661, -2.11963745345901, -2.11963745345901, 5.6121626115933)), est = c(scale = 28.2847884486368, shape = 1.05944902997604), pars = list(log_scale = 3.34232414948968, log_shape = 0.0577489899484726), flags = list(at_boundary = FALSE, computable = TRUE)))",lnorm_lnorm,0.05,1.32752,NA,NA,NA,1,0.95,cdf,percentile,parametric,0,1,lnorm_lnorm,numeric(0)
1,1,FALSE,5,Boron,Spirodella polyrrhiza,1.8,Plant,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.0709197252160534, log_scale = 3.24979040553342), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.0521592425383351, log_scale = 3.26855155991363), value = 21.5992656601237, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.46296482004847, 5.26771792946124, 5.26771792946124, 5.26771483009887)), est = c(scale = 26.2732565316286, shape = 1.05354349809698), pars = list(log_scale = 3.26855155991363, log_shape = 0.0521592425383351), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.77612272973549, log_scalelog = 0.57027707940964), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.1200530284664, log_scalelog = 0.270384762353549), value = 22.7357199201822, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.91149729564533, -1.90528186703927, -1.90528186703927, 10.6069930822592)), est = c(locationlog = 2.1200530284664, scalelog = 1.31046857271574), pars = list(locationlog = 2.1200530284664, log_scalelog = 0.270384762353549), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.77612272973549, log_scalelog = 0.916850669689613), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.91423190972086, log_scalelog = -0.358099591288578), value = 22.0845690371308, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(3.4341246748476, 0.499769430597881, 0.499769430597881, 6.98558232421298)), est = c(locationlog = 2.91423190972086, scalelog = 0.699003456884912), pars = list(locationlog = 2.91423190972086, log_scalelog = -0.358099591288578), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.80388395703284, log_sdlog = 0.318212658892525), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.77612369904032, log_sdlog = 0.209854445232504), value = 22.0245820772907, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(3.2861906012625, -6.37064291894443e-06, -6.37064291894443e-06, 10.0000208123868)), est = c(meanlog = 2.77612369904032, sdlog = 1.2334985053014), pars = list(meanlog = 2.77612369904032, log_sdlog = 0.209854445232504), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 1.60743589278879, log_sdlog1 = 0.346797650585182, meanlog2 = 3.60151599986222, log_sdlog2 = -0.38706149063331, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 1.99034570838894, log_sdlog1 = 0.286683257635471, meanlog2 = 3.42087489998547, log_sdlog2 = -0.468459653346944, pmix = 0.5), value = 21.4511625063483, counts = c(`function` = 12, gradient = 12), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(0.788287469394661, -0.324135693935862, 0.165005130909078, 0.0594500270465814, -2.20979842699074, -0.324135693935862, 3.66513096540675, 1.26819419195667, 0.0914235746740809, -0.218632324075823, 
    0.165005130909078, 1.26819419195667, 4.72779943553958, 0.0727084770916568, -1.68100125418813, 0.0594500270465814, 0.0914235746740809, 0.0727084770916568, 5.0296202426585, 0.374586123416823, -2.20979842699074, -0.218632324075823, -1.68100125418813, 0.374586123416823, 7.1953556775653)), est = c(meanlog1 = 1.99034570838894, meanlog2 = 3.42087489998547, pmix = 0.5, sdlog1 = 1.3320022451109, sdlog2 = 0.625965730277033), pars = list(meanlog1 = 1.99034570838894, meanlog2 = 3.42087489998547, pmix = 0.5, 
        log_sdlog1 = 0.286683257635471, log_sdlog2 = -0.468459653346944), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.303299271682075, log_scale = 3.44094063661029), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.0577489899484726, log_scale = 3.34232414948968), value = 21.5911767141402, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.41414873904661, -2.11963745345901, -2.11963745345901, 5.6121626115933)), est = c(scale = 28.2847884486368, shape = 1.05944902997604), pars = list(log_scale = 3.34232414948968, log_shape = 0.0577489899484726), flags = list(at_boundary = FALSE, computable = TRUE)))",lnorm_lnorm,0.05,1.32752,NA,NA,NA,1,0.95,cdf,percentile,parametric,0,1,lnorm_lnorm,numeric(0)
1,1,FALSE,5,Boron,Pimephales promelas,18.3,Fish,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.0709197252160534, log_scale = 3.24979040553342), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.0521592425383351, log_scale = 3.26855155991363), value = 21.5992656601237, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.46296482004847, 5.26771792946124, 5.26771792946124, 5.26771483009887)), est = c(scale = 26.2732565316286, shape = 1.05354349809698), pars = list(log_scale = 3.26855155991363, log_shape = 0.0521592425383351), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.77612272973549, log_scalelog = 0.57027707940964), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.1200530284664, log_scalelog = 0.270384762353549), value = 22.7357199201822, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.91149729564533, -1.90528186703927, -1.90528186703927, 10.6069930822592)), est = c(locationlog = 2.1200530284664, scalelog = 1.31046857271574), pars = list(locationlog = 2.1200530284664, log_scalelog = 0.270384762353549), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.77612272973549, log_scalelog = 0.916850669689613), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.91423190972086, log_scalelog = -0.358099591288578), value = 22.0845690371308, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(3.4341246748476, 0.499769430597881, 0.499769430597881, 6.98558232421298)), est = c(locationlog = 2.91423190972086, scalelog = 0.699003456884912), pars = list(locationlog = 2.91423190972086, log_scalelog = -0.358099591288578), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.80388395703284, log_sdlog = 0.318212658892525), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.77612369904032, log_sdlog = 0.209854445232504), value = 22.0245820772907, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(3.2861906012625, -6.37064291894443e-06, -6.37064291894443e-06, 10.0000208123868)), est = c(meanlog = 2.77612369904032, sdlog = 1.2334985053014), pars = list(meanlog = 2.77612369904032, log_sdlog = 0.209854445232504), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 1.60743589278879, log_sdlog1 = 0.346797650585182, meanlog2 = 3.60151599986222, log_sdlog2 = -0.38706149063331, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 1.99034570838894, log_sdlog1 = 0.286683257635471, meanlog2 = 3.42087489998547, log_sdlog2 = -0.468459653346944, pmix = 0.5), value = 21.4511625063483, counts = c(`function` = 12, gradient = 12), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(0.788287469394661, -0.324135693935862, 0.165005130909078, 0.0594500270465814, -2.20979842699074, -0.324135693935862, 3.66513096540675, 1.26819419195667, 0.0914235746740809, -0.218632324075823, 
    0.165005130909078, 1.26819419195667, 4.72779943553958, 0.0727084770916568, -1.68100125418813, 0.0594500270465814, 0.0914235746740809, 0.0727084770916568, 5.0296202426585, 0.374586123416823, -2.20979842699074, -0.218632324075823, -1.68100125418813, 0.374586123416823, 7.1953556775653)), est = c(meanlog1 = 1.99034570838894, meanlog2 = 3.42087489998547, pmix = 0.5, sdlog1 = 1.3320022451109, sdlog2 = 0.625965730277033), pars = list(meanlog1 = 1.99034570838894, meanlog2 = 3.42087489998547, pmix = 0.5, 
        log_sdlog1 = 0.286683257635471, log_sdlog2 = -0.468459653346944), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.303299271682075, log_scale = 3.44094063661029), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.0577489899484726, log_scale = 3.34232414948968), value = 21.5911767141402, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.41414873904661, -2.11963745345901, -2.11963745345901, 5.6121626115933)), est = c(scale = 28.2847884486368, shape = 1.05944902997604), pars = list(log_scale = 3.34232414948968, log_shape = 0.0577489899484726), flags = list(at_boundary = FALSE, computable = TRUE)))",lnorm_lnorm,0.05,1.32752,NA,NA,NA,1,0.95,cdf,percentile,parametric,0,1,lnorm_lnorm,numeric(0)
1,1,FALSE,10,Boron,Ceriodaphnia dubia,13.4,Invertebrate,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.296961095837491, log_scale = 3.0921637045904), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.261440996953924, log_scale = 3.12768679876144), value = 43.6947412117056, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.1578440455155, 12.9880041437013, 12.9880041437013, 12.9879663232819)), est = c(scale = 22.8211285756601, shape = 1.29880030613677), pars = list(log_scale = 3.12768679876144, log_shape = 0.261440996953924), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.352240607534656), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), value = 45.9330602035977, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.2733281997642, -4.46045016373558, -4.46045016373558, 23.2160273096977)), est = c(locationlog = 2.39783588813966, scalelog = 1.17255556905755), pars = list(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.698814197814629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), value = 44.256651435281, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.48684532860544, 0.0875077924964762, 0.0875077924964762, 14.4456093113738)), est = c(locationlog = 3.01880130017102, scalelog = 0.590352831830035), pars = list(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.98670299513176, log_sdlog = 0.10235655173629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), value = 44.2678041002333, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.03553302961929, -8.90233683405559e-07, -8.90233683405559e-07, 20.0000177800354)), est = c(meanlog = 2.95713172761119, sdlog = 1.05201785573431), pars = list(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.16206173752339, log_sdlog1 = -0.125798239499222, meanlog2 = 3.81134425274013, log_sdlog2 = -0.556825392185898, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.10056111509066, log_sdlog1 = 0.205450849919085, meanlog2 = 3.29666779842978, log_sdlog2 = -0.306715469257007, pmix = 0.3), value = 43.7405806968797, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.10806901294958, -0.534157452938338, 0.372742203584499, -0.0953397439732499, -3.845106624433, -0.534157452938338, 3.96201126055292, 1.99526595742094, 0.201699249151078, 1.09304102786659, 
    0.372742203584499, 1.99526595742094, 10.3372574319162, 0.633396133716582, -3.98711529205142, -0.0953397439732499, 0.201699249151078, 0.633396133716582, 12.388720589456, 0.792657683189083, -3.845106624433, 1.09304102786659, -3.98711529205142, 0.792657683189083, 14.4747599477348)), est = c(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, sdlog1 = 1.22807861931498, sdlog2 = 0.735859945900444), pars = list(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, 
        log_sdlog1 = 0.205450849919085, log_sdlog2 = -0.306715469257007), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0261006526172895, log_scale = 3.49407828676558), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.169571830144152, log_scale = 3.44710520115741), value = 43.6807922745908, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.5449756612725, -4.97000758937715, -4.97000758937715, 14.0374532123274)), est = c(scale = 31.4093368667314, shape = 1.18479744814816), pars = list(log_scale = 3.44710520115741, log_shape = 0.169571830144152), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,2.95574,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,FALSE,10,Boron,Myriophyllum spicatum,34.2,Plant,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.296961095837491, log_scale = 3.0921637045904), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.261440996953924, log_scale = 3.12768679876144), value = 43.6947412117056, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.1578440455155, 12.9880041437013, 12.9880041437013, 12.9879663232819)), est = c(scale = 22.8211285756601, shape = 1.29880030613677), pars = list(log_scale = 3.12768679876144, log_shape = 0.261440996953924), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.352240607534656), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), value = 45.9330602035977, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.2733281997642, -4.46045016373558, -4.46045016373558, 23.2160273096977)), est = c(locationlog = 2.39783588813966, scalelog = 1.17255556905755), pars = list(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.698814197814629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), value = 44.256651435281, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.48684532860544, 0.0875077924964762, 0.0875077924964762, 14.4456093113738)), est = c(locationlog = 3.01880130017102, scalelog = 0.590352831830035), pars = list(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.98670299513176, log_sdlog = 0.10235655173629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), value = 44.2678041002333, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.03553302961929, -8.90233683405559e-07, -8.90233683405559e-07, 20.0000177800354)), est = c(meanlog = 2.95713172761119, sdlog = 1.05201785573431), pars = list(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.16206173752339, log_sdlog1 = -0.125798239499222, meanlog2 = 3.81134425274013, log_sdlog2 = -0.556825392185898, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.10056111509066, log_sdlog1 = 0.205450849919085, meanlog2 = 3.29666779842978, log_sdlog2 = -0.306715469257007, pmix = 0.3), value = 43.7405806968797, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.10806901294958, -0.534157452938338, 0.372742203584499, -0.0953397439732499, -3.845106624433, -0.534157452938338, 3.96201126055292, 1.99526595742094, 0.201699249151078, 1.09304102786659, 
    0.372742203584499, 1.99526595742094, 10.3372574319162, 0.633396133716582, -3.98711529205142, -0.0953397439732499, 0.201699249151078, 0.633396133716582, 12.388720589456, 0.792657683189083, -3.845106624433, 1.09304102786659, -3.98711529205142, 0.792657683189083, 14.4747599477348)), est = c(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, sdlog1 = 1.22807861931498, sdlog2 = 0.735859945900444), pars = list(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, 
        log_sdlog1 = 0.205450849919085, log_sdlog2 = -0.306715469257007), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0261006526172895, log_scale = 3.49407828676558), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.169571830144152, log_scale = 3.44710520115741), value = 43.6807922745908, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.5449756612725, -4.97000758937715, -4.97000758937715, 14.0374532123274)), est = c(scale = 31.4093368667314, shape = 1.18479744814816), pars = list(log_scale = 3.44710520115741, log_shape = 0.169571830144152), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,2.95574,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,FALSE,10,Boron,Rana sylvatica,70.7,Amphibian,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.296961095837491, log_scale = 3.0921637045904), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.261440996953924, log_scale = 3.12768679876144), value = 43.6947412117056, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.1578440455155, 12.9880041437013, 12.9880041437013, 12.9879663232819)), est = c(scale = 22.8211285756601, shape = 1.29880030613677), pars = list(log_scale = 3.12768679876144, log_shape = 0.261440996953924), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.352240607534656), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), value = 45.9330602035977, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.2733281997642, -4.46045016373558, -4.46045016373558, 23.2160273096977)), est = c(locationlog = 2.39783588813966, scalelog = 1.17255556905755), pars = list(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.698814197814629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), value = 44.256651435281, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.48684532860544, 0.0875077924964762, 0.0875077924964762, 14.4456093113738)), est = c(locationlog = 3.01880130017102, scalelog = 0.590352831830035), pars = list(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.98670299513176, log_sdlog = 0.10235655173629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), value = 44.2678041002333, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.03553302961929, -8.90233683405559e-07, -8.90233683405559e-07, 20.0000177800354)), est = c(meanlog = 2.95713172761119, sdlog = 1.05201785573431), pars = list(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.16206173752339, log_sdlog1 = -0.125798239499222, meanlog2 = 3.81134425274013, log_sdlog2 = -0.556825392185898, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.10056111509066, log_sdlog1 = 0.205450849919085, meanlog2 = 3.29666779842978, log_sdlog2 = -0.306715469257007, pmix = 0.3), value = 43.7405806968797, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.10806901294958, -0.534157452938338, 0.372742203584499, -0.0953397439732499, -3.845106624433, -0.534157452938338, 3.96201126055292, 1.99526595742094, 0.201699249151078, 1.09304102786659, 
    0.372742203584499, 1.99526595742094, 10.3372574319162, 0.633396133716582, -3.98711529205142, -0.0953397439732499, 0.201699249151078, 0.633396133716582, 12.388720589456, 0.792657683189083, -3.845106624433, 1.09304102786659, -3.98711529205142, 0.792657683189083, 14.4747599477348)), est = c(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, sdlog1 = 1.22807861931498, sdlog2 = 0.735859945900444), pars = list(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, 
        log_sdlog1 = 0.205450849919085, log_sdlog2 = -0.306715469257007), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0261006526172895, log_scale = 3.49407828676558), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.169571830144152, log_scale = 3.44710520115741), value = 43.6807922745908, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.5449756612725, -4.97000758937715, -4.97000758937715, 14.0374532123274)), est = c(scale = 31.4093368667314, shape = 1.18479744814816), pars = list(log_scale = 3.44710520115741, log_shape = 0.169571830144152), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,2.95574,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,FALSE,10,Boron,Spirodella polyrrhiza,1.8,Plant,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.296961095837491, log_scale = 3.0921637045904), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.261440996953924, log_scale = 3.12768679876144), value = 43.6947412117056, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.1578440455155, 12.9880041437013, 12.9880041437013, 12.9879663232819)), est = c(scale = 22.8211285756601, shape = 1.29880030613677), pars = list(log_scale = 3.12768679876144, log_shape = 0.261440996953924), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.352240607534656), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), value = 45.9330602035977, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.2733281997642, -4.46045016373558, -4.46045016373558, 23.2160273096977)), est = c(locationlog = 2.39783588813966, scalelog = 1.17255556905755), pars = list(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.698814197814629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), value = 44.256651435281, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.48684532860544, 0.0875077924964762, 0.0875077924964762, 14.4456093113738)), est = c(locationlog = 3.01880130017102, scalelog = 0.590352831830035), pars = list(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.98670299513176, log_sdlog = 0.10235655173629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), value = 44.2678041002333, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.03553302961929, -8.90233683405559e-07, -8.90233683405559e-07, 20.0000177800354)), est = c(meanlog = 2.95713172761119, sdlog = 1.05201785573431), pars = list(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.16206173752339, log_sdlog1 = -0.125798239499222, meanlog2 = 3.81134425274013, log_sdlog2 = -0.556825392185898, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.10056111509066, log_sdlog1 = 0.205450849919085, meanlog2 = 3.29666779842978, log_sdlog2 = -0.306715469257007, pmix = 0.3), value = 43.7405806968797, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.10806901294958, -0.534157452938338, 0.372742203584499, -0.0953397439732499, -3.845106624433, -0.534157452938338, 3.96201126055292, 1.99526595742094, 0.201699249151078, 1.09304102786659, 
    0.372742203584499, 1.99526595742094, 10.3372574319162, 0.633396133716582, -3.98711529205142, -0.0953397439732499, 0.201699249151078, 0.633396133716582, 12.388720589456, 0.792657683189083, -3.845106624433, 1.09304102786659, -3.98711529205142, 0.792657683189083, 14.4747599477348)), est = c(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, sdlog1 = 1.22807861931498, sdlog2 = 0.735859945900444), pars = list(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, 
        log_sdlog1 = 0.205450849919085, log_sdlog2 = -0.306715469257007), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0261006526172895, log_scale = 3.49407828676558), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.169571830144152, log_scale = 3.44710520115741), value = 43.6807922745908, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.5449756612725, -4.97000758937715, -4.97000758937715, 14.0374532123274)), est = c(scale = 31.4093368667314, shape = 1.18479744814816), pars = list(log_scale = 3.44710520115741, log_shape = 0.169571830144152), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,2.95574,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,FALSE,10,Boron,Pimephales promelas,18.3,Fish,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.296961095837491, log_scale = 3.0921637045904), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.261440996953924, log_scale = 3.12768679876144), value = 43.6947412117056, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.1578440455155, 12.9880041437013, 12.9880041437013, 12.9879663232819)), est = c(scale = 22.8211285756601, shape = 1.29880030613677), pars = list(log_scale = 3.12768679876144, log_shape = 0.261440996953924), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.352240607534656), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), value = 45.9330602035977, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.2733281997642, -4.46045016373558, -4.46045016373558, 23.2160273096977)), est = c(locationlog = 2.39783588813966, scalelog = 1.17255556905755), pars = list(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.698814197814629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), value = 44.256651435281, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.48684532860544, 0.0875077924964762, 0.0875077924964762, 14.4456093113738)), est = c(locationlog = 3.01880130017102, scalelog = 0.590352831830035), pars = list(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.98670299513176, log_sdlog = 0.10235655173629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), value = 44.2678041002333, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.03553302961929, -8.90233683405559e-07, -8.90233683405559e-07, 20.0000177800354)), est = c(meanlog = 2.95713172761119, sdlog = 1.05201785573431), pars = list(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.16206173752339, log_sdlog1 = -0.125798239499222, meanlog2 = 3.81134425274013, log_sdlog2 = -0.556825392185898, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.10056111509066, log_sdlog1 = 0.205450849919085, meanlog2 = 3.29666779842978, log_sdlog2 = -0.306715469257007, pmix = 0.3), value = 43.7405806968797, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.10806901294958, -0.534157452938338, 0.372742203584499, -0.0953397439732499, -3.845106624433, -0.534157452938338, 3.96201126055292, 1.99526595742094, 0.201699249151078, 1.09304102786659, 
    0.372742203584499, 1.99526595742094, 10.3372574319162, 0.633396133716582, -3.98711529205142, -0.0953397439732499, 0.201699249151078, 0.633396133716582, 12.388720589456, 0.792657683189083, -3.845106624433, 1.09304102786659, -3.98711529205142, 0.792657683189083, 14.4747599477348)), est = c(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, sdlog1 = 1.22807861931498, sdlog2 = 0.735859945900444), pars = list(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, 
        log_sdlog1 = 0.205450849919085, log_sdlog2 = -0.306715469257007), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0261006526172895, log_scale = 3.49407828676558), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.169571830144152, log_scale = 3.44710520115741), value = 43.6807922745908, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.5449756612725, -4.97000758937715, -4.97000758937715, 14.0374532123274)), est = c(scale = 31.4093368667314, shape = 1.18479744814816), pars = list(log_scale = 3.44710520115741, log_shape = 0.169571830144152), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,2.95574,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,FALSE,10,Boron,Anacystis nidulans,50,Plant,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.296961095837491, log_scale = 3.0921637045904), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.261440996953924, log_scale = 3.12768679876144), value = 43.6947412117056, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.1578440455155, 12.9880041437013, 12.9880041437013, 12.9879663232819)), est = c(scale = 22.8211285756601, shape = 1.29880030613677), pars = list(log_scale = 3.12768679876144, log_shape = 0.261440996953924), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.352240607534656), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), value = 45.9330602035977, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.2733281997642, -4.46045016373558, -4.46045016373558, 23.2160273096977)), est = c(locationlog = 2.39783588813966, scalelog = 1.17255556905755), pars = list(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.698814197814629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), value = 44.256651435281, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.48684532860544, 0.0875077924964762, 0.0875077924964762, 14.4456093113738)), est = c(locationlog = 3.01880130017102, scalelog = 0.590352831830035), pars = list(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.98670299513176, log_sdlog = 0.10235655173629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), value = 44.2678041002333, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.03553302961929, -8.90233683405559e-07, -8.90233683405559e-07, 20.0000177800354)), est = c(meanlog = 2.95713172761119, sdlog = 1.05201785573431), pars = list(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.16206173752339, log_sdlog1 = -0.125798239499222, meanlog2 = 3.81134425274013, log_sdlog2 = -0.556825392185898, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.10056111509066, log_sdlog1 = 0.205450849919085, meanlog2 = 3.29666779842978, log_sdlog2 = -0.306715469257007, pmix = 0.3), value = 43.7405806968797, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.10806901294958, -0.534157452938338, 0.372742203584499, -0.0953397439732499, -3.845106624433, -0.534157452938338, 3.96201126055292, 1.99526595742094, 0.201699249151078, 1.09304102786659, 
    0.372742203584499, 1.99526595742094, 10.3372574319162, 0.633396133716582, -3.98711529205142, -0.0953397439732499, 0.201699249151078, 0.633396133716582, 12.388720589456, 0.792657683189083, -3.845106624433, 1.09304102786659, -3.98711529205142, 0.792657683189083, 14.4747599477348)), est = c(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, sdlog1 = 1.22807861931498, sdlog2 = 0.735859945900444), pars = list(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, 
        log_sdlog1 = 0.205450849919085, log_sdlog2 = -0.306715469257007), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0261006526172895, log_scale = 3.49407828676558), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.169571830144152, log_scale = 3.44710520115741), value = 43.6807922745908, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.5449756612725, -4.97000758937715, -4.97000758937715, 14.0374532123274)), est = c(scale = 31.4093368667314, shape = 1.18479744814816), pars = list(log_scale = 3.44710520115741, log_shape = 0.169571830144152), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,2.95574,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,FALSE,10,Boron,Selenastrum capricornutum,12.3,Plant,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.296961095837491, log_scale = 3.0921637045904), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.261440996953924, log_scale = 3.12768679876144), value = 43.6947412117056, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.1578440455155, 12.9880041437013, 12.9880041437013, 12.9879663232819)), est = c(scale = 22.8211285756601, shape = 1.29880030613677), pars = list(log_scale = 3.12768679876144, log_shape = 0.261440996953924), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.352240607534656), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), value = 45.9330602035977, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.2733281997642, -4.46045016373558, -4.46045016373558, 23.2160273096977)), est = c(locationlog = 2.39783588813966, scalelog = 1.17255556905755), pars = list(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.698814197814629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), value = 44.256651435281, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.48684532860544, 0.0875077924964762, 0.0875077924964762, 14.4456093113738)), est = c(locationlog = 3.01880130017102, scalelog = 0.590352831830035), pars = list(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.98670299513176, log_sdlog = 0.10235655173629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), value = 44.2678041002333, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.03553302961929, -8.90233683405559e-07, -8.90233683405559e-07, 20.0000177800354)), est = c(meanlog = 2.95713172761119, sdlog = 1.05201785573431), pars = list(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.16206173752339, log_sdlog1 = -0.125798239499222, meanlog2 = 3.81134425274013, log_sdlog2 = -0.556825392185898, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.10056111509066, log_sdlog1 = 0.205450849919085, meanlog2 = 3.29666779842978, log_sdlog2 = -0.306715469257007, pmix = 0.3), value = 43.7405806968797, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.10806901294958, -0.534157452938338, 0.372742203584499, -0.0953397439732499, -3.845106624433, -0.534157452938338, 3.96201126055292, 1.99526595742094, 0.201699249151078, 1.09304102786659, 
    0.372742203584499, 1.99526595742094, 10.3372574319162, 0.633396133716582, -3.98711529205142, -0.0953397439732499, 0.201699249151078, 0.633396133716582, 12.388720589456, 0.792657683189083, -3.845106624433, 1.09304102786659, -3.98711529205142, 0.792657683189083, 14.4747599477348)), est = c(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, sdlog1 = 1.22807861931498, sdlog2 = 0.735859945900444), pars = list(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, 
        log_sdlog1 = 0.205450849919085, log_sdlog2 = -0.306715469257007), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0261006526172895, log_scale = 3.49407828676558), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.169571830144152, log_scale = 3.44710520115741), value = 43.6807922745908, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.5449756612725, -4.97000758937715, -4.97000758937715, 14.0374532123274)), est = c(scale = 31.4093368667314, shape = 1.18479744814816), pars = list(log_scale = 3.44710520115741, log_shape = 0.169571830144152), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,2.95574,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,FALSE,10,Boron,Opercularia bimarginata,10,Invertebrate,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.296961095837491, log_scale = 3.0921637045904), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.261440996953924, log_scale = 3.12768679876144), value = 43.6947412117056, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.1578440455155, 12.9880041437013, 12.9880041437013, 12.9879663232819)), est = c(scale = 22.8211285756601, shape = 1.29880030613677), pars = list(log_scale = 3.12768679876144, log_shape = 0.261440996953924), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.352240607534656), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), value = 45.9330602035977, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.2733281997642, -4.46045016373558, -4.46045016373558, 23.2160273096977)), est = c(locationlog = 2.39783588813966, scalelog = 1.17255556905755), pars = list(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.698814197814629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), value = 44.256651435281, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.48684532860544, 0.0875077924964762, 0.0875077924964762, 14.4456093113738)), est = c(locationlog = 3.01880130017102, scalelog = 0.590352831830035), pars = list(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.98670299513176, log_sdlog = 0.10235655173629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), value = 44.2678041002333, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.03553302961929, -8.90233683405559e-07, -8.90233683405559e-07, 20.0000177800354)), est = c(meanlog = 2.95713172761119, sdlog = 1.05201785573431), pars = list(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.16206173752339, log_sdlog1 = -0.125798239499222, meanlog2 = 3.81134425274013, log_sdlog2 = -0.556825392185898, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.10056111509066, log_sdlog1 = 0.205450849919085, meanlog2 = 3.29666779842978, log_sdlog2 = -0.306715469257007, pmix = 0.3), value = 43.7405806968797, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.10806901294958, -0.534157452938338, 0.372742203584499, -0.0953397439732499, -3.845106624433, -0.534157452938338, 3.96201126055292, 1.99526595742094, 0.201699249151078, 1.09304102786659, 
    0.372742203584499, 1.99526595742094, 10.3372574319162, 0.633396133716582, -3.98711529205142, -0.0953397439732499, 0.201699249151078, 0.633396133716582, 12.388720589456, 0.792657683189083, -3.845106624433, 1.09304102786659, -3.98711529205142, 0.792657683189083, 14.4747599477348)), est = c(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, sdlog1 = 1.22807861931498, sdlog2 = 0.735859945900444), pars = list(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, 
        log_sdlog1 = 0.205450849919085, log_sdlog2 = -0.306715469257007), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0261006526172895, log_scale = 3.49407828676558), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.169571830144152, log_scale = 3.44710520115741), value = 43.6807922745908, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.5449756612725, -4.97000758937715, -4.97000758937715, 14.0374532123274)), est = c(scale = 31.4093368667314, shape = 1.18479744814816), pars = list(log_scale = 3.44710520115741, log_shape = 0.169571830144152), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,2.95574,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,FALSE,10,Boron,Entosiphon sulcatum,15,Invertebrate,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.296961095837491, log_scale = 3.0921637045904), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.261440996953924, log_scale = 3.12768679876144), value = 43.6947412117056, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.1578440455155, 12.9880041437013, 12.9880041437013, 12.9879663232819)), est = c(scale = 22.8211285756601, shape = 1.29880030613677), pars = list(log_scale = 3.12768679876144, log_shape = 0.261440996953924), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.352240607534656), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), value = 45.9330602035977, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.2733281997642, -4.46045016373558, -4.46045016373558, 23.2160273096977)), est = c(locationlog = 2.39783588813966, scalelog = 1.17255556905755), pars = list(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.698814197814629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), value = 44.256651435281, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.48684532860544, 0.0875077924964762, 0.0875077924964762, 14.4456093113738)), est = c(locationlog = 3.01880130017102, scalelog = 0.590352831830035), pars = list(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.98670299513176, log_sdlog = 0.10235655173629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), value = 44.2678041002333, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.03553302961929, -8.90233683405559e-07, -8.90233683405559e-07, 20.0000177800354)), est = c(meanlog = 2.95713172761119, sdlog = 1.05201785573431), pars = list(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.16206173752339, log_sdlog1 = -0.125798239499222, meanlog2 = 3.81134425274013, log_sdlog2 = -0.556825392185898, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.10056111509066, log_sdlog1 = 0.205450849919085, meanlog2 = 3.29666779842978, log_sdlog2 = -0.306715469257007, pmix = 0.3), value = 43.7405806968797, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.10806901294958, -0.534157452938338, 0.372742203584499, -0.0953397439732499, -3.845106624433, -0.534157452938338, 3.96201126055292, 1.99526595742094, 0.201699249151078, 1.09304102786659, 
    0.372742203584499, 1.99526595742094, 10.3372574319162, 0.633396133716582, -3.98711529205142, -0.0953397439732499, 0.201699249151078, 0.633396133716582, 12.388720589456, 0.792657683189083, -3.845106624433, 1.09304102786659, -3.98711529205142, 0.792657683189083, 14.4747599477348)), est = c(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, sdlog1 = 1.22807861931498, sdlog2 = 0.735859945900444), pars = list(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, 
        log_sdlog1 = 0.205450849919085, log_sdlog2 = -0.306715469257007), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0261006526172895, log_scale = 3.49407828676558), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.169571830144152, log_scale = 3.44710520115741), value = 43.6807922745908, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.5449756612725, -4.97000758937715, -4.97000758937715, 14.0374532123274)), est = c(scale = 31.4093368667314, shape = 1.18479744814816), pars = list(log_scale = 3.44710520115741, log_shape = 0.169571830144152), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,2.95574,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
1,1,FALSE,10,Boron,Ambystoma jeffersonianum,70.7,Amphibian,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.296961095837491, log_scale = 3.0921637045904), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.261440996953924, log_scale = 3.12768679876144), value = 43.6947412117056, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.1578440455155, 12.9880041437013, 12.9880041437013, 12.9879663232819)), est = c(scale = 22.8211285756601, shape = 1.29880030613677), pars = list(log_scale = 3.12768679876144, log_shape = 0.261440996953924), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.352240607534656), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), value = 45.9330602035977, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.2733281997642, -4.46045016373558, -4.46045016373558, 23.2160273096977)), est = c(locationlog = 2.39783588813966, scalelog = 1.17255556905755), pars = list(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.698814197814629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), value = 44.256651435281, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.48684532860544, 0.0875077924964762, 0.0875077924964762, 14.4456093113738)), est = c(locationlog = 3.01880130017102, scalelog = 0.590352831830035), pars = list(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.98670299513176, log_sdlog = 0.10235655173629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), value = 44.2678041002333, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.03553302961929, -8.90233683405559e-07, -8.90233683405559e-07, 20.0000177800354)), est = c(meanlog = 2.95713172761119, sdlog = 1.05201785573431), pars = list(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.16206173752339, log_sdlog1 = -0.125798239499222, meanlog2 = 3.81134425274013, log_sdlog2 = -0.556825392185898, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.10056111509066, log_sdlog1 = 0.205450849919085, meanlog2 = 3.29666779842978, log_sdlog2 = -0.306715469257007, pmix = 0.3), value = 43.7405806968797, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.10806901294958, -0.534157452938338, 0.372742203584499, -0.0953397439732499, -3.845106624433, -0.534157452938338, 3.96201126055292, 1.99526595742094, 0.201699249151078, 1.09304102786659, 
    0.372742203584499, 1.99526595742094, 10.3372574319162, 0.633396133716582, -3.98711529205142, -0.0953397439732499, 0.201699249151078, 0.633396133716582, 12.388720589456, 0.792657683189083, -3.845106624433, 1.09304102786659, -3.98711529205142, 0.792657683189083, 14.4747599477348)), est = c(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, sdlog1 = 1.22807861931498, sdlog2 = 0.735859945900444), pars = list(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, 
        log_sdlog1 = 0.205450849919085, log_sdlog2 = -0.306715469257007), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0261006526172895, log_scale = 3.49407828676558), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.169571830144152, log_scale = 3.44710520115741), value = 43.6807922745908, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.5449756612725, -4.97000758937715, -4.97000758937715, 14.0374532123274)), est = c(scale = 31.4093368667314, shape = 1.18479744814816), pars = list(log_scale = 3.44710520115741, log_shape = 0.169571830144152), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,2.95574,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,TRUE,5,Boron,Ceriodaphnia dubia,13.4,Invertebrate,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.404342295956148, log_scale = 3.17973204379166), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.0105313667858157, log_scale = 3.57354290637599), value = 22.9201935827036, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.27159371108351, 5.05293550514965, 5.05293550514965, 5.05293626268208)), est = c(scale = 35.6426482848709, shape = 1.01058701681439), pars = list(log_scale = 3.57354290637599, log_shape = 0.0105313667858157), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01361143021043, log_scalelog = 0.656875636393804), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.28904105433868, log_scalelog = 0.376119114857425), value = 24.4358118482949, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.3565510495971, -1.72511552626965, -1.72511552626965, 10.6498933497436)), est = c(locationlog = 2.28904105433868, scalelog = 1.45662062859647), pars = list(locationlog = 2.28904105433868, log_scalelog = 0.376119114857425), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01361143021043, log_scalelog = 1.00344922667378), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.21159478248024, log_scalelog = -0.264677785737225), value = 23.720568054143, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.81342660491168, 0.663711081769443, 0.663711081769443, 7.16360678673574)), est = c(locationlog = 3.21159478248024, scalelog = 0.767453194506141), pars = list(locationlog = 3.21159478248024, log_scalelog = -0.264677785737225), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04374754451254, log_sdlog = 0.403945230306847), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01361049211189, log_sdlog = 0.296454505400714), value = 23.6450183645866, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.76358541928495, 5.18503263296939e-06, 5.18503263296939e-06, 9.9999907486879)), est = c(meanlog = 3.01361049211189, sdlog = 1.34508136466754), pars = list(meanlog = 3.01361049211189, log_sdlog = 0.296454505400714), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 1.60743589278879, log_sdlog1 = 0.346797650585182, meanlog2 = 4.00128864566171, log_sdlog2 = -0.955683746294042, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 1.90372731530473, log_sdlog1 = 0.18184626406043, meanlog2 = 3.9933343044265, log_sdlog2 = -1.20835298286039, pmix = 0.5), value = 21.8945918630597, counts = c(`function` = 12, gradient = 12), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.15749458501768, -0.563743440651667, -0.772422299048776, 0.213541067331319, -1.43180326885801, -0.563743440651667, 3.91575777552026, -0.277663697958906, 0.0925194874597639, -1.59987627195682, 
    -0.772422299048776, -0.277663697958906, 24.3076366978829, 1.42889831677594, -3.05961733243781, 0.213541067331319, 0.0925194874597639, 1.42889831677594, 4.88222000496555, 0.832087488744832, -1.43180326885801, -1.59987627195682, -3.05961733243781, 0.832087488744832, 15.5345267050092)), est = c(meanlog1 = 1.90372731530473, meanlog2 = 3.9933343044265, pmix = 0.5, sdlog1 = 1.19942978424021, sdlog2 = 0.298688820136962), pars = list(meanlog1 = 1.90372731530473, meanlog2 = 3.9933343044265, pmix = 0.5, 
        log_sdlog1 = 0.18184626406043, log_sdlog2 = -1.20835298286039), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.401894528195339, log_scale = 3.74731745369501), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.0848299228971603, log_scale = 3.6113315359395), value = 22.8970770469694, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.28590117356708, -1.9014653883579, -1.9014653883579, 5.92448904106288)), est = c(scale = 37.0153072274199, shape = 1.08853191659923), pars = list(log_scale = 3.6113315359395, log_shape = 0.0848299228971603), flags = list(at_boundary = FALSE, computable = TRUE)))",lnorm_lnorm,0.05,1.44282,NA,NA,NA,1,0.95,cdf,percentile,parametric,0,1,lnorm_lnorm,numeric(0)
2,1,TRUE,5,Boron,Myriophyllum spicatum,34.2,Plant,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.404342295956148, log_scale = 3.17973204379166), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.0105313667858157, log_scale = 3.57354290637599), value = 22.9201935827036, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.27159371108351, 5.05293550514965, 5.05293550514965, 5.05293626268208)), est = c(scale = 35.6426482848709, shape = 1.01058701681439), pars = list(log_scale = 3.57354290637599, log_shape = 0.0105313667858157), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01361143021043, log_scalelog = 0.656875636393804), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.28904105433868, log_scalelog = 0.376119114857425), value = 24.4358118482949, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.3565510495971, -1.72511552626965, -1.72511552626965, 10.6498933497436)), est = c(locationlog = 2.28904105433868, scalelog = 1.45662062859647), pars = list(locationlog = 2.28904105433868, log_scalelog = 0.376119114857425), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01361143021043, log_scalelog = 1.00344922667378), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.21159478248024, log_scalelog = -0.264677785737225), value = 23.720568054143, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.81342660491168, 0.663711081769443, 0.663711081769443, 7.16360678673574)), est = c(locationlog = 3.21159478248024, scalelog = 0.767453194506141), pars = list(locationlog = 3.21159478248024, log_scalelog = -0.264677785737225), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04374754451254, log_sdlog = 0.403945230306847), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01361049211189, log_sdlog = 0.296454505400714), value = 23.6450183645866, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.76358541928495, 5.18503263296939e-06, 5.18503263296939e-06, 9.9999907486879)), est = c(meanlog = 3.01361049211189, sdlog = 1.34508136466754), pars = list(meanlog = 3.01361049211189, log_sdlog = 0.296454505400714), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 1.60743589278879, log_sdlog1 = 0.346797650585182, meanlog2 = 4.00128864566171, log_sdlog2 = -0.955683746294042, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 1.90372731530473, log_sdlog1 = 0.18184626406043, meanlog2 = 3.9933343044265, log_sdlog2 = -1.20835298286039, pmix = 0.5), value = 21.8945918630597, counts = c(`function` = 12, gradient = 12), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.15749458501768, -0.563743440651667, -0.772422299048776, 0.213541067331319, -1.43180326885801, -0.563743440651667, 3.91575777552026, -0.277663697958906, 0.0925194874597639, -1.59987627195682, 
    -0.772422299048776, -0.277663697958906, 24.3076366978829, 1.42889831677594, -3.05961733243781, 0.213541067331319, 0.0925194874597639, 1.42889831677594, 4.88222000496555, 0.832087488744832, -1.43180326885801, -1.59987627195682, -3.05961733243781, 0.832087488744832, 15.5345267050092)), est = c(meanlog1 = 1.90372731530473, meanlog2 = 3.9933343044265, pmix = 0.5, sdlog1 = 1.19942978424021, sdlog2 = 0.298688820136962), pars = list(meanlog1 = 1.90372731530473, meanlog2 = 3.9933343044265, pmix = 0.5, 
        log_sdlog1 = 0.18184626406043, log_sdlog2 = -1.20835298286039), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.401894528195339, log_scale = 3.74731745369501), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.0848299228971603, log_scale = 3.6113315359395), value = 22.8970770469694, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.28590117356708, -1.9014653883579, -1.9014653883579, 5.92448904106288)), est = c(scale = 37.0153072274199, shape = 1.08853191659923), pars = list(log_scale = 3.6113315359395, log_shape = 0.0848299228971603), flags = list(at_boundary = FALSE, computable = TRUE)))",lnorm_lnorm,0.05,1.44282,NA,NA,NA,1,0.95,cdf,percentile,parametric,0,1,lnorm_lnorm,numeric(0)
2,1,TRUE,5,Boron,Rana sylvatica,70.7,Amphibian,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.404342295956148, log_scale = 3.17973204379166), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.0105313667858157, log_scale = 3.57354290637599), value = 22.9201935827036, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.27159371108351, 5.05293550514965, 5.05293550514965, 5.05293626268208)), est = c(scale = 35.6426482848709, shape = 1.01058701681439), pars = list(log_scale = 3.57354290637599, log_shape = 0.0105313667858157), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01361143021043, log_scalelog = 0.656875636393804), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.28904105433868, log_scalelog = 0.376119114857425), value = 24.4358118482949, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.3565510495971, -1.72511552626965, -1.72511552626965, 10.6498933497436)), est = c(locationlog = 2.28904105433868, scalelog = 1.45662062859647), pars = list(locationlog = 2.28904105433868, log_scalelog = 0.376119114857425), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01361143021043, log_scalelog = 1.00344922667378), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.21159478248024, log_scalelog = -0.264677785737225), value = 23.720568054143, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.81342660491168, 0.663711081769443, 0.663711081769443, 7.16360678673574)), est = c(locationlog = 3.21159478248024, scalelog = 0.767453194506141), pars = list(locationlog = 3.21159478248024, log_scalelog = -0.264677785737225), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04374754451254, log_sdlog = 0.403945230306847), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01361049211189, log_sdlog = 0.296454505400714), value = 23.6450183645866, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.76358541928495, 5.18503263296939e-06, 5.18503263296939e-06, 9.9999907486879)), est = c(meanlog = 3.01361049211189, sdlog = 1.34508136466754), pars = list(meanlog = 3.01361049211189, log_sdlog = 0.296454505400714), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 1.60743589278879, log_sdlog1 = 0.346797650585182, meanlog2 = 4.00128864566171, log_sdlog2 = -0.955683746294042, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 1.90372731530473, log_sdlog1 = 0.18184626406043, meanlog2 = 3.9933343044265, log_sdlog2 = -1.20835298286039, pmix = 0.5), value = 21.8945918630597, counts = c(`function` = 12, gradient = 12), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.15749458501768, -0.563743440651667, -0.772422299048776, 0.213541067331319, -1.43180326885801, -0.563743440651667, 3.91575777552026, -0.277663697958906, 0.0925194874597639, -1.59987627195682, 
    -0.772422299048776, -0.277663697958906, 24.3076366978829, 1.42889831677594, -3.05961733243781, 0.213541067331319, 0.0925194874597639, 1.42889831677594, 4.88222000496555, 0.832087488744832, -1.43180326885801, -1.59987627195682, -3.05961733243781, 0.832087488744832, 15.5345267050092)), est = c(meanlog1 = 1.90372731530473, meanlog2 = 3.9933343044265, pmix = 0.5, sdlog1 = 1.19942978424021, sdlog2 = 0.298688820136962), pars = list(meanlog1 = 1.90372731530473, meanlog2 = 3.9933343044265, pmix = 0.5, 
        log_sdlog1 = 0.18184626406043, log_sdlog2 = -1.20835298286039), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.401894528195339, log_scale = 3.74731745369501), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.0848299228971603, log_scale = 3.6113315359395), value = 22.8970770469694, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.28590117356708, -1.9014653883579, -1.9014653883579, 5.92448904106288)), est = c(scale = 37.0153072274199, shape = 1.08853191659923), pars = list(log_scale = 3.6113315359395, log_shape = 0.0848299228971603), flags = list(at_boundary = FALSE, computable = TRUE)))",lnorm_lnorm,0.05,1.44282,NA,NA,NA,1,0.95,cdf,percentile,parametric,0,1,lnorm_lnorm,numeric(0)
2,1,TRUE,5,Boron,Lemna minor,60,Plant,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.404342295956148, log_scale = 3.17973204379166), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.0105313667858157, log_scale = 3.57354290637599), value = 22.9201935827036, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.27159371108351, 5.05293550514965, 5.05293550514965, 5.05293626268208)), est = c(scale = 35.6426482848709, shape = 1.01058701681439), pars = list(log_scale = 3.57354290637599, log_shape = 0.0105313667858157), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01361143021043, log_scalelog = 0.656875636393804), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.28904105433868, log_scalelog = 0.376119114857425), value = 24.4358118482949, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.3565510495971, -1.72511552626965, -1.72511552626965, 10.6498933497436)), est = c(locationlog = 2.28904105433868, scalelog = 1.45662062859647), pars = list(locationlog = 2.28904105433868, log_scalelog = 0.376119114857425), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01361143021043, log_scalelog = 1.00344922667378), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.21159478248024, log_scalelog = -0.264677785737225), value = 23.720568054143, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.81342660491168, 0.663711081769443, 0.663711081769443, 7.16360678673574)), est = c(locationlog = 3.21159478248024, scalelog = 0.767453194506141), pars = list(locationlog = 3.21159478248024, log_scalelog = -0.264677785737225), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04374754451254, log_sdlog = 0.403945230306847), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01361049211189, log_sdlog = 0.296454505400714), value = 23.6450183645866, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.76358541928495, 5.18503263296939e-06, 5.18503263296939e-06, 9.9999907486879)), est = c(meanlog = 3.01361049211189, sdlog = 1.34508136466754), pars = list(meanlog = 3.01361049211189, log_sdlog = 0.296454505400714), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 1.60743589278879, log_sdlog1 = 0.346797650585182, meanlog2 = 4.00128864566171, log_sdlog2 = -0.955683746294042, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 1.90372731530473, log_sdlog1 = 0.18184626406043, meanlog2 = 3.9933343044265, log_sdlog2 = -1.20835298286039, pmix = 0.5), value = 21.8945918630597, counts = c(`function` = 12, gradient = 12), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.15749458501768, -0.563743440651667, -0.772422299048776, 0.213541067331319, -1.43180326885801, -0.563743440651667, 3.91575777552026, -0.277663697958906, 0.0925194874597639, -1.59987627195682, 
    -0.772422299048776, -0.277663697958906, 24.3076366978829, 1.42889831677594, -3.05961733243781, 0.213541067331319, 0.0925194874597639, 1.42889831677594, 4.88222000496555, 0.832087488744832, -1.43180326885801, -1.59987627195682, -3.05961733243781, 0.832087488744832, 15.5345267050092)), est = c(meanlog1 = 1.90372731530473, meanlog2 = 3.9933343044265, pmix = 0.5, sdlog1 = 1.19942978424021, sdlog2 = 0.298688820136962), pars = list(meanlog1 = 1.90372731530473, meanlog2 = 3.9933343044265, pmix = 0.5, 
        log_sdlog1 = 0.18184626406043, log_sdlog2 = -1.20835298286039), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.401894528195339, log_scale = 3.74731745369501), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.0848299228971603, log_scale = 3.6113315359395), value = 22.8970770469694, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.28590117356708, -1.9014653883579, -1.9014653883579, 5.92448904106288)), est = c(scale = 37.0153072274199, shape = 1.08853191659923), pars = list(log_scale = 3.6113315359395, log_shape = 0.0848299228971603), flags = list(at_boundary = FALSE, computable = TRUE)))",lnorm_lnorm,0.05,1.44282,NA,NA,NA,1,0.95,cdf,percentile,parametric,0,1,lnorm_lnorm,numeric(0)
2,1,TRUE,5,Boron,Spirodella polyrrhiza,1.8,Plant,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.404342295956148, log_scale = 3.17973204379166), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.0105313667858157, log_scale = 3.57354290637599), value = 22.9201935827036, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.27159371108351, 5.05293550514965, 5.05293550514965, 5.05293626268208)), est = c(scale = 35.6426482848709, shape = 1.01058701681439), pars = list(log_scale = 3.57354290637599, log_shape = 0.0105313667858157), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01361143021043, log_scalelog = 0.656875636393804), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.28904105433868, log_scalelog = 0.376119114857425), value = 24.4358118482949, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.3565510495971, -1.72511552626965, -1.72511552626965, 10.6498933497436)), est = c(locationlog = 2.28904105433868, scalelog = 1.45662062859647), pars = list(locationlog = 2.28904105433868, log_scalelog = 0.376119114857425), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01361143021043, log_scalelog = 1.00344922667378), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.21159478248024, log_scalelog = -0.264677785737225), value = 23.720568054143, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.81342660491168, 0.663711081769443, 0.663711081769443, 7.16360678673574)), est = c(locationlog = 3.21159478248024, scalelog = 0.767453194506141), pars = list(locationlog = 3.21159478248024, log_scalelog = -0.264677785737225), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04374754451254, log_sdlog = 0.403945230306847), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01361049211189, log_sdlog = 0.296454505400714), value = 23.6450183645866, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.76358541928495, 5.18503263296939e-06, 5.18503263296939e-06, 9.9999907486879)), est = c(meanlog = 3.01361049211189, sdlog = 1.34508136466754), pars = list(meanlog = 3.01361049211189, log_sdlog = 0.296454505400714), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 1.60743589278879, log_sdlog1 = 0.346797650585182, meanlog2 = 4.00128864566171, log_sdlog2 = -0.955683746294042, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 1.90372731530473, log_sdlog1 = 0.18184626406043, meanlog2 = 3.9933343044265, log_sdlog2 = -1.20835298286039, pmix = 0.5), value = 21.8945918630597, counts = c(`function` = 12, gradient = 12), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.15749458501768, -0.563743440651667, -0.772422299048776, 0.213541067331319, -1.43180326885801, -0.563743440651667, 3.91575777552026, -0.277663697958906, 0.0925194874597639, -1.59987627195682, 
    -0.772422299048776, -0.277663697958906, 24.3076366978829, 1.42889831677594, -3.05961733243781, 0.213541067331319, 0.0925194874597639, 1.42889831677594, 4.88222000496555, 0.832087488744832, -1.43180326885801, -1.59987627195682, -3.05961733243781, 0.832087488744832, 15.5345267050092)), est = c(meanlog1 = 1.90372731530473, meanlog2 = 3.9933343044265, pmix = 0.5, sdlog1 = 1.19942978424021, sdlog2 = 0.298688820136962), pars = list(meanlog1 = 1.90372731530473, meanlog2 = 3.9933343044265, pmix = 0.5, 
        log_sdlog1 = 0.18184626406043, log_sdlog2 = -1.20835298286039), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.401894528195339, log_scale = 3.74731745369501), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.0848299228971603, log_scale = 3.6113315359395), value = 22.8970770469694, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.28590117356708, -1.9014653883579, -1.9014653883579, 5.92448904106288)), est = c(scale = 37.0153072274199, shape = 1.08853191659923), pars = list(log_scale = 3.6113315359395, log_shape = 0.0848299228971603), flags = list(at_boundary = FALSE, computable = TRUE)))",lnorm_lnorm,0.05,1.44282,NA,NA,NA,1,0.95,cdf,percentile,parametric,0,1,lnorm_lnorm,numeric(0)
2,1,TRUE,10,Boron,Ceriodaphnia dubia,13.4,Invertebrate,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.347793754217606, log_scale = 3.09262434059783), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.277430462233145, log_scale = 3.16298819283177), value = 44.1844051391579, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.3513547229456, 13.197344545515, 13.197344545515, 13.1973382514882)), est = c(scale = 23.6411347541813, shape = 1.31973434457373), pars = list(log_scale = 3.16298819283177, log_shape = 0.277430462233145), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.354906869806067), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), value = 46.6778177990908, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(6.97932406875603, -4.4109512522487, -4.4109512522487, 23.5210817167262)), est = c(locationlog = 2.45095092520366, scalelog = 1.19699830659697), pars = list(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.70148046008604), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), value = 44.8068237391937, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.70755613219043, 0.110062370784643, 0.110062370784643, 14.3477071950677)), est = c(locationlog = 3.08612119576206, scalelog = 0.585534345569591), pars = list(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04610984020903, log_sdlog = 0.104996151384988), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), value = 44.8826533078709, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.9874790685385, -9.13810438523545e-07, -9.13810438523545e-07, 20.0000177849704)), est = c(meanlog = 3.01595038767856, sdlog = 1.05482655382095), pars = list(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.24404647320555, log_sdlog1 = -0.0740119078270196, meanlog2 = 3.8481732072125, log_sdlog2 = -0.528291412471149, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.14758312942008, log_sdlog1 = 0.244519270285268, meanlog2 = 3.34961017263854, log_sdlog2 = -0.334200253537533, pmix = 0.3), value = 44.2079824669256, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.01596678568366, -0.417719976164404, 0.355566795496601, -0.0227070283941919, -3.71066812352201, -0.417719976164404, 4.08011017928992, 1.92759745001563, 0.209859003102214, 1.21595140513363, 
    0.355566795496601, 1.92759745001563, 11.2200049169097, 0.305380836107699, -3.54125431450658, -0.0227070283941919, 0.209859003102214, 0.305380836107699, 13.1099265769319, 0.473756761924852, -3.71066812352201, 1.21595140513363, -3.54125431450658, 0.473756761924852, 14.4223658096976)), est = c(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, sdlog1 = 1.27700727028162, sdlog2 = 0.715910404280703), pars = list(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, 
        log_sdlog1 = 0.244519270285268, log_sdlog2 = -0.334200253537533), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0403453011819949, log_scale = 3.56060029650164), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.18695514873387, log_scale = 3.50227796541358), value = 44.1529874803777, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.3139940408785, -4.9874260353886, -4.9874260353886, 14.5340712022155)), est = c(scale = 33.1909737983211, shape = 1.20557321235233), pars = list(log_scale = 3.50227796541358, log_shape = 0.18695514873387), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,3.17476,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,TRUE,10,Boron,Myriophyllum spicatum,34.2,Plant,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.347793754217606, log_scale = 3.09262434059783), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.277430462233145, log_scale = 3.16298819283177), value = 44.1844051391579, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.3513547229456, 13.197344545515, 13.197344545515, 13.1973382514882)), est = c(scale = 23.6411347541813, shape = 1.31973434457373), pars = list(log_scale = 3.16298819283177, log_shape = 0.277430462233145), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.354906869806067), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), value = 46.6778177990908, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(6.97932406875603, -4.4109512522487, -4.4109512522487, 23.5210817167262)), est = c(locationlog = 2.45095092520366, scalelog = 1.19699830659697), pars = list(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.70148046008604), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), value = 44.8068237391937, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.70755613219043, 0.110062370784643, 0.110062370784643, 14.3477071950677)), est = c(locationlog = 3.08612119576206, scalelog = 0.585534345569591), pars = list(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04610984020903, log_sdlog = 0.104996151384988), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), value = 44.8826533078709, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.9874790685385, -9.13810438523545e-07, -9.13810438523545e-07, 20.0000177849704)), est = c(meanlog = 3.01595038767856, sdlog = 1.05482655382095), pars = list(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.24404647320555, log_sdlog1 = -0.0740119078270196, meanlog2 = 3.8481732072125, log_sdlog2 = -0.528291412471149, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.14758312942008, log_sdlog1 = 0.244519270285268, meanlog2 = 3.34961017263854, log_sdlog2 = -0.334200253537533, pmix = 0.3), value = 44.2079824669256, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.01596678568366, -0.417719976164404, 0.355566795496601, -0.0227070283941919, -3.71066812352201, -0.417719976164404, 4.08011017928992, 1.92759745001563, 0.209859003102214, 1.21595140513363, 
    0.355566795496601, 1.92759745001563, 11.2200049169097, 0.305380836107699, -3.54125431450658, -0.0227070283941919, 0.209859003102214, 0.305380836107699, 13.1099265769319, 0.473756761924852, -3.71066812352201, 1.21595140513363, -3.54125431450658, 0.473756761924852, 14.4223658096976)), est = c(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, sdlog1 = 1.27700727028162, sdlog2 = 0.715910404280703), pars = list(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, 
        log_sdlog1 = 0.244519270285268, log_sdlog2 = -0.334200253537533), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0403453011819949, log_scale = 3.56060029650164), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.18695514873387, log_scale = 3.50227796541358), value = 44.1529874803777, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.3139940408785, -4.9874260353886, -4.9874260353886, 14.5340712022155)), est = c(scale = 33.1909737983211, shape = 1.20557321235233), pars = list(log_scale = 3.50227796541358, log_shape = 0.18695514873387), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,3.17476,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,TRUE,10,Boron,Rana sylvatica,70.7,Amphibian,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.347793754217606, log_scale = 3.09262434059783), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.277430462233145, log_scale = 3.16298819283177), value = 44.1844051391579, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.3513547229456, 13.197344545515, 13.197344545515, 13.1973382514882)), est = c(scale = 23.6411347541813, shape = 1.31973434457373), pars = list(log_scale = 3.16298819283177, log_shape = 0.277430462233145), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.354906869806067), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), value = 46.6778177990908, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(6.97932406875603, -4.4109512522487, -4.4109512522487, 23.5210817167262)), est = c(locationlog = 2.45095092520366, scalelog = 1.19699830659697), pars = list(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.70148046008604), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), value = 44.8068237391937, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.70755613219043, 0.110062370784643, 0.110062370784643, 14.3477071950677)), est = c(locationlog = 3.08612119576206, scalelog = 0.585534345569591), pars = list(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04610984020903, log_sdlog = 0.104996151384988), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), value = 44.8826533078709, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.9874790685385, -9.13810438523545e-07, -9.13810438523545e-07, 20.0000177849704)), est = c(meanlog = 3.01595038767856, sdlog = 1.05482655382095), pars = list(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.24404647320555, log_sdlog1 = -0.0740119078270196, meanlog2 = 3.8481732072125, log_sdlog2 = -0.528291412471149, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.14758312942008, log_sdlog1 = 0.244519270285268, meanlog2 = 3.34961017263854, log_sdlog2 = -0.334200253537533, pmix = 0.3), value = 44.2079824669256, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.01596678568366, -0.417719976164404, 0.355566795496601, -0.0227070283941919, -3.71066812352201, -0.417719976164404, 4.08011017928992, 1.92759745001563, 0.209859003102214, 1.21595140513363, 
    0.355566795496601, 1.92759745001563, 11.2200049169097, 0.305380836107699, -3.54125431450658, -0.0227070283941919, 0.209859003102214, 0.305380836107699, 13.1099265769319, 0.473756761924852, -3.71066812352201, 1.21595140513363, -3.54125431450658, 0.473756761924852, 14.4223658096976)), est = c(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, sdlog1 = 1.27700727028162, sdlog2 = 0.715910404280703), pars = list(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, 
        log_sdlog1 = 0.244519270285268, log_sdlog2 = -0.334200253537533), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0403453011819949, log_scale = 3.56060029650164), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.18695514873387, log_scale = 3.50227796541358), value = 44.1529874803777, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.3139940408785, -4.9874260353886, -4.9874260353886, 14.5340712022155)), est = c(scale = 33.1909737983211, shape = 1.20557321235233), pars = list(log_scale = 3.50227796541358, log_shape = 0.18695514873387), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,3.17476,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,TRUE,10,Boron,Lemna minor,60,Plant,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.347793754217606, log_scale = 3.09262434059783), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.277430462233145, log_scale = 3.16298819283177), value = 44.1844051391579, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.3513547229456, 13.197344545515, 13.197344545515, 13.1973382514882)), est = c(scale = 23.6411347541813, shape = 1.31973434457373), pars = list(log_scale = 3.16298819283177, log_shape = 0.277430462233145), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.354906869806067), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), value = 46.6778177990908, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(6.97932406875603, -4.4109512522487, -4.4109512522487, 23.5210817167262)), est = c(locationlog = 2.45095092520366, scalelog = 1.19699830659697), pars = list(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.70148046008604), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), value = 44.8068237391937, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.70755613219043, 0.110062370784643, 0.110062370784643, 14.3477071950677)), est = c(locationlog = 3.08612119576206, scalelog = 0.585534345569591), pars = list(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04610984020903, log_sdlog = 0.104996151384988), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), value = 44.8826533078709, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.9874790685385, -9.13810438523545e-07, -9.13810438523545e-07, 20.0000177849704)), est = c(meanlog = 3.01595038767856, sdlog = 1.05482655382095), pars = list(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.24404647320555, log_sdlog1 = -0.0740119078270196, meanlog2 = 3.8481732072125, log_sdlog2 = -0.528291412471149, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.14758312942008, log_sdlog1 = 0.244519270285268, meanlog2 = 3.34961017263854, log_sdlog2 = -0.334200253537533, pmix = 0.3), value = 44.2079824669256, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.01596678568366, -0.417719976164404, 0.355566795496601, -0.0227070283941919, -3.71066812352201, -0.417719976164404, 4.08011017928992, 1.92759745001563, 0.209859003102214, 1.21595140513363, 
    0.355566795496601, 1.92759745001563, 11.2200049169097, 0.305380836107699, -3.54125431450658, -0.0227070283941919, 0.209859003102214, 0.305380836107699, 13.1099265769319, 0.473756761924852, -3.71066812352201, 1.21595140513363, -3.54125431450658, 0.473756761924852, 14.4223658096976)), est = c(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, sdlog1 = 1.27700727028162, sdlog2 = 0.715910404280703), pars = list(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, 
        log_sdlog1 = 0.244519270285268, log_sdlog2 = -0.334200253537533), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0403453011819949, log_scale = 3.56060029650164), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.18695514873387, log_scale = 3.50227796541358), value = 44.1529874803777, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.3139940408785, -4.9874260353886, -4.9874260353886, 14.5340712022155)), est = c(scale = 33.1909737983211, shape = 1.20557321235233), pars = list(log_scale = 3.50227796541358, log_shape = 0.18695514873387), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,3.17476,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,TRUE,10,Boron,Spirodella polyrrhiza,1.8,Plant,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.347793754217606, log_scale = 3.09262434059783), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.277430462233145, log_scale = 3.16298819283177), value = 44.1844051391579, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.3513547229456, 13.197344545515, 13.197344545515, 13.1973382514882)), est = c(scale = 23.6411347541813, shape = 1.31973434457373), pars = list(log_scale = 3.16298819283177, log_shape = 0.277430462233145), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.354906869806067), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), value = 46.6778177990908, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(6.97932406875603, -4.4109512522487, -4.4109512522487, 23.5210817167262)), est = c(locationlog = 2.45095092520366, scalelog = 1.19699830659697), pars = list(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.70148046008604), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), value = 44.8068237391937, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.70755613219043, 0.110062370784643, 0.110062370784643, 14.3477071950677)), est = c(locationlog = 3.08612119576206, scalelog = 0.585534345569591), pars = list(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04610984020903, log_sdlog = 0.104996151384988), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), value = 44.8826533078709, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.9874790685385, -9.13810438523545e-07, -9.13810438523545e-07, 20.0000177849704)), est = c(meanlog = 3.01595038767856, sdlog = 1.05482655382095), pars = list(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.24404647320555, log_sdlog1 = -0.0740119078270196, meanlog2 = 3.8481732072125, log_sdlog2 = -0.528291412471149, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.14758312942008, log_sdlog1 = 0.244519270285268, meanlog2 = 3.34961017263854, log_sdlog2 = -0.334200253537533, pmix = 0.3), value = 44.2079824669256, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.01596678568366, -0.417719976164404, 0.355566795496601, -0.0227070283941919, -3.71066812352201, -0.417719976164404, 4.08011017928992, 1.92759745001563, 0.209859003102214, 1.21595140513363, 
    0.355566795496601, 1.92759745001563, 11.2200049169097, 0.305380836107699, -3.54125431450658, -0.0227070283941919, 0.209859003102214, 0.305380836107699, 13.1099265769319, 0.473756761924852, -3.71066812352201, 1.21595140513363, -3.54125431450658, 0.473756761924852, 14.4223658096976)), est = c(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, sdlog1 = 1.27700727028162, sdlog2 = 0.715910404280703), pars = list(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, 
        log_sdlog1 = 0.244519270285268, log_sdlog2 = -0.334200253537533), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0403453011819949, log_scale = 3.56060029650164), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.18695514873387, log_scale = 3.50227796541358), value = 44.1529874803777, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.3139940408785, -4.9874260353886, -4.9874260353886, 14.5340712022155)), est = c(scale = 33.1909737983211, shape = 1.20557321235233), pars = list(log_scale = 3.50227796541358, log_shape = 0.18695514873387), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,3.17476,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,TRUE,10,Boron,Pimephales promelas,18.3,Fish,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.347793754217606, log_scale = 3.09262434059783), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.277430462233145, log_scale = 3.16298819283177), value = 44.1844051391579, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.3513547229456, 13.197344545515, 13.197344545515, 13.1973382514882)), est = c(scale = 23.6411347541813, shape = 1.31973434457373), pars = list(log_scale = 3.16298819283177, log_shape = 0.277430462233145), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.354906869806067), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), value = 46.6778177990908, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(6.97932406875603, -4.4109512522487, -4.4109512522487, 23.5210817167262)), est = c(locationlog = 2.45095092520366, scalelog = 1.19699830659697), pars = list(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.70148046008604), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), value = 44.8068237391937, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.70755613219043, 0.110062370784643, 0.110062370784643, 14.3477071950677)), est = c(locationlog = 3.08612119576206, scalelog = 0.585534345569591), pars = list(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04610984020903, log_sdlog = 0.104996151384988), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), value = 44.8826533078709, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.9874790685385, -9.13810438523545e-07, -9.13810438523545e-07, 20.0000177849704)), est = c(meanlog = 3.01595038767856, sdlog = 1.05482655382095), pars = list(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.24404647320555, log_sdlog1 = -0.0740119078270196, meanlog2 = 3.8481732072125, log_sdlog2 = -0.528291412471149, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.14758312942008, log_sdlog1 = 0.244519270285268, meanlog2 = 3.34961017263854, log_sdlog2 = -0.334200253537533, pmix = 0.3), value = 44.2079824669256, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.01596678568366, -0.417719976164404, 0.355566795496601, -0.0227070283941919, -3.71066812352201, -0.417719976164404, 4.08011017928992, 1.92759745001563, 0.209859003102214, 1.21595140513363, 
    0.355566795496601, 1.92759745001563, 11.2200049169097, 0.305380836107699, -3.54125431450658, -0.0227070283941919, 0.209859003102214, 0.305380836107699, 13.1099265769319, 0.473756761924852, -3.71066812352201, 1.21595140513363, -3.54125431450658, 0.473756761924852, 14.4223658096976)), est = c(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, sdlog1 = 1.27700727028162, sdlog2 = 0.715910404280703), pars = list(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, 
        log_sdlog1 = 0.244519270285268, log_sdlog2 = -0.334200253537533), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0403453011819949, log_scale = 3.56060029650164), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.18695514873387, log_scale = 3.50227796541358), value = 44.1529874803777, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.3139940408785, -4.9874260353886, -4.9874260353886, 14.5340712022155)), est = c(scale = 33.1909737983211, shape = 1.20557321235233), pars = list(log_scale = 3.50227796541358, log_shape = 0.18695514873387), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,3.17476,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,TRUE,10,Boron,Selenastrum capricornutum,12.3,Plant,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.347793754217606, log_scale = 3.09262434059783), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.277430462233145, log_scale = 3.16298819283177), value = 44.1844051391579, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.3513547229456, 13.197344545515, 13.197344545515, 13.1973382514882)), est = c(scale = 23.6411347541813, shape = 1.31973434457373), pars = list(log_scale = 3.16298819283177, log_shape = 0.277430462233145), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.354906869806067), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), value = 46.6778177990908, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(6.97932406875603, -4.4109512522487, -4.4109512522487, 23.5210817167262)), est = c(locationlog = 2.45095092520366, scalelog = 1.19699830659697), pars = list(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.70148046008604), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), value = 44.8068237391937, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.70755613219043, 0.110062370784643, 0.110062370784643, 14.3477071950677)), est = c(locationlog = 3.08612119576206, scalelog = 0.585534345569591), pars = list(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04610984020903, log_sdlog = 0.104996151384988), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), value = 44.8826533078709, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.9874790685385, -9.13810438523545e-07, -9.13810438523545e-07, 20.0000177849704)), est = c(meanlog = 3.01595038767856, sdlog = 1.05482655382095), pars = list(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.24404647320555, log_sdlog1 = -0.0740119078270196, meanlog2 = 3.8481732072125, log_sdlog2 = -0.528291412471149, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.14758312942008, log_sdlog1 = 0.244519270285268, meanlog2 = 3.34961017263854, log_sdlog2 = -0.334200253537533, pmix = 0.3), value = 44.2079824669256, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.01596678568366, -0.417719976164404, 0.355566795496601, -0.0227070283941919, -3.71066812352201, -0.417719976164404, 4.08011017928992, 1.92759745001563, 0.209859003102214, 1.21595140513363, 
    0.355566795496601, 1.92759745001563, 11.2200049169097, 0.305380836107699, -3.54125431450658, -0.0227070283941919, 0.209859003102214, 0.305380836107699, 13.1099265769319, 0.473756761924852, -3.71066812352201, 1.21595140513363, -3.54125431450658, 0.473756761924852, 14.4223658096976)), est = c(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, sdlog1 = 1.27700727028162, sdlog2 = 0.715910404280703), pars = list(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, 
        log_sdlog1 = 0.244519270285268, log_sdlog2 = -0.334200253537533), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0403453011819949, log_scale = 3.56060029650164), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.18695514873387, log_scale = 3.50227796541358), value = 44.1529874803777, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.3139940408785, -4.9874260353886, -4.9874260353886, 14.5340712022155)), est = c(scale = 33.1909737983211, shape = 1.20557321235233), pars = list(log_scale = 3.50227796541358, log_shape = 0.18695514873387), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,3.17476,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,TRUE,10,Boron,Selenastrum capricornutum,12.3,Plant,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.347793754217606, log_scale = 3.09262434059783), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.277430462233145, log_scale = 3.16298819283177), value = 44.1844051391579, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.3513547229456, 13.197344545515, 13.197344545515, 13.1973382514882)), est = c(scale = 23.6411347541813, shape = 1.31973434457373), pars = list(log_scale = 3.16298819283177, log_shape = 0.277430462233145), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.354906869806067), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), value = 46.6778177990908, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(6.97932406875603, -4.4109512522487, -4.4109512522487, 23.5210817167262)), est = c(locationlog = 2.45095092520366, scalelog = 1.19699830659697), pars = list(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.70148046008604), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), value = 44.8068237391937, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.70755613219043, 0.110062370784643, 0.110062370784643, 14.3477071950677)), est = c(locationlog = 3.08612119576206, scalelog = 0.585534345569591), pars = list(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04610984020903, log_sdlog = 0.104996151384988), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), value = 44.8826533078709, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.9874790685385, -9.13810438523545e-07, -9.13810438523545e-07, 20.0000177849704)), est = c(meanlog = 3.01595038767856, sdlog = 1.05482655382095), pars = list(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.24404647320555, log_sdlog1 = -0.0740119078270196, meanlog2 = 3.8481732072125, log_sdlog2 = -0.528291412471149, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.14758312942008, log_sdlog1 = 0.244519270285268, meanlog2 = 3.34961017263854, log_sdlog2 = -0.334200253537533, pmix = 0.3), value = 44.2079824669256, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.01596678568366, -0.417719976164404, 0.355566795496601, -0.0227070283941919, -3.71066812352201, -0.417719976164404, 4.08011017928992, 1.92759745001563, 0.209859003102214, 1.21595140513363, 
    0.355566795496601, 1.92759745001563, 11.2200049169097, 0.305380836107699, -3.54125431450658, -0.0227070283941919, 0.209859003102214, 0.305380836107699, 13.1099265769319, 0.473756761924852, -3.71066812352201, 1.21595140513363, -3.54125431450658, 0.473756761924852, 14.4223658096976)), est = c(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, sdlog1 = 1.27700727028162, sdlog2 = 0.715910404280703), pars = list(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, 
        log_sdlog1 = 0.244519270285268, log_sdlog2 = -0.334200253537533), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0403453011819949, log_scale = 3.56060029650164), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.18695514873387, log_scale = 3.50227796541358), value = 44.1529874803777, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.3139940408785, -4.9874260353886, -4.9874260353886, 14.5340712022155)), est = c(scale = 33.1909737983211, shape = 1.20557321235233), pars = list(log_scale = 3.50227796541358, log_shape = 0.18695514873387), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,3.17476,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,TRUE,10,Boron,Rana sylvatica,70.7,Amphibian,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.347793754217606, log_scale = 3.09262434059783), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.277430462233145, log_scale = 3.16298819283177), value = 44.1844051391579, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.3513547229456, 13.197344545515, 13.197344545515, 13.1973382514882)), est = c(scale = 23.6411347541813, shape = 1.31973434457373), pars = list(log_scale = 3.16298819283177, log_shape = 0.277430462233145), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.354906869806067), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), value = 46.6778177990908, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(6.97932406875603, -4.4109512522487, -4.4109512522487, 23.5210817167262)), est = c(locationlog = 2.45095092520366, scalelog = 1.19699830659697), pars = list(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.70148046008604), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), value = 44.8068237391937, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.70755613219043, 0.110062370784643, 0.110062370784643, 14.3477071950677)), est = c(locationlog = 3.08612119576206, scalelog = 0.585534345569591), pars = list(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04610984020903, log_sdlog = 0.104996151384988), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), value = 44.8826533078709, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.9874790685385, -9.13810438523545e-07, -9.13810438523545e-07, 20.0000177849704)), est = c(meanlog = 3.01595038767856, sdlog = 1.05482655382095), pars = list(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.24404647320555, log_sdlog1 = -0.0740119078270196, meanlog2 = 3.8481732072125, log_sdlog2 = -0.528291412471149, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.14758312942008, log_sdlog1 = 0.244519270285268, meanlog2 = 3.34961017263854, log_sdlog2 = -0.334200253537533, pmix = 0.3), value = 44.2079824669256, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.01596678568366, -0.417719976164404, 0.355566795496601, -0.0227070283941919, -3.71066812352201, -0.417719976164404, 4.08011017928992, 1.92759745001563, 0.209859003102214, 1.21595140513363, 
    0.355566795496601, 1.92759745001563, 11.2200049169097, 0.305380836107699, -3.54125431450658, -0.0227070283941919, 0.209859003102214, 0.305380836107699, 13.1099265769319, 0.473756761924852, -3.71066812352201, 1.21595140513363, -3.54125431450658, 0.473756761924852, 14.4223658096976)), est = c(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, sdlog1 = 1.27700727028162, sdlog2 = 0.715910404280703), pars = list(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, 
        log_sdlog1 = 0.244519270285268, log_sdlog2 = -0.334200253537533), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0403453011819949, log_scale = 3.56060029650164), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.18695514873387, log_scale = 3.50227796541358), value = 44.1529874803777, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.3139940408785, -4.9874260353886, -4.9874260353886, 14.5340712022155)), est = c(scale = 33.1909737983211, shape = 1.20557321235233), pars = list(log_scale = 3.50227796541358, log_shape = 0.18695514873387), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,3.17476,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,TRUE,10,Boron,Pimephales promelas,18.3,Fish,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.347793754217606, log_scale = 3.09262434059783), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.277430462233145, log_scale = 3.16298819283177), value = 44.1844051391579, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.3513547229456, 13.197344545515, 13.197344545515, 13.1973382514882)), est = c(scale = 23.6411347541813, shape = 1.31973434457373), pars = list(log_scale = 3.16298819283177, log_shape = 0.277430462233145), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.354906869806067), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), value = 46.6778177990908, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(6.97932406875603, -4.4109512522487, -4.4109512522487, 23.5210817167262)), est = c(locationlog = 2.45095092520366, scalelog = 1.19699830659697), pars = list(locationlog = 2.45095092520366, log_scalelog = 0.179817011868879), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 3.01595033684062, log_scalelog = 0.70148046008604), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), value = 44.8068237391937, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.70755613219043, 0.110062370784643, 0.110062370784643, 14.3477071950677)), est = c(locationlog = 3.08612119576206, scalelog = 0.585534345569591), pars = list(locationlog = 3.08612119576206, log_scalelog = -0.535230437426396), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 3.04610984020903, log_sdlog = 0.104996151384988), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), value = 44.8826533078709, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.9874790685385, -9.13810438523545e-07, -9.13810438523545e-07, 20.0000177849704)), est = c(meanlog = 3.01595038767856, sdlog = 1.05482655382095), pars = list(meanlog = 3.01595038767856, log_sdlog = 0.0533763494510352), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.24404647320555, log_sdlog1 = -0.0740119078270196, meanlog2 = 3.8481732072125, log_sdlog2 = -0.528291412471149, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.14758312942008, log_sdlog1 = 0.244519270285268, meanlog2 = 3.34961017263854, log_sdlog2 = -0.334200253537533, pmix = 0.3), value = 44.2079824669256, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.01596678568366, -0.417719976164404, 0.355566795496601, -0.0227070283941919, -3.71066812352201, -0.417719976164404, 4.08011017928992, 1.92759745001563, 0.209859003102214, 1.21595140513363, 
    0.355566795496601, 1.92759745001563, 11.2200049169097, 0.305380836107699, -3.54125431450658, -0.0227070283941919, 0.209859003102214, 0.305380836107699, 13.1099265769319, 0.473756761924852, -3.71066812352201, 1.21595140513363, -3.54125431450658, 0.473756761924852, 14.4223658096976)), est = c(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, sdlog1 = 1.27700727028162, sdlog2 = 0.715910404280703), pars = list(meanlog1 = 2.14758312942008, meanlog2 = 3.34961017263854, pmix = 0.3, 
        log_sdlog1 = 0.244519270285268, log_sdlog2 = -0.334200253537533), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0403453011819949, log_scale = 3.56060029650164), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.18695514873387, log_scale = 3.50227796541358), value = 44.1529874803777, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.3139940408785, -4.9874260353886, -4.9874260353886, 14.5340712022155)), est = c(scale = 33.1909737983211, shape = 1.20557321235233), pars = list(log_scale = 3.50227796541358, log_shape = 0.18695514873387), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,3.17476,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,FALSE,5,Boron,Ceriodaphnia dubia,13.4,Invertebrate,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.0709197252160534, log_scale = 3.24979040553342), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.0521592425383351, log_scale = 3.26855155991363), value = 21.5992656601237, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.46296482004847, 5.26771792946124, 5.26771792946124, 5.26771483009887)), est = c(scale = 26.2732565316286, shape = 1.05354349809698), pars = list(log_scale = 3.26855155991363, log_shape = 0.0521592425383351), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.77612272973549, log_scalelog = 0.57027707940964), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.1200530284664, log_scalelog = 0.270384762353549), value = 22.7357199201822, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.91149729564533, -1.90528186703927, -1.90528186703927, 10.6069930822592)), est = c(locationlog = 2.1200530284664, scalelog = 1.31046857271574), pars = list(locationlog = 2.1200530284664, log_scalelog = 0.270384762353549), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.77612272973549, log_scalelog = 0.916850669689613), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.91423190972086, log_scalelog = -0.358099591288578), value = 22.0845690371308, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(3.4341246748476, 0.499769430597881, 0.499769430597881, 6.98558232421298)), est = c(locationlog = 2.91423190972086, scalelog = 0.699003456884912), pars = list(locationlog = 2.91423190972086, log_scalelog = -0.358099591288578), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.80388395703284, log_sdlog = 0.318212658892525), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.77612369904032, log_sdlog = 0.209854445232504), value = 22.0245820772907, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(3.2861906012625, -6.37064291894443e-06, -6.37064291894443e-06, 10.0000208123868)), est = c(meanlog = 2.77612369904032, sdlog = 1.2334985053014), pars = list(meanlog = 2.77612369904032, log_sdlog = 0.209854445232504), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 1.60743589278879, log_sdlog1 = 0.346797650585182, meanlog2 = 3.60151599986222, log_sdlog2 = -0.38706149063331, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 1.99034570838894, log_sdlog1 = 0.286683257635471, meanlog2 = 3.42087489998547, log_sdlog2 = -0.468459653346944, pmix = 0.5), value = 21.4511625063483, counts = c(`function` = 12, gradient = 12), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(0.788287469394661, -0.324135693935862, 0.165005130909078, 0.0594500270465814, -2.20979842699074, -0.324135693935862, 3.66513096540675, 1.26819419195667, 0.0914235746740809, -0.218632324075823, 
    0.165005130909078, 1.26819419195667, 4.72779943553958, 0.0727084770916568, -1.68100125418813, 0.0594500270465814, 0.0914235746740809, 0.0727084770916568, 5.0296202426585, 0.374586123416823, -2.20979842699074, -0.218632324075823, -1.68100125418813, 0.374586123416823, 7.1953556775653)), est = c(meanlog1 = 1.99034570838894, meanlog2 = 3.42087489998547, pmix = 0.5, sdlog1 = 1.3320022451109, sdlog2 = 0.625965730277033), pars = list(meanlog1 = 1.99034570838894, meanlog2 = 3.42087489998547, pmix = 0.5, 
        log_sdlog1 = 0.286683257635471, log_sdlog2 = -0.468459653346944), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.303299271682075, log_scale = 3.44094063661029), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.0577489899484726, log_scale = 3.34232414948968), value = 21.5911767141402, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.41414873904661, -2.11963745345901, -2.11963745345901, 5.6121626115933)), est = c(scale = 28.2847884486368, shape = 1.05944902997604), pars = list(log_scale = 3.34232414948968, log_shape = 0.0577489899484726), flags = list(at_boundary = FALSE, computable = TRUE)))",lnorm_lnorm,0.05,1.32752,NA,NA,NA,1,0.95,cdf,percentile,parametric,0,1,lnorm_lnorm,numeric(0)
2,1,FALSE,5,Boron,Myriophyllum spicatum,34.2,Plant,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.0709197252160534, log_scale = 3.24979040553342), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.0521592425383351, log_scale = 3.26855155991363), value = 21.5992656601237, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.46296482004847, 5.26771792946124, 5.26771792946124, 5.26771483009887)), est = c(scale = 26.2732565316286, shape = 1.05354349809698), pars = list(log_scale = 3.26855155991363, log_shape = 0.0521592425383351), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.77612272973549, log_scalelog = 0.57027707940964), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.1200530284664, log_scalelog = 0.270384762353549), value = 22.7357199201822, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.91149729564533, -1.90528186703927, -1.90528186703927, 10.6069930822592)), est = c(locationlog = 2.1200530284664, scalelog = 1.31046857271574), pars = list(locationlog = 2.1200530284664, log_scalelog = 0.270384762353549), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.77612272973549, log_scalelog = 0.916850669689613), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.91423190972086, log_scalelog = -0.358099591288578), value = 22.0845690371308, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(3.4341246748476, 0.499769430597881, 0.499769430597881, 6.98558232421298)), est = c(locationlog = 2.91423190972086, scalelog = 0.699003456884912), pars = list(locationlog = 2.91423190972086, log_scalelog = -0.358099591288578), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.80388395703284, log_sdlog = 0.318212658892525), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.77612369904032, log_sdlog = 0.209854445232504), value = 22.0245820772907, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(3.2861906012625, -6.37064291894443e-06, -6.37064291894443e-06, 10.0000208123868)), est = c(meanlog = 2.77612369904032, sdlog = 1.2334985053014), pars = list(meanlog = 2.77612369904032, log_sdlog = 0.209854445232504), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 1.60743589278879, log_sdlog1 = 0.346797650585182, meanlog2 = 3.60151599986222, log_sdlog2 = -0.38706149063331, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 1.99034570838894, log_sdlog1 = 0.286683257635471, meanlog2 = 3.42087489998547, log_sdlog2 = -0.468459653346944, pmix = 0.5), value = 21.4511625063483, counts = c(`function` = 12, gradient = 12), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(0.788287469394661, -0.324135693935862, 0.165005130909078, 0.0594500270465814, -2.20979842699074, -0.324135693935862, 3.66513096540675, 1.26819419195667, 0.0914235746740809, -0.218632324075823, 
    0.165005130909078, 1.26819419195667, 4.72779943553958, 0.0727084770916568, -1.68100125418813, 0.0594500270465814, 0.0914235746740809, 0.0727084770916568, 5.0296202426585, 0.374586123416823, -2.20979842699074, -0.218632324075823, -1.68100125418813, 0.374586123416823, 7.1953556775653)), est = c(meanlog1 = 1.99034570838894, meanlog2 = 3.42087489998547, pmix = 0.5, sdlog1 = 1.3320022451109, sdlog2 = 0.625965730277033), pars = list(meanlog1 = 1.99034570838894, meanlog2 = 3.42087489998547, pmix = 0.5, 
        log_sdlog1 = 0.286683257635471, log_sdlog2 = -0.468459653346944), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.303299271682075, log_scale = 3.44094063661029), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.0577489899484726, log_scale = 3.34232414948968), value = 21.5911767141402, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.41414873904661, -2.11963745345901, -2.11963745345901, 5.6121626115933)), est = c(scale = 28.2847884486368, shape = 1.05944902997604), pars = list(log_scale = 3.34232414948968, log_shape = 0.0577489899484726), flags = list(at_boundary = FALSE, computable = TRUE)))",lnorm_lnorm,0.05,1.32752,NA,NA,NA,1,0.95,cdf,percentile,parametric,0,1,lnorm_lnorm,numeric(0)
2,1,FALSE,5,Boron,Rana sylvatica,70.7,Amphibian,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.0709197252160534, log_scale = 3.24979040553342), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.0521592425383351, log_scale = 3.26855155991363), value = 21.5992656601237, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.46296482004847, 5.26771792946124, 5.26771792946124, 5.26771483009887)), est = c(scale = 26.2732565316286, shape = 1.05354349809698), pars = list(log_scale = 3.26855155991363, log_shape = 0.0521592425383351), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.77612272973549, log_scalelog = 0.57027707940964), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.1200530284664, log_scalelog = 0.270384762353549), value = 22.7357199201822, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.91149729564533, -1.90528186703927, -1.90528186703927, 10.6069930822592)), est = c(locationlog = 2.1200530284664, scalelog = 1.31046857271574), pars = list(locationlog = 2.1200530284664, log_scalelog = 0.270384762353549), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.77612272973549, log_scalelog = 0.916850669689613), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.91423190972086, log_scalelog = -0.358099591288578), value = 22.0845690371308, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(3.4341246748476, 0.499769430597881, 0.499769430597881, 6.98558232421298)), est = c(locationlog = 2.91423190972086, scalelog = 0.699003456884912), pars = list(locationlog = 2.91423190972086, log_scalelog = -0.358099591288578), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.80388395703284, log_sdlog = 0.318212658892525), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.77612369904032, log_sdlog = 0.209854445232504), value = 22.0245820772907, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(3.2861906012625, -6.37064291894443e-06, -6.37064291894443e-06, 10.0000208123868)), est = c(meanlog = 2.77612369904032, sdlog = 1.2334985053014), pars = list(meanlog = 2.77612369904032, log_sdlog = 0.209854445232504), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 1.60743589278879, log_sdlog1 = 0.346797650585182, meanlog2 = 3.60151599986222, log_sdlog2 = -0.38706149063331, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 1.99034570838894, log_sdlog1 = 0.286683257635471, meanlog2 = 3.42087489998547, log_sdlog2 = -0.468459653346944, pmix = 0.5), value = 21.4511625063483, counts = c(`function` = 12, gradient = 12), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(0.788287469394661, -0.324135693935862, 0.165005130909078, 0.0594500270465814, -2.20979842699074, -0.324135693935862, 3.66513096540675, 1.26819419195667, 0.0914235746740809, -0.218632324075823, 
    0.165005130909078, 1.26819419195667, 4.72779943553958, 0.0727084770916568, -1.68100125418813, 0.0594500270465814, 0.0914235746740809, 0.0727084770916568, 5.0296202426585, 0.374586123416823, -2.20979842699074, -0.218632324075823, -1.68100125418813, 0.374586123416823, 7.1953556775653)), est = c(meanlog1 = 1.99034570838894, meanlog2 = 3.42087489998547, pmix = 0.5, sdlog1 = 1.3320022451109, sdlog2 = 0.625965730277033), pars = list(meanlog1 = 1.99034570838894, meanlog2 = 3.42087489998547, pmix = 0.5, 
        log_sdlog1 = 0.286683257635471, log_sdlog2 = -0.468459653346944), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.303299271682075, log_scale = 3.44094063661029), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.0577489899484726, log_scale = 3.34232414948968), value = 21.5911767141402, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.41414873904661, -2.11963745345901, -2.11963745345901, 5.6121626115933)), est = c(scale = 28.2847884486368, shape = 1.05944902997604), pars = list(log_scale = 3.34232414948968, log_shape = 0.0577489899484726), flags = list(at_boundary = FALSE, computable = TRUE)))",lnorm_lnorm,0.05,1.32752,NA,NA,NA,1,0.95,cdf,percentile,parametric,0,1,lnorm_lnorm,numeric(0)
2,1,FALSE,5,Boron,Spirodella polyrrhiza,1.8,Plant,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.0709197252160534, log_scale = 3.24979040553342), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.0521592425383351, log_scale = 3.26855155991363), value = 21.5992656601237, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.46296482004847, 5.26771792946124, 5.26771792946124, 5.26771483009887)), est = c(scale = 26.2732565316286, shape = 1.05354349809698), pars = list(log_scale = 3.26855155991363, log_shape = 0.0521592425383351), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.77612272973549, log_scalelog = 0.57027707940964), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.1200530284664, log_scalelog = 0.270384762353549), value = 22.7357199201822, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.91149729564533, -1.90528186703927, -1.90528186703927, 10.6069930822592)), est = c(locationlog = 2.1200530284664, scalelog = 1.31046857271574), pars = list(locationlog = 2.1200530284664, log_scalelog = 0.270384762353549), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.77612272973549, log_scalelog = 0.916850669689613), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.91423190972086, log_scalelog = -0.358099591288578), value = 22.0845690371308, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(3.4341246748476, 0.499769430597881, 0.499769430597881, 6.98558232421298)), est = c(locationlog = 2.91423190972086, scalelog = 0.699003456884912), pars = list(locationlog = 2.91423190972086, log_scalelog = -0.358099591288578), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.80388395703284, log_sdlog = 0.318212658892525), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.77612369904032, log_sdlog = 0.209854445232504), value = 22.0245820772907, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(3.2861906012625, -6.37064291894443e-06, -6.37064291894443e-06, 10.0000208123868)), est = c(meanlog = 2.77612369904032, sdlog = 1.2334985053014), pars = list(meanlog = 2.77612369904032, log_sdlog = 0.209854445232504), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 1.60743589278879, log_sdlog1 = 0.346797650585182, meanlog2 = 3.60151599986222, log_sdlog2 = -0.38706149063331, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 1.99034570838894, log_sdlog1 = 0.286683257635471, meanlog2 = 3.42087489998547, log_sdlog2 = -0.468459653346944, pmix = 0.5), value = 21.4511625063483, counts = c(`function` = 12, gradient = 12), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(0.788287469394661, -0.324135693935862, 0.165005130909078, 0.0594500270465814, -2.20979842699074, -0.324135693935862, 3.66513096540675, 1.26819419195667, 0.0914235746740809, -0.218632324075823, 
    0.165005130909078, 1.26819419195667, 4.72779943553958, 0.0727084770916568, -1.68100125418813, 0.0594500270465814, 0.0914235746740809, 0.0727084770916568, 5.0296202426585, 0.374586123416823, -2.20979842699074, -0.218632324075823, -1.68100125418813, 0.374586123416823, 7.1953556775653)), est = c(meanlog1 = 1.99034570838894, meanlog2 = 3.42087489998547, pmix = 0.5, sdlog1 = 1.3320022451109, sdlog2 = 0.625965730277033), pars = list(meanlog1 = 1.99034570838894, meanlog2 = 3.42087489998547, pmix = 0.5, 
        log_sdlog1 = 0.286683257635471, log_sdlog2 = -0.468459653346944), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.303299271682075, log_scale = 3.44094063661029), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.0577489899484726, log_scale = 3.34232414948968), value = 21.5911767141402, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.41414873904661, -2.11963745345901, -2.11963745345901, 5.6121626115933)), est = c(scale = 28.2847884486368, shape = 1.05944902997604), pars = list(log_scale = 3.34232414948968, log_shape = 0.0577489899484726), flags = list(at_boundary = FALSE, computable = TRUE)))",lnorm_lnorm,0.05,1.32752,NA,NA,NA,1,0.95,cdf,percentile,parametric,0,1,lnorm_lnorm,numeric(0)
2,1,FALSE,5,Boron,Pimephales promelas,18.3,Fish,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.0709197252160534, log_scale = 3.24979040553342), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.0521592425383351, log_scale = 3.26855155991363), value = 21.5992656601237, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.46296482004847, 5.26771792946124, 5.26771792946124, 5.26771483009887)), est = c(scale = 26.2732565316286, shape = 1.05354349809698), pars = list(log_scale = 3.26855155991363, log_shape = 0.0521592425383351), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.77612272973549, log_scalelog = 0.57027707940964), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.1200530284664, log_scalelog = 0.270384762353549), value = 22.7357199201822, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(2.91149729564533, -1.90528186703927, -1.90528186703927, 10.6069930822592)), est = c(locationlog = 2.1200530284664, scalelog = 1.31046857271574), pars = list(locationlog = 2.1200530284664, log_scalelog = 0.270384762353549), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.77612272973549, log_scalelog = 0.916850669689613), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.91423190972086, log_scalelog = -0.358099591288578), value = 22.0845690371308, counts = c(`function` = 8, gradient = 8), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(3.4341246748476, 0.499769430597881, 0.499769430597881, 6.98558232421298)), est = c(locationlog = 2.91423190972086, scalelog = 0.699003456884912), pars = list(locationlog = 2.91423190972086, log_scalelog = -0.358099591288578), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.80388395703284, log_sdlog = 0.318212658892525), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.77612369904032, log_sdlog = 0.209854445232504), value = 22.0245820772907, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(3.2861906012625, -6.37064291894443e-06, -6.37064291894443e-06, 10.0000208123868)), est = c(meanlog = 2.77612369904032, sdlog = 1.2334985053014), pars = list(meanlog = 2.77612369904032, log_sdlog = 0.209854445232504), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 1.60743589278879, log_sdlog1 = 0.346797650585182, meanlog2 = 3.60151599986222, log_sdlog2 = -0.38706149063331, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 1.99034570838894, log_sdlog1 = 0.286683257635471, meanlog2 = 3.42087489998547, log_sdlog2 = -0.468459653346944, pmix = 0.5), value = 21.4511625063483, counts = c(`function` = 12, gradient = 12), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(0.788287469394661, -0.324135693935862, 0.165005130909078, 0.0594500270465814, -2.20979842699074, -0.324135693935862, 3.66513096540675, 1.26819419195667, 0.0914235746740809, -0.218632324075823, 
    0.165005130909078, 1.26819419195667, 4.72779943553958, 0.0727084770916568, -1.68100125418813, 0.0594500270465814, 0.0914235746740809, 0.0727084770916568, 5.0296202426585, 0.374586123416823, -2.20979842699074, -0.218632324075823, -1.68100125418813, 0.374586123416823, 7.1953556775653)), est = c(meanlog1 = 1.99034570838894, meanlog2 = 3.42087489998547, pmix = 0.5, sdlog1 = 1.3320022451109, sdlog2 = 0.625965730277033), pars = list(meanlog1 = 1.99034570838894, meanlog2 = 3.42087489998547, pmix = 0.5, 
        log_sdlog1 = 0.286683257635471, log_sdlog2 = -0.468459653346944), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.303299271682075, log_scale = 3.44094063661029), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.0577489899484726, log_scale = 3.34232414948968), value = 21.5911767141402, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(8.41414873904661, -2.11963745345901, -2.11963745345901, 5.6121626115933)), est = c(scale = 28.2847884486368, shape = 1.05944902997604), pars = list(log_scale = 3.34232414948968, log_shape = 0.0577489899484726), flags = list(at_boundary = FALSE, computable = TRUE)))",lnorm_lnorm,0.05,1.32752,NA,NA,NA,1,0.95,cdf,percentile,parametric,0,1,lnorm_lnorm,numeric(0)
2,1,FALSE,10,Boron,Ceriodaphnia dubia,13.4,Invertebrate,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.296961095837491, log_scale = 3.0921637045904), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.261440996953924, log_scale = 3.12768679876144), value = 43.6947412117056, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.1578440455155, 12.9880041437013, 12.9880041437013, 12.9879663232819)), est = c(scale = 22.8211285756601, shape = 1.29880030613677), pars = list(log_scale = 3.12768679876144, log_shape = 0.261440996953924), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.352240607534656), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), value = 45.9330602035977, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.2733281997642, -4.46045016373558, -4.46045016373558, 23.2160273096977)), est = c(locationlog = 2.39783588813966, scalelog = 1.17255556905755), pars = list(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.698814197814629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), value = 44.256651435281, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.48684532860544, 0.0875077924964762, 0.0875077924964762, 14.4456093113738)), est = c(locationlog = 3.01880130017102, scalelog = 0.590352831830035), pars = list(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.98670299513176, log_sdlog = 0.10235655173629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), value = 44.2678041002333, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.03553302961929, -8.90233683405559e-07, -8.90233683405559e-07, 20.0000177800354)), est = c(meanlog = 2.95713172761119, sdlog = 1.05201785573431), pars = list(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.16206173752339, log_sdlog1 = -0.125798239499222, meanlog2 = 3.81134425274013, log_sdlog2 = -0.556825392185898, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.10056111509066, log_sdlog1 = 0.205450849919085, meanlog2 = 3.29666779842978, log_sdlog2 = -0.306715469257007, pmix = 0.3), value = 43.7405806968797, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.10806901294958, -0.534157452938338, 0.372742203584499, -0.0953397439732499, -3.845106624433, -0.534157452938338, 3.96201126055292, 1.99526595742094, 0.201699249151078, 1.09304102786659, 
    0.372742203584499, 1.99526595742094, 10.3372574319162, 0.633396133716582, -3.98711529205142, -0.0953397439732499, 0.201699249151078, 0.633396133716582, 12.388720589456, 0.792657683189083, -3.845106624433, 1.09304102786659, -3.98711529205142, 0.792657683189083, 14.4747599477348)), est = c(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, sdlog1 = 1.22807861931498, sdlog2 = 0.735859945900444), pars = list(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, 
        log_sdlog1 = 0.205450849919085, log_sdlog2 = -0.306715469257007), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0261006526172895, log_scale = 3.49407828676558), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.169571830144152, log_scale = 3.44710520115741), value = 43.6807922745908, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.5449756612725, -4.97000758937715, -4.97000758937715, 14.0374532123274)), est = c(scale = 31.4093368667314, shape = 1.18479744814816), pars = list(log_scale = 3.44710520115741, log_shape = 0.169571830144152), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,2.95574,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,FALSE,10,Boron,Myriophyllum spicatum,34.2,Plant,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.296961095837491, log_scale = 3.0921637045904), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.261440996953924, log_scale = 3.12768679876144), value = 43.6947412117056, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.1578440455155, 12.9880041437013, 12.9880041437013, 12.9879663232819)), est = c(scale = 22.8211285756601, shape = 1.29880030613677), pars = list(log_scale = 3.12768679876144, log_shape = 0.261440996953924), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.352240607534656), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), value = 45.9330602035977, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.2733281997642, -4.46045016373558, -4.46045016373558, 23.2160273096977)), est = c(locationlog = 2.39783588813966, scalelog = 1.17255556905755), pars = list(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.698814197814629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), value = 44.256651435281, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.48684532860544, 0.0875077924964762, 0.0875077924964762, 14.4456093113738)), est = c(locationlog = 3.01880130017102, scalelog = 0.590352831830035), pars = list(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.98670299513176, log_sdlog = 0.10235655173629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), value = 44.2678041002333, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.03553302961929, -8.90233683405559e-07, -8.90233683405559e-07, 20.0000177800354)), est = c(meanlog = 2.95713172761119, sdlog = 1.05201785573431), pars = list(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.16206173752339, log_sdlog1 = -0.125798239499222, meanlog2 = 3.81134425274013, log_sdlog2 = -0.556825392185898, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.10056111509066, log_sdlog1 = 0.205450849919085, meanlog2 = 3.29666779842978, log_sdlog2 = -0.306715469257007, pmix = 0.3), value = 43.7405806968797, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.10806901294958, -0.534157452938338, 0.372742203584499, -0.0953397439732499, -3.845106624433, -0.534157452938338, 3.96201126055292, 1.99526595742094, 0.201699249151078, 1.09304102786659, 
    0.372742203584499, 1.99526595742094, 10.3372574319162, 0.633396133716582, -3.98711529205142, -0.0953397439732499, 0.201699249151078, 0.633396133716582, 12.388720589456, 0.792657683189083, -3.845106624433, 1.09304102786659, -3.98711529205142, 0.792657683189083, 14.4747599477348)), est = c(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, sdlog1 = 1.22807861931498, sdlog2 = 0.735859945900444), pars = list(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, 
        log_sdlog1 = 0.205450849919085, log_sdlog2 = -0.306715469257007), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0261006526172895, log_scale = 3.49407828676558), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.169571830144152, log_scale = 3.44710520115741), value = 43.6807922745908, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.5449756612725, -4.97000758937715, -4.97000758937715, 14.0374532123274)), est = c(scale = 31.4093368667314, shape = 1.18479744814816), pars = list(log_scale = 3.44710520115741, log_shape = 0.169571830144152), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,2.95574,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,FALSE,10,Boron,Rana sylvatica,70.7,Amphibian,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.296961095837491, log_scale = 3.0921637045904), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.261440996953924, log_scale = 3.12768679876144), value = 43.6947412117056, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.1578440455155, 12.9880041437013, 12.9880041437013, 12.9879663232819)), est = c(scale = 22.8211285756601, shape = 1.29880030613677), pars = list(log_scale = 3.12768679876144, log_shape = 0.261440996953924), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.352240607534656), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), value = 45.9330602035977, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.2733281997642, -4.46045016373558, -4.46045016373558, 23.2160273096977)), est = c(locationlog = 2.39783588813966, scalelog = 1.17255556905755), pars = list(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.698814197814629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), value = 44.256651435281, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.48684532860544, 0.0875077924964762, 0.0875077924964762, 14.4456093113738)), est = c(locationlog = 3.01880130017102, scalelog = 0.590352831830035), pars = list(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.98670299513176, log_sdlog = 0.10235655173629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), value = 44.2678041002333, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.03553302961929, -8.90233683405559e-07, -8.90233683405559e-07, 20.0000177800354)), est = c(meanlog = 2.95713172761119, sdlog = 1.05201785573431), pars = list(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.16206173752339, log_sdlog1 = -0.125798239499222, meanlog2 = 3.81134425274013, log_sdlog2 = -0.556825392185898, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.10056111509066, log_sdlog1 = 0.205450849919085, meanlog2 = 3.29666779842978, log_sdlog2 = -0.306715469257007, pmix = 0.3), value = 43.7405806968797, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.10806901294958, -0.534157452938338, 0.372742203584499, -0.0953397439732499, -3.845106624433, -0.534157452938338, 3.96201126055292, 1.99526595742094, 0.201699249151078, 1.09304102786659, 
    0.372742203584499, 1.99526595742094, 10.3372574319162, 0.633396133716582, -3.98711529205142, -0.0953397439732499, 0.201699249151078, 0.633396133716582, 12.388720589456, 0.792657683189083, -3.845106624433, 1.09304102786659, -3.98711529205142, 0.792657683189083, 14.4747599477348)), est = c(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, sdlog1 = 1.22807861931498, sdlog2 = 0.735859945900444), pars = list(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, 
        log_sdlog1 = 0.205450849919085, log_sdlog2 = -0.306715469257007), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0261006526172895, log_scale = 3.49407828676558), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.169571830144152, log_scale = 3.44710520115741), value = 43.6807922745908, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.5449756612725, -4.97000758937715, -4.97000758937715, 14.0374532123274)), est = c(scale = 31.4093368667314, shape = 1.18479744814816), pars = list(log_scale = 3.44710520115741, log_shape = 0.169571830144152), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,2.95574,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,FALSE,10,Boron,Spirodella polyrrhiza,1.8,Plant,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.296961095837491, log_scale = 3.0921637045904), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.261440996953924, log_scale = 3.12768679876144), value = 43.6947412117056, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.1578440455155, 12.9880041437013, 12.9880041437013, 12.9879663232819)), est = c(scale = 22.8211285756601, shape = 1.29880030613677), pars = list(log_scale = 3.12768679876144, log_shape = 0.261440996953924), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.352240607534656), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), value = 45.9330602035977, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.2733281997642, -4.46045016373558, -4.46045016373558, 23.2160273096977)), est = c(locationlog = 2.39783588813966, scalelog = 1.17255556905755), pars = list(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.698814197814629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), value = 44.256651435281, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.48684532860544, 0.0875077924964762, 0.0875077924964762, 14.4456093113738)), est = c(locationlog = 3.01880130017102, scalelog = 0.590352831830035), pars = list(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.98670299513176, log_sdlog = 0.10235655173629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), value = 44.2678041002333, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.03553302961929, -8.90233683405559e-07, -8.90233683405559e-07, 20.0000177800354)), est = c(meanlog = 2.95713172761119, sdlog = 1.05201785573431), pars = list(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.16206173752339, log_sdlog1 = -0.125798239499222, meanlog2 = 3.81134425274013, log_sdlog2 = -0.556825392185898, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.10056111509066, log_sdlog1 = 0.205450849919085, meanlog2 = 3.29666779842978, log_sdlog2 = -0.306715469257007, pmix = 0.3), value = 43.7405806968797, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.10806901294958, -0.534157452938338, 0.372742203584499, -0.0953397439732499, -3.845106624433, -0.534157452938338, 3.96201126055292, 1.99526595742094, 0.201699249151078, 1.09304102786659, 
    0.372742203584499, 1.99526595742094, 10.3372574319162, 0.633396133716582, -3.98711529205142, -0.0953397439732499, 0.201699249151078, 0.633396133716582, 12.388720589456, 0.792657683189083, -3.845106624433, 1.09304102786659, -3.98711529205142, 0.792657683189083, 14.4747599477348)), est = c(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, sdlog1 = 1.22807861931498, sdlog2 = 0.735859945900444), pars = list(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, 
        log_sdlog1 = 0.205450849919085, log_sdlog2 = -0.306715469257007), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0261006526172895, log_scale = 3.49407828676558), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.169571830144152, log_scale = 3.44710520115741), value = 43.6807922745908, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.5449756612725, -4.97000758937715, -4.97000758937715, 14.0374532123274)), est = c(scale = 31.4093368667314, shape = 1.18479744814816), pars = list(log_scale = 3.44710520115741, log_shape = 0.169571830144152), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,2.95574,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,FALSE,10,Boron,Pimephales promelas,18.3,Fish,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.296961095837491, log_scale = 3.0921637045904), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.261440996953924, log_scale = 3.12768679876144), value = 43.6947412117056, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.1578440455155, 12.9880041437013, 12.9880041437013, 12.9879663232819)), est = c(scale = 22.8211285756601, shape = 1.29880030613677), pars = list(log_scale = 3.12768679876144, log_shape = 0.261440996953924), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.352240607534656), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), value = 45.9330602035977, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.2733281997642, -4.46045016373558, -4.46045016373558, 23.2160273096977)), est = c(locationlog = 2.39783588813966, scalelog = 1.17255556905755), pars = list(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.698814197814629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), value = 44.256651435281, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.48684532860544, 0.0875077924964762, 0.0875077924964762, 14.4456093113738)), est = c(locationlog = 3.01880130017102, scalelog = 0.590352831830035), pars = list(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.98670299513176, log_sdlog = 0.10235655173629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), value = 44.2678041002333, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.03553302961929, -8.90233683405559e-07, -8.90233683405559e-07, 20.0000177800354)), est = c(meanlog = 2.95713172761119, sdlog = 1.05201785573431), pars = list(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.16206173752339, log_sdlog1 = -0.125798239499222, meanlog2 = 3.81134425274013, log_sdlog2 = -0.556825392185898, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.10056111509066, log_sdlog1 = 0.205450849919085, meanlog2 = 3.29666779842978, log_sdlog2 = -0.306715469257007, pmix = 0.3), value = 43.7405806968797, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.10806901294958, -0.534157452938338, 0.372742203584499, -0.0953397439732499, -3.845106624433, -0.534157452938338, 3.96201126055292, 1.99526595742094, 0.201699249151078, 1.09304102786659, 
    0.372742203584499, 1.99526595742094, 10.3372574319162, 0.633396133716582, -3.98711529205142, -0.0953397439732499, 0.201699249151078, 0.633396133716582, 12.388720589456, 0.792657683189083, -3.845106624433, 1.09304102786659, -3.98711529205142, 0.792657683189083, 14.4747599477348)), est = c(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, sdlog1 = 1.22807861931498, sdlog2 = 0.735859945900444), pars = list(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, 
        log_sdlog1 = 0.205450849919085, log_sdlog2 = -0.306715469257007), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0261006526172895, log_scale = 3.49407828676558), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.169571830144152, log_scale = 3.44710520115741), value = 43.6807922745908, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.5449756612725, -4.97000758937715, -4.97000758937715, 14.0374532123274)), est = c(scale = 31.4093368667314, shape = 1.18479744814816), pars = list(log_scale = 3.44710520115741, log_shape = 0.169571830144152), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,2.95574,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,FALSE,10,Boron,Anacystis nidulans,50,Plant,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.296961095837491, log_scale = 3.0921637045904), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.261440996953924, log_scale = 3.12768679876144), value = 43.6947412117056, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.1578440455155, 12.9880041437013, 12.9880041437013, 12.9879663232819)), est = c(scale = 22.8211285756601, shape = 1.29880030613677), pars = list(log_scale = 3.12768679876144, log_shape = 0.261440996953924), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.352240607534656), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), value = 45.9330602035977, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.2733281997642, -4.46045016373558, -4.46045016373558, 23.2160273096977)), est = c(locationlog = 2.39783588813966, scalelog = 1.17255556905755), pars = list(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.698814197814629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), value = 44.256651435281, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.48684532860544, 0.0875077924964762, 0.0875077924964762, 14.4456093113738)), est = c(locationlog = 3.01880130017102, scalelog = 0.590352831830035), pars = list(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.98670299513176, log_sdlog = 0.10235655173629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), value = 44.2678041002333, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.03553302961929, -8.90233683405559e-07, -8.90233683405559e-07, 20.0000177800354)), est = c(meanlog = 2.95713172761119, sdlog = 1.05201785573431), pars = list(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.16206173752339, log_sdlog1 = -0.125798239499222, meanlog2 = 3.81134425274013, log_sdlog2 = -0.556825392185898, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.10056111509066, log_sdlog1 = 0.205450849919085, meanlog2 = 3.29666779842978, log_sdlog2 = -0.306715469257007, pmix = 0.3), value = 43.7405806968797, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.10806901294958, -0.534157452938338, 0.372742203584499, -0.0953397439732499, -3.845106624433, -0.534157452938338, 3.96201126055292, 1.99526595742094, 0.201699249151078, 1.09304102786659, 
    0.372742203584499, 1.99526595742094, 10.3372574319162, 0.633396133716582, -3.98711529205142, -0.0953397439732499, 0.201699249151078, 0.633396133716582, 12.388720589456, 0.792657683189083, -3.845106624433, 1.09304102786659, -3.98711529205142, 0.792657683189083, 14.4747599477348)), est = c(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, sdlog1 = 1.22807861931498, sdlog2 = 0.735859945900444), pars = list(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, 
        log_sdlog1 = 0.205450849919085, log_sdlog2 = -0.306715469257007), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0261006526172895, log_scale = 3.49407828676558), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.169571830144152, log_scale = 3.44710520115741), value = 43.6807922745908, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.5449756612725, -4.97000758937715, -4.97000758937715, 14.0374532123274)), est = c(scale = 31.4093368667314, shape = 1.18479744814816), pars = list(log_scale = 3.44710520115741, log_shape = 0.169571830144152), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,2.95574,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,FALSE,10,Boron,Selenastrum capricornutum,12.3,Plant,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.296961095837491, log_scale = 3.0921637045904), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.261440996953924, log_scale = 3.12768679876144), value = 43.6947412117056, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.1578440455155, 12.9880041437013, 12.9880041437013, 12.9879663232819)), est = c(scale = 22.8211285756601, shape = 1.29880030613677), pars = list(log_scale = 3.12768679876144, log_shape = 0.261440996953924), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.352240607534656), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), value = 45.9330602035977, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.2733281997642, -4.46045016373558, -4.46045016373558, 23.2160273096977)), est = c(locationlog = 2.39783588813966, scalelog = 1.17255556905755), pars = list(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.698814197814629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), value = 44.256651435281, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.48684532860544, 0.0875077924964762, 0.0875077924964762, 14.4456093113738)), est = c(locationlog = 3.01880130017102, scalelog = 0.590352831830035), pars = list(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.98670299513176, log_sdlog = 0.10235655173629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), value = 44.2678041002333, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.03553302961929, -8.90233683405559e-07, -8.90233683405559e-07, 20.0000177800354)), est = c(meanlog = 2.95713172761119, sdlog = 1.05201785573431), pars = list(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.16206173752339, log_sdlog1 = -0.125798239499222, meanlog2 = 3.81134425274013, log_sdlog2 = -0.556825392185898, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.10056111509066, log_sdlog1 = 0.205450849919085, meanlog2 = 3.29666779842978, log_sdlog2 = -0.306715469257007, pmix = 0.3), value = 43.7405806968797, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.10806901294958, -0.534157452938338, 0.372742203584499, -0.0953397439732499, -3.845106624433, -0.534157452938338, 3.96201126055292, 1.99526595742094, 0.201699249151078, 1.09304102786659, 
    0.372742203584499, 1.99526595742094, 10.3372574319162, 0.633396133716582, -3.98711529205142, -0.0953397439732499, 0.201699249151078, 0.633396133716582, 12.388720589456, 0.792657683189083, -3.845106624433, 1.09304102786659, -3.98711529205142, 0.792657683189083, 14.4747599477348)), est = c(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, sdlog1 = 1.22807861931498, sdlog2 = 0.735859945900444), pars = list(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, 
        log_sdlog1 = 0.205450849919085, log_sdlog2 = -0.306715469257007), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0261006526172895, log_scale = 3.49407828676558), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.169571830144152, log_scale = 3.44710520115741), value = 43.6807922745908, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.5449756612725, -4.97000758937715, -4.97000758937715, 14.0374532123274)), est = c(scale = 31.4093368667314, shape = 1.18479744814816), pars = list(log_scale = 3.44710520115741, log_shape = 0.169571830144152), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,2.95574,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,FALSE,10,Boron,Opercularia bimarginata,10,Invertebrate,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.296961095837491, log_scale = 3.0921637045904), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.261440996953924, log_scale = 3.12768679876144), value = 43.6947412117056, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.1578440455155, 12.9880041437013, 12.9880041437013, 12.9879663232819)), est = c(scale = 22.8211285756601, shape = 1.29880030613677), pars = list(log_scale = 3.12768679876144, log_shape = 0.261440996953924), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.352240607534656), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), value = 45.9330602035977, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.2733281997642, -4.46045016373558, -4.46045016373558, 23.2160273096977)), est = c(locationlog = 2.39783588813966, scalelog = 1.17255556905755), pars = list(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.698814197814629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), value = 44.256651435281, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.48684532860544, 0.0875077924964762, 0.0875077924964762, 14.4456093113738)), est = c(locationlog = 3.01880130017102, scalelog = 0.590352831830035), pars = list(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.98670299513176, log_sdlog = 0.10235655173629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), value = 44.2678041002333, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.03553302961929, -8.90233683405559e-07, -8.90233683405559e-07, 20.0000177800354)), est = c(meanlog = 2.95713172761119, sdlog = 1.05201785573431), pars = list(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.16206173752339, log_sdlog1 = -0.125798239499222, meanlog2 = 3.81134425274013, log_sdlog2 = -0.556825392185898, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.10056111509066, log_sdlog1 = 0.205450849919085, meanlog2 = 3.29666779842978, log_sdlog2 = -0.306715469257007, pmix = 0.3), value = 43.7405806968797, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.10806901294958, -0.534157452938338, 0.372742203584499, -0.0953397439732499, -3.845106624433, -0.534157452938338, 3.96201126055292, 1.99526595742094, 0.201699249151078, 1.09304102786659, 
    0.372742203584499, 1.99526595742094, 10.3372574319162, 0.633396133716582, -3.98711529205142, -0.0953397439732499, 0.201699249151078, 0.633396133716582, 12.388720589456, 0.792657683189083, -3.845106624433, 1.09304102786659, -3.98711529205142, 0.792657683189083, 14.4747599477348)), est = c(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, sdlog1 = 1.22807861931498, sdlog2 = 0.735859945900444), pars = list(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, 
        log_sdlog1 = 0.205450849919085, log_sdlog2 = -0.306715469257007), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0261006526172895, log_scale = 3.49407828676558), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.169571830144152, log_scale = 3.44710520115741), value = 43.6807922745908, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.5449756612725, -4.97000758937715, -4.97000758937715, 14.0374532123274)), est = c(scale = 31.4093368667314, shape = 1.18479744814816), pars = list(log_scale = 3.44710520115741, log_shape = 0.169571830144152), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,2.95574,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,FALSE,10,Boron,Entosiphon sulcatum,15,Invertebrate,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.296961095837491, log_scale = 3.0921637045904), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.261440996953924, log_scale = 3.12768679876144), value = 43.6947412117056, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.1578440455155, 12.9880041437013, 12.9880041437013, 12.9879663232819)), est = c(scale = 22.8211285756601, shape = 1.29880030613677), pars = list(log_scale = 3.12768679876144, log_shape = 0.261440996953924), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.352240607534656), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), value = 45.9330602035977, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.2733281997642, -4.46045016373558, -4.46045016373558, 23.2160273096977)), est = c(locationlog = 2.39783588813966, scalelog = 1.17255556905755), pars = list(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.698814197814629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), value = 44.256651435281, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.48684532860544, 0.0875077924964762, 0.0875077924964762, 14.4456093113738)), est = c(locationlog = 3.01880130017102, scalelog = 0.590352831830035), pars = list(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.98670299513176, log_sdlog = 0.10235655173629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), value = 44.2678041002333, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.03553302961929, -8.90233683405559e-07, -8.90233683405559e-07, 20.0000177800354)), est = c(meanlog = 2.95713172761119, sdlog = 1.05201785573431), pars = list(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.16206173752339, log_sdlog1 = -0.125798239499222, meanlog2 = 3.81134425274013, log_sdlog2 = -0.556825392185898, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.10056111509066, log_sdlog1 = 0.205450849919085, meanlog2 = 3.29666779842978, log_sdlog2 = -0.306715469257007, pmix = 0.3), value = 43.7405806968797, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.10806901294958, -0.534157452938338, 0.372742203584499, -0.0953397439732499, -3.845106624433, -0.534157452938338, 3.96201126055292, 1.99526595742094, 0.201699249151078, 1.09304102786659, 
    0.372742203584499, 1.99526595742094, 10.3372574319162, 0.633396133716582, -3.98711529205142, -0.0953397439732499, 0.201699249151078, 0.633396133716582, 12.388720589456, 0.792657683189083, -3.845106624433, 1.09304102786659, -3.98711529205142, 0.792657683189083, 14.4747599477348)), est = c(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, sdlog1 = 1.22807861931498, sdlog2 = 0.735859945900444), pars = list(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, 
        log_sdlog1 = 0.205450849919085, log_sdlog2 = -0.306715469257007), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0261006526172895, log_scale = 3.49407828676558), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.169571830144152, log_scale = 3.44710520115741), value = 43.6807922745908, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.5449756612725, -4.97000758937715, -4.97000758937715, 14.0374532123274)), est = c(scale = 31.4093368667314, shape = 1.18479744814816), pars = list(log_scale = 3.44710520115741, log_shape = 0.169571830144152), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,2.95574,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
2,1,FALSE,10,Boron,Ambystoma jeffersonianum,70.7,Amphibian,mg/L,"list(gamma = list(dist = ""gamma"", model = list(par = c(log_shape = 0.296961095837491, log_scale = 3.0921637045904), fn = function (x = last.par[lfixed()], ...) 
{
    if (tracepar) {
        cat(""par:\n"")
        print(x)
    }
    if (!validpar(x)) 
        return(NaN)
    if (is.null(random)) {
        ans <- f(x, order = 0)
        if (!ADreport) {
            if (is.finite(ans) && ans < value.best) {
                last.par.best <<- x
                value.best <<- ans
            }
        }
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
            }
            else ff(x, order = 0)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- NaN
    }
    ans
}, gr = function (x = last.par[lfixed()], ...) 
{
    if (is.null(random)) {
        ans <- f(x, order = 1)
    }
    else {
        ans <- try({
            if (MCcontrol$doMC) {
                ff(x, order = 0)
                MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
            }
            else ff(x, order = 1)
        }, silent = silent)
        if (is.character(ans)) 
            ans <- rep(NaN, length(x))
    }
    if (tracemgc) 
        cat(""outer mgc: "", max(abs(ans)), ""\n"")
    ans
}, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
{
    if (is.null(random)) {
        if (!atomic) 
            return(f(x, order = 2))
        if (is.null(ADGrad)) 
            retape_adgrad()
        return(f(x, type = ""ADGrad"", order = 1))
    }
    else {
        stop(""Hessian not yet implemented for models with random effects."")
    }
}, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
{
    omp <- config(DLL = DLL)
    random <<- .random
    if (atomic) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
        ADreportDims <<- attr(out, ""reportdims"")
    }
    if (is.character(profile)) {
        random <<- c(random, profile)
    }
    if (is.character(random)) {
        if (!regexp) {
            if (!all(random %in% names(parameters))) {
                cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                print(setdiff(random, names(parameters)))
                cat(""(Note that regular expression match is disabled by default)\n"")
                stop()
            }
            if (any(duplicated(random))) {
                cat(""Duplicates in 'random' - will be removed\n"")
                random <<- unique(random)
            }
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
            random <<- which(as.logical(unlist(tmp)))
            if (length(random) == 0) 
                random <<- NULL
        }
        if (regexp) {
            random <<- grepRandomParameters(parameters, random)
            if (length(random) == 0) {
                cat(""Selected random effects did not match any model parameters.\n"")
                random <<- NULL
            }
        }
        if (is.character(profile)) {
            tmp <- lapply(parameters, function(x) x * 0)
            tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
            profile <<- match(which(as.logical(unlist(tmp))), random)
            if (length(profile) == 0) 
                random <<- NULL
            if (any(duplicated(profile))) 
                stop(""Profile parameter vector not unique."")
            tmp <- rep(0, length(random))
            tmp[profile] <- 1
            profile <<- tmp
        }
        if (set.defaults) {
            par <<- unlist(parameters)
        }
    }
    if (""ADFun"" %in% type) {
        if (omp$autopar) 
            openmp(1, DLL = DLL)
        ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
        if (omp$autopar) 
            openmp(omp$nthreads, DLL = DLL)
        if (!is.null(integrate)) {
            nm <- sapply(parameters, length)
            nmpar <- rep(names(nm), nm)
            for (i in seq_along(integrate)) {
                I <- integrate[i]
                if (is.null(names(I)) || names(I) == """") {
                  I <- I[[1]]
                }
                ok <- all(names(I) %in% nmpar[random])
                if (!ok) 
                  stop(""Names to be 'integrate'd must be among the random parameters"")
                w <- which(nmpar[random] %in% names(I))
                arg_which <- I[[1]]$which
                if (!is.null(arg_which)) 
                  w <- w[arg_which]
                method <- sapply(I, function(x) x$method)
                ok <- all(duplicated(method)[-1])
                if (!ok) 
                  stop(""Grouping only allowed for identical methods"")
                method <- method[1]
                cfg <- NULL
                if (method == ""marginal_sr"") {
                  fac <- factor(nmpar[random[w]], levels = names(I))
                  cfg <- list(grid = I, random2grid = fac)
                }
                else {
                  cfg <- I[[1]]
                }
                stopifnot(is.list(cfg))
                TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                activeDomain <- as.logical(info(ADFun)$activeDomain)
                random_remove <- random[w][!activeDomain[random[w]]]
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                par_mask[random] <- TRUE
                par <<- par[-random_remove]
                nmpar <- nmpar[-random_remove]
                par_mask <- par_mask[-random_remove]
                random <<- which(par_mask)
                if (length(random) == 0) {
                  random <<- NULL
                  type <<- setdiff(type, ""ADGrad"")
                }
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
        }
        if (intern) {
            cfg <- inner.control
            if (is.null(cfg$sparse)) 
                cfg$sparse <- TRUE
            cfg <- lapply(cfg, as.double)
            TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
            TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
            attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
            par <<- par[-random]
            random <<- NULL
            if (config(DLL = DLL)$optimize.instantly) {
                TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
            }
        }
        if (set.defaults) {
            par <<- attr(ADFun$ptr, ""par"")
            last.par <<- par
            last.par1 <<- par
            last.par2 <<- par
            last.par.best <<- par
            value.best <<- Inf
        }
    }
    if (omp$autopar && !ADreport) {
        TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
    }
    if (length(random) > 0) {
        TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
    }
    if (""Fun"" %in% type) {
        Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
    }
    if (""ADGrad"" %in% type) {
        retape_adgrad(lazy = TRUE)
    }
    env$skipFixedEffects <- !is.null(ADGrad)
    delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
}, env = <environment>, report = function (par = last.par) 
{
    f(par, order = 0, type = ""double"")
    as.list(reportenv)
}, simulate = function (par = last.par, complete = FALSE) 
{
    f(par, order = 0, type = ""double"", do_simulate = TRUE)
    sim <- as.list(reportenv)
    if (complete) {
        ans <- data
        ans[names(sim)] <- sim
    }
    else {
        ans <- sim
    }
    ans
}), optim = list(par = c(log_shape = 0.261440996953924, log_scale = 3.12768679876144), value = 43.6947412117056, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(19.1578440455155, 12.9880041437013, 12.9880041437013, 12.9879663232819)), est = c(scale = 22.8211285756601, shape = 1.29880030613677), pars = list(log_scale = 3.12768679876144, log_shape = 0.261440996953924), flags = list(at_boundary = FALSE, computable = TRUE)), 
    lgumbel = list(dist = ""lgumbel"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.352240607534656), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), value = 45.9330602035977, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(7.2733281997642, -4.46045016373558, -4.46045016373558, 23.2160273096977)), est = c(locationlog = 2.39783588813966, scalelog = 1.17255556905755), pars = list(locationlog = 2.39783588813966, log_scalelog = 0.15918561386775), flags = list(at_boundary = FALSE, 
        computable = TRUE)), llogis = list(dist = ""llogis"", model = list(par = c(locationlog = 2.95713167834827, log_scalelog = 0.698814197814629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), value = 44.256651435281, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.48684532860544, 0.0875077924964762, 0.0875077924964762, 14.4456093113738)), est = c(locationlog = 3.01880130017102, scalelog = 0.590352831830035), pars = list(locationlog = 3.01880130017102, log_scalelog = -0.527034900774199), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm = list(dist = ""lnorm"", model = list(par = c(meanlog = 2.98670299513176, log_sdlog = 0.10235655173629), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), value = 44.2678041002333, counts = c(`function` = 7, gradient = 7), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(9.03553302961929, -8.90233683405559e-07, -8.90233683405559e-07, 20.0000177800354)), est = c(meanlog = 2.95713172761119, sdlog = 1.05201785573431), pars = list(meanlog = 2.95713172761119, log_sdlog = 0.0507100873029472), flags = list(at_boundary = FALSE, 
        computable = TRUE)), lnorm_lnorm = list(dist = ""lnorm_lnorm"", model = list(par = c(meanlog1 = 2.16206173752339, log_sdlog1 = -0.125798239499222, meanlog2 = 3.81134425274013, log_sdlog2 = -0.556825392185898, pmix = 0.5), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(meanlog1 = 2.10056111509066, log_sdlog1 = 0.205450849919085, meanlog2 = 3.29666779842978, log_sdlog2 = -0.306715469257007, pmix = 0.3), value = 43.7405806968797, counts = c(`function` = 15, gradient = 15), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(1.10806901294958, -0.534157452938338, 0.372742203584499, -0.0953397439732499, -3.845106624433, -0.534157452938338, 3.96201126055292, 1.99526595742094, 0.201699249151078, 1.09304102786659, 
    0.372742203584499, 1.99526595742094, 10.3372574319162, 0.633396133716582, -3.98711529205142, -0.0953397439732499, 0.201699249151078, 0.633396133716582, 12.388720589456, 0.792657683189083, -3.845106624433, 1.09304102786659, -3.98711529205142, 0.792657683189083, 14.4747599477348)), est = c(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, sdlog1 = 1.22807861931498, sdlog2 = 0.735859945900444), pars = list(meanlog1 = 2.10056111509066, meanlog2 = 3.29666779842978, pmix = 0.3, 
        log_sdlog1 = 0.205450849919085, log_sdlog2 = -0.306715469257007), flags = list(at_boundary = TRUE, computable = TRUE)), weibull = list(dist = ""weibull"", model = list(par = c(log_shape = -0.0261006526172895, log_scale = 3.49407828676558), fn = function (x = last.par[lfixed()], ...) 
    {
        if (tracepar) {
            cat(""par:\n"")
            print(x)
        }
        if (!validpar(x)) 
            return(NaN)
        if (is.null(random)) {
            ans <- f(x, order = 0)
            if (!ADreport) {
                if (is.finite(ans) && ans < value.best) {
                  last.par.best <<- x
                  value.best <<- ans
                }
            }
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 0)
                }
                else ff(x, order = 0)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- NaN
        }
        ans
    }, gr = function (x = last.par[lfixed()], ...) 
    {
        if (is.null(random)) {
            ans <- f(x, order = 1)
        }
        else {
            ans <- try({
                if (MCcontrol$doMC) {
                  ff(x, order = 0)
                  MC(last.par, n = MCcontrol$n, seed = MCcontrol$seed, order = 1)
                }
                else ff(x, order = 1)
            }, silent = silent)
            if (is.character(ans)) 
                ans <- rep(NaN, length(x))
        }
        if (tracemgc) 
            cat(""outer mgc: "", max(abs(ans)), ""\n"")
        ans
    }, he = function (x = last.par[lfixed()], atomic = usingAtomics()) 
    {
        if (is.null(random)) {
            if (!atomic) 
                return(f(x, order = 2))
            if (is.null(ADGrad)) 
                retape_adgrad()
            return(f(x, type = ""ADGrad"", order = 1))
        }
        else {
            stop(""Hessian not yet implemented for models with random effects."")
        }
    }, hessian = FALSE, method = ""BFGS"", retape = function (set.defaults = TRUE) 
    {
        omp <- config(DLL = DLL)
        random <<- .random
        if (atomic) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
            out <- EvalDoubleFunObject(Fun, unlist(parameters), get_reportdims = TRUE)
            ADreportDims <<- attr(out, ""reportdims"")
        }
        if (is.character(profile)) {
            random <<- c(random, profile)
        }
        if (is.character(random)) {
            if (!regexp) {
                if (!all(random %in% names(parameters))) {
                  cat(""Some 'random' effect names does not match 'parameter' list:\n"")
                  print(setdiff(random, names(parameters)))
                  cat(""(Note that regular expression match is disabled by default)\n"")
                  stop()
                }
                if (any(duplicated(random))) {
                  cat(""Duplicates in 'random' - will be removed\n"")
                  random <<- unique(random)
                }
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[random] <- lapply(tmp[random], function(x) x * 0 + 1)
                random <<- which(as.logical(unlist(tmp)))
                if (length(random) == 0) 
                  random <<- NULL
            }
            if (regexp) {
                random <<- grepRandomParameters(parameters, random)
                if (length(random) == 0) {
                  cat(""Selected random effects did not match any model parameters.\n"")
                  random <<- NULL
                }
            }
            if (is.character(profile)) {
                tmp <- lapply(parameters, function(x) x * 0)
                tmp[profile] <- lapply(tmp[profile], function(x) x * 0 + 1)
                profile <<- match(which(as.logical(unlist(tmp))), random)
                if (length(profile) == 0) 
                  random <<- NULL
                if (any(duplicated(profile))) 
                  stop(""Profile parameter vector not unique."")
                tmp <- rep(0, length(random))
                tmp[profile] <- 1
                profile <<- tmp
            }
            if (set.defaults) {
                par <<- unlist(parameters)
            }
        }
        if (""ADFun"" %in% type) {
            if (omp$autopar) 
                openmp(1, DLL = DLL)
            ADFun <<- MakeADFunObject(data, parameters, reportenv, ADreport = ADreport, DLL = DLL)
            if (omp$autopar) 
                openmp(omp$nthreads, DLL = DLL)
            if (!is.null(integrate)) {
                nm <- sapply(parameters, length)
                nmpar <- rep(names(nm), nm)
                for (i in seq_along(integrate)) {
                  I <- integrate[i]
                  if (is.null(names(I)) || names(I) == """") {
                    I <- I[[1]]
                  }
                  ok <- all(names(I) %in% nmpar[random])
                  if (!ok) 
                    stop(""Names to be 'integrate'd must be among the random parameters"")
                  w <- which(nmpar[random] %in% names(I))
                  arg_which <- I[[1]]$which
                  if (!is.null(arg_which)) 
                    w <- w[arg_which]
                  method <- sapply(I, function(x) x$method)
                  ok <- all(duplicated(method)[-1])
                  if (!ok) 
                    stop(""Grouping only allowed for identical methods"")
                  method <- method[1]
                  cfg <- NULL
                  if (method == ""marginal_sr"") {
                    fac <- factor(nmpar[random[w]], levels = names(I))
                    cfg <- list(grid = I, random2grid = fac)
                  }
                  else {
                    cfg <- I[[1]]
                  }
                  stopifnot(is.list(cfg))
                  TransformADFunObject(ADFun, method = method, random_order = random[w], config = cfg, mustWork = 1)
                  activeDomain <- as.logical(info(ADFun)$activeDomain)
                  random_remove <- random[w][!activeDomain[random[w]]]
                  TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random_remove, mustWork = 1)
                  attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random_remove]
                  par_mask <- rep(FALSE, length(attr(ADFun$ptr, ""par"")))
                  par_mask[random] <- TRUE
                  par <<- par[-random_remove]
                  nmpar <- nmpar[-random_remove]
                  par_mask <- par_mask[-random_remove]
                  random <<- which(par_mask)
                  if (length(random) == 0) {
                    random <<- NULL
                    type <<- setdiff(type, ""ADGrad"")
                  }
                  if (config(DLL = DLL)$optimize.instantly) {
                    TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                  }
                }
            }
            if (intern) {
                cfg <- inner.control
                if (is.null(cfg$sparse)) 
                  cfg$sparse <- TRUE
                cfg <- lapply(cfg, as.double)
                TransformADFunObject(ADFun, method = ""laplace"", config = cfg, random_order = random, mustWork = 1)
                TransformADFunObject(ADFun, method = ""remove_random_parameters"", random_order = random, mustWork = 1)
                attr(ADFun$ptr, ""par"") <- attr(ADFun$ptr, ""par"")[-random]
                par <<- par[-random]
                random <<- NULL
                if (config(DLL = DLL)$optimize.instantly) {
                  TransformADFunObject(ADFun, method = ""optimize"", mustWork = 1)
                }
            }
            if (set.defaults) {
                par <<- attr(ADFun$ptr, ""par"")
                last.par <<- par
                last.par1 <<- par
                last.par2 <<- par
                last.par.best <<- par
                value.best <<- Inf
            }
        }
        if (omp$autopar && !ADreport) {
            TransformADFunObject(ADFun, method = ""parallel_accumulate"", num_threads = as.integer(openmp(DLL = DLL)), mustWork = 0)
        }
        if (length(random) > 0) {
            TransformADFunObject(ADFun, method = ""reorder_random"", random_order = random, mustWork = 0)
        }
        if (""Fun"" %in% type) {
            Fun <<- MakeDoubleFunObject(data, parameters, reportenv, DLL = DLL)
        }
        if (""ADGrad"" %in% type) {
            retape_adgrad(lazy = TRUE)
        }
        env$skipFixedEffects <- !is.null(ADGrad)
        delayedAssign(""spHess"", sparseHessianFun(env, skipFixedEffects = skipFixedEffects), assign.env = env)
    }, env = <environment>, report = function (par = last.par) 
    {
        f(par, order = 0, type = ""double"")
        as.list(reportenv)
    }, simulate = function (par = last.par, complete = FALSE) 
    {
        f(par, order = 0, type = ""double"", do_simulate = TRUE)
        sim <- as.list(reportenv)
        if (complete) {
            ans <- data
            ans[names(sim)] <- sim
        }
        else {
            ans <- sim
        }
        ans
    }), optim = list(par = c(log_shape = 0.169571830144152, log_scale = 3.44710520115741), value = 43.6807922745908, counts = c(`function` = 9, gradient = 9), convergence = 0, message = ""CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH"", hessian = c(17.5449756612725, -4.97000758937715, -4.97000758937715, 14.0374532123274)), est = c(scale = 31.4093368667314, shape = 1.18479744814816), pars = list(log_scale = 3.44710520115741, log_shape = 0.169571830144152), flags = list(at_boundary = FALSE, computable = TRUE)))",average,0.05,2.95574,NA,NA,NA,1,0.95,multi,weighted_samples,parametric,0,1,"c(""gamma"", ""lgumbel"", ""llogis"", ""lnorm"", ""weibull"")",numeric(0)
